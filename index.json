[{"categories":["MyBatis学习"],"content":"核心配置文件 官方推荐名称：mybatis-config.xml MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息 ","date":"2022-07-05","objectID":"/mybatis_learning2/:1:0","tags":["MyBatis","SQL","SSM"],"title":"MyBatis学习2","uri":"/mybatis_learning2/"},{"categories":["MyBatis学习"],"content":"核心配置点 configuration properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） ","date":"2022-07-05","objectID":"/mybatis_learning2/:1:1","tags":["MyBatis","SQL","SSM"],"title":"MyBatis学习2","uri":"/mybatis_learning2/"},{"categories":["MyBatis学习"],"content":"环境配置 environments MyBatis 可以配置成适应多种环境 尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境 如果你想连接两个数据库，就需要创建两个 SqlSessionFactory 实例，每个数据库对应一个 如果需要切换环境，则将 \u003cenvironments default=\"development\"\u003e 中的default对应的环境更换 datasource：数据源，进行数据库连接 （没有连接池unpooled/有数据池pooled/直接连接jndi） ","date":"2022-07-05","objectID":"/mybatis_learning2/:1:2","tags":["MyBatis","SQL","SSM"],"title":"MyBatis学习2","uri":"/mybatis_learning2/"},{"categories":["MyBatis学习"],"content":"属性 properties 可以通过properties属性，引用配置文件 编写一个配置文件 db.properties driver=com.mysql.cj.jdbc.Driver url=jdbc:mysql://localhost:3306/mybatis?useSSL=true\u0026useUnicode=true\u0026characterEncoding=UTF-8\u0026serverTimezone=GMT username=root password=Wby785403310 在mybatis配置文件mybatis-config.xml中引入 db.properties，并在environment中设置为properties中的value \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003c!--数据库相关配置--\u003e \u003cproperty name=\"driver\" value=\"${driver}\"/\u003e \u003cproperty name=\"url\" value=\"${url}\"/\u003e \u003cproperty name=\"username\" value=\"${username}\"/\u003e \u003cproperty name=\"password\" value=\"${password}\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e ","date":"2022-07-05","objectID":"/mybatis_learning2/:1:3","tags":["MyBatis","SQL","SSM"],"title":"MyBatis学习2","uri":"/mybatis_learning2/"},{"categories":["MyBatis学习"],"content":"什么是 MyBatis MyBatis 是一款优秀的持久层框架 它支持自定义 SQL、存储过程以及高级映射。 MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。 MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 ","date":"2022-07-04","objectID":"/mybatis_learning1/:1:0","tags":["MyBatis","SQL","SSM"],"title":"MyBatis学习1","uri":"/mybatis_learning1/"},{"categories":["MyBatis学习"],"content":"如何获得MyBatis maven仓库 \u003c!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.2\u003c/version\u003e \u003c/dependency\u003e Github：release 地址 中文文档 ","date":"2022-07-04","objectID":"/mybatis_learning1/:2:0","tags":["MyBatis","SQL","SSM"],"title":"MyBatis学习1","uri":"/mybatis_learning1/"},{"categories":["MyBatis学习"],"content":"第一个MyBatis 程序 思路：搭建环境 -》 导入MyBatis -》编写代码 -》测试 ","date":"2022-07-04","objectID":"/mybatis_learning1/:3:0","tags":["MyBatis","SQL","SSM"],"title":"MyBatis学习1","uri":"/mybatis_learning1/"},{"categories":["MyBatis学习"],"content":"搭建环境 搭建数据库 createdatabase`mybatis`;use`mybatis`;createtable`user`(`id`int(20)notnull,`name`varchar(30)defaultnull,`pwd`varchar(30)defaultnull,primarykey(`id`))engine=InnoDBdefaultcharset=utf8;insertinto`user`(`id`,`name`,`pwd`)values(1,'swagger','123456'),(2,'boyan','123456'),(3,'lisi','123456'); 新建一个maven项目 新建一个普通的maven项目 删除src目录（父工程） 导入maven依赖 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003c!-- 父工程 --\u003e \u003cgroupId\u003eorg.example\u003c/groupId\u003e \u003cartifactId\u003eMyBatis_learning\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003cproperties\u003e \u003cmaven.compiler.source\u003e16\u003c/maven.compiler.source\u003e \u003cmaven.compiler.target\u003e16\u003c/maven.compiler.target\u003e \u003c/properties\u003e \u003c!-- 导入依赖 --\u003e \u003cdependencies\u003e \u003c!--mysql 驱动--\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e5.1.45\u003c/version\u003e \u003c/dependency\u003e \u003c!--mybatis--\u003e \u003c!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.1\u003c/version\u003e \u003c/dependency\u003e \u003c!--junit--\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.12\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e 创建一个模块，编写配置文件和工具类 编写MyBatis核心配置文件 \u003cconfiguration\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003c!--数据库相关配置--\u003e \u003cproperty name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\"/\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?useSSL=true\u0026amp;useUnicode=true\u0026amp;characterEncoding=UTF-8\u0026amp;serverTimezone=GMT\"/\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"Wby785403310\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003c/configuration\u003e 编写MyBatis工具类 package com.swagger.utils; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; // sqlSessionFactory --\u003e sqlSession public class MyBatisUtils { private static SqlSessionFactory sqlSessionFactory; static { try { // 设计模式：工厂模式 // 1 获取sqlSessionFactory对象 String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } } // 2 从中获取SqlSession 实例 // 既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。 // SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。 public static SqlSession getSqlSession(){ return sqlSessionFactory.openSession(); } } 编写代码 实体类：和数据库的字段严格对应 package com.swagger.pojo; // 和数据库对应的实体类 public class User { private int id; private String name; private String pwd; public User() { } public User(int id, String name, String pwd) { this.id = id; this.name = name; this.pwd = pwd; } public int getId() { return id; } public String getName() { return name; } public String getPwd() { return pwd; } public void setId(int id) { this.id = id; } public void setName(String name) { this.name = name; } public void setPwd(String pwd) { this.pwd = pwd; } @Override public String toString() { return \"User{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", pwd='\" + pwd + '\\'' + '}'; } } Dao接口 package com.swagger.dao; import com.swagger.pojo.User; import java.util.List; // Data Access object // 等价于mapper public interface UserDao { List\u003cUser\u003e getUserList(); } 接口实现类由原来的UserDaoImpl转化为一个mapper.xml配置文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003c!--namespace=绑定一个对应的Dao/Mapper接口--\u003e \u003cmapper namespace=\"com.swagger.dao.UserDao\"\u003e \u003c!-- select 查询语句 id 相当于UserDao中提取操作接口的名字--\u003e \u003cselect id=\"ge","date":"2022-07-04","objectID":"/mybatis_learning1/:3:1","tags":["MyBatis","SQL","SSM"],"title":"MyBatis学习1","uri":"/mybatis_learning1/"},{"categories":["MyBatis学习"],"content":"CRUD ","date":"2022-07-04","objectID":"/mybatis_learning1/:4:0","tags":["MyBatis","SQL","SSM"],"title":"MyBatis学习1","uri":"/mybatis_learning1/"},{"categories":["MyBatis学习"],"content":"UserMapper.xml文件 namespace：namespace中的包名要和Dao/Mapper中的接口名称一致 select：选择，查询语句 id：就是对应namespace中的方法名称 resultType：sql语句执行的返回值类型 parameterType：参数类型 ","date":"2022-07-04","objectID":"/mybatis_learning1/:4:1","tags":["MyBatis","SQL","SSM"],"title":"MyBatis学习1","uri":"/mybatis_learning1/"},{"categories":["MyBatis学习"],"content":"代码实战 UserMapper.java接口中添加抽象方法，返回类型和参数类型需要注意 package com.swagger.dao; import com.swagger.pojo.User; import java.util.List; // Data Access object // 等价于mapper public interface UserMapper { // 获取全部用户 List\u003cUser\u003e getUserList(); // 根据id查询用户 User getUserById(int id); // insert 一个用户 int addUser(User user); // update 修改用户 int updateUser(User user); // delete 删除一个用户 int deleteUser(int id); } UserMapper.xml 中添加对应的标签和sql语句，返回类型和参数类型需要对应 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003c!--namespace=绑定一个对应的Dao/Mapper接口--\u003e \u003cmapper namespace=\"com.swagger.dao.UserMapper\"\u003e \u003c!-- select 查询语句 id 相当于UserDao中提取操作接口的名字--\u003e \u003cselect id=\"getUserList\" resultType=\"com.swagger.pojo.User\"\u003e select * from mybatis.user \u003c/select\u003e \u003c!-- 根据id查询用户 --\u003e \u003cselect id=\"getUserById\" parameterType=\"int\" resultType=\"com.swagger.pojo.User\"\u003e select * from mybatis.user where id = #{id} \u003c/select\u003e \u003c!-- 对象中的属性，可以直接取出来 插入一个用户--\u003e \u003cinsert id=\"addUser\" parameterType=\"com.swagger.pojo.User\"\u003e insert into mybatis.user (id, name, pwd) values (#{id}, #{name}, #{pwd}) \u003c/insert\u003e \u003c!--update 修改用户--\u003e \u003cupdate id=\"updateUser\" parameterType=\"com.swagger.pojo.User\"\u003e update mybatis.user set name = #{name}, pwd = #{pwd} where id = #{id} \u003c/update\u003e \u003cdelete id=\"deleteUser\" parameterType=\"int\"\u003e delete from mybatis.user where id = #{id} \u003c/delete\u003e \u003c/mapper\u003e 测试类中进行测试 package com.swagger.dao; import com.swagger.pojo.User; import com.swagger.utils.MyBatisUtils; import org.apache.ibatis.session.SqlSession; import org.junit.Test; import java.util.List; public class UserMapperTest { @Test public void test(){ // 1 获得sqlSession对象 SqlSession sqlSession = MyBatisUtils.getSqlSession(); // 2 方式1： 执行sql UserMapper userMapper = sqlSession.getMapper(UserMapper.class); List\u003cUser\u003e userList = userMapper.getUserList(); for (User user : userList) { System.out.println(user); } // 关闭sqlSession sqlSession.close(); } // 增删改需要提交事务 // 查 @Test public void test_getUserById(){ SqlSession sqlSession = MyBatisUtils.getSqlSession(); int id = 1; UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User userById = userMapper.getUserById(1); System.out.println(userById); sqlSession.close(); } // @Test public void test_addUser(){ SqlSession sqlSession = MyBatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); int i = mapper.addUser(new User(4, \"haha\", \"123456\")); if (i\u003e0){ System.out.println(\"插入成功\"); // 提交事务 sqlSession.commit(); } sqlSession.close(); } @Test public void test_updateUser(){ SqlSession sqlSession = MyBatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); int i = mapper.updateUser(new User(4, \"hehe\", \"1234\")); if (i\u003e0){ System.out.println(\"修改成功\"); sqlSession.commit(); } sqlSession.close(); } @Test public void test_deleteUser(){ SqlSession sqlSession = MyBatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); int i = mapper.deleteUser(3); if (i\u003e0){ System.out.println(\"删除成功\"); sqlSession.commit(); } sqlSession.close(); } } tips：增删改需要对事务进行提交 sqlSession.commit(); ","date":"2022-07-04","objectID":"/mybatis_learning1/:4:2","tags":["MyBatis","SQL","SSM"],"title":"MyBatis学习1","uri":"/mybatis_learning1/"},{"categories":["MyBatis学习"],"content":"错误分析 标签名字不能和具体的sql关键词相冲突 resources 注册mapper的路径不能使用java 点的格式来表示路径，要用斜杠/ 程序配置文件必须规范 空指针异常，没有注册到资源 maven 资源没有导出到target问题 ","date":"2022-07-04","objectID":"/mybatis_learning1/:4:3","tags":["MyBatis","SQL","SSM"],"title":"MyBatis学习1","uri":"/mybatis_learning1/"},{"categories":["MyBatis学习"],"content":"万能的map 将Dao接口中方法的输入参数换成map类型 int addUser2(Map\u003cString, Object\u003e map); 对应mapper.xml中的参数换成map中的key，即可取到具体的对应的value 编写测试类 @Test public void test_addUser2(){ SqlSession sqlSession = MyBatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); Map\u003cString, Object\u003e map = new HashMap\u003c\u003e(); map.put(\"userid\", 5); map.put(\"username\", \"boyanwei\"); map.put(\"passWord\", \"12345\"); int i = mapper.addUser2(map); if (i \u003e 0){ System.out.println(\"插入成功\"); sqlSession.commit(); } sqlSession.close(); } ","date":"2022-07-04","objectID":"/mybatis_learning1/:5:0","tags":["MyBatis","SQL","SSM"],"title":"MyBatis学习1","uri":"/mybatis_learning1/"},{"categories":["MyBatis学习"],"content":"传递参数关键点 Map传递参数，直接在SQL中取出key即可：parameterType=\"map\" 对象传递参数，直接在SQL中取出对象的属性即可： parameterType=\"Object\" 只有一个基本类型参数的情况下，可以直接在sql中取到，参数类型可以不写 tips ： 多个参数可以用map，或者注解 ","date":"2022-07-04","objectID":"/mybatis_learning1/:5:1","tags":["MyBatis","SQL","SSM"],"title":"MyBatis学习1","uri":"/mybatis_learning1/"},{"categories":["MyBatis学习"],"content":"模糊查询 like 在java代码层面使用通配符 在SQL拼接中加入通配符，但是有可能存在SQL注入问题，不安全 ","date":"2022-07-04","objectID":"/mybatis_learning1/:5:2","tags":["MyBatis","SQL","SSM"],"title":"MyBatis学习1","uri":"/mybatis_learning1/"},{"categories":["MySQL学习"],"content":"JDBC 中对象的解释 ","date":"2022-06-28","objectID":"/mysql_learning5/:1:0","tags":["SQL","mysql","navicat"],"title":"MySQL学习5","uri":"/mysql_learning5/"},{"categories":["MySQL学习"],"content":"DriverManager // 1 加载驱动 // DriverManager.registerDriver(new com.mysql.jdbc.Driver()); Class.forName(\"com.mysql.jdbc.Driver\"); // 固定写法，加载驱动 Connection connection = DriverManager.getConnection(url, username, password); // connection是代表数据库 // 数据库设置自动提交 connection.rollback(); connection.commit(); connection.setAutoCommit(); ","date":"2022-06-28","objectID":"/mysql_learning5/:1:1","tags":["SQL","mysql","navicat"],"title":"MySQL学习5","uri":"/mysql_learning5/"},{"categories":["MySQL学习"],"content":"URL String url = \"jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true\u0026characterEncoding=utf8\u0026useSSL=true\"; // 协议://主机地址:端口号/数据库名?参数1\u0026参数2\u0026参数3 // mysql 默认 3306 // oracle 默认 1521 // jdbc:oracle:thin:@主机地址:端口号:sid ","date":"2022-06-28","objectID":"/mysql_learning5/:1:2","tags":["SQL","mysql","navicat"],"title":"MySQL学习5","uri":"/mysql_learning5/"},{"categories":["MySQL学习"],"content":"Statement 执行SQL的对象 PrepareStatement执行SQL的对象 String sql = \"SELECT * FROM users;\"; statement.executeQuery(sql); // 查询操作，返回ResultSet statement.execute(sql); // 执行任何SQL statement.executeUpdate(sql); // 更新、插入、删除 都是这个，返回一个受影响的行数int statement.executeBatch(sql); // 同时执行多个SQL ","date":"2022-06-28","objectID":"/mysql_learning5/:1:3","tags":["SQL","mysql","navicat"],"title":"MySQL学习5","uri":"/mysql_learning5/"},{"categories":["MySQL学习"],"content":"ResultSet 查询的结果集：封装了所有的查询结果 resultSet.getObject(); // 不知道数据类型的时候 resultSet.getInt(); // 知道数据类型的时候 resultSet.getFloat(); resultSet.getDate(); resultSet.next() // 数据往后遍历 resultSet.previous() // 前一行 resultSet.absolute(row) // 移动到指定行数 resultSet.afterLast(); // 移动到最后面 resultSet.beforeFirst(); // 移动到最前面 ","date":"2022-06-28","objectID":"/mysql_learning5/:1:4","tags":["SQL","mysql","navicat"],"title":"MySQL学习5","uri":"/mysql_learning5/"},{"categories":["MySQL学习"],"content":"释放资源 必须要完成（很耗资源） // 6 释放连接 resultSet.close(); statement.close(); connection.close(); ","date":"2022-06-28","objectID":"/mysql_learning5/:1:5","tags":["SQL","mysql","navicat"],"title":"MySQL学习5","uri":"/mysql_learning5/"},{"categories":["MySQL学习"],"content":"Statement 对象详解 ","date":"2022-06-28","objectID":"/mysql_learning5/:2:0","tags":["SQL","mysql","navicat"],"title":"MySQL学习5","uri":"/mysql_learning5/"},{"categories":["MySQL学习"],"content":"保存数据库所需参数 src 建立一个 db.properties文件，用于保存连接数据库所需要的参数 driver=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true\u0026characterEncoding=utf8\u0026useSSL=true username=root password=Wby785403310 ","date":"2022-06-28","objectID":"/mysql_learning5/:2:1","tags":["SQL","mysql","navicat"],"title":"MySQL学习5","uri":"/mysql_learning5/"},{"categories":["MySQL学习"],"content":"编写工具类 编写工具类中读取 db.properties文件中的参数 将静态代码块中集成获取驱动 实现获取连接和释放资源方法 package com.swagger.lesson02.utils; import java.io.IOException; import java.io.InputStream; import java.sql.*; import java.util.Properties; // 数据库连接 工具类 public class JdbcUtils { private static String driver = null; private static String url = null; private static String username = null; private static String password = null; static { try { InputStream in = JdbcUtils.class.getClassLoader().getResourceAsStream(\"db.properties\"); Properties properties = new Properties(); properties.load(in); driver = properties.getProperty(\"driver\"); url = properties.getProperty(\"url\"); username = properties.getProperty(\"username\"); password = properties.getProperty(\"password\"); // 1 加载驱动 只用加载一次 Class.forName(driver); } catch (Exception e) { e.printStackTrace(); } } // 获取连接 public static Connection getConnection() throws SQLException { return DriverManager.getConnection(url, username, password); } // 释放连接资源 public static void releaseResource(Connection conn, Statement st, ResultSet rs){ if (rs != null){ try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if (st != null){ try { st.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn != null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } } ","date":"2022-06-28","objectID":"/mysql_learning5/:2:2","tags":["SQL","mysql","navicat"],"title":"MySQL学习5","uri":"/mysql_learning5/"},{"categories":["MySQL学习"],"content":"增 package com.swagger.lesson02; import com.swagger.lesson02.utils.JdbcUtils; import java.sql.Connection; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; public class TestInsert { public static void main(String[] args) { Connection conn = null; Statement st = null; ResultSet rs = null; try { conn = JdbcUtils.getConnection(); // 获取数据库连接 st = conn.createStatement(); // 获取SQL的执行对象 String sql = \"INSERT into users(`id`, `NAME`, `PASSWORD`, `email`, `birthday`)\" + \"VALUES(5, 'swagger', '123456', 'fdafdsa@qq.com', '2020-01-01');\"; int i = st.executeUpdate(sql); if (i \u003e 0){ System.out.println(\"插入成功！\"); } } catch (SQLException e) { e.printStackTrace(); } finally { JdbcUtils.releaseResource(conn, st, rs); } } } ","date":"2022-06-28","objectID":"/mysql_learning5/:2:3","tags":["SQL","mysql","navicat"],"title":"MySQL学习5","uri":"/mysql_learning5/"},{"categories":["MySQL学习"],"content":"删 package com.swagger.lesson02; import com.swagger.lesson02.utils.JdbcUtils; import java.sql.Connection; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; public class TestDelete { public static void main(String[] args) { Connection conn = null; Statement st = null; ResultSet rs = null; try { conn = JdbcUtils.getConnection(); // 获取数据库连接 st = conn.createStatement(); // 获取SQL的执行对象 String sql = \"DELETE FROM users WHERE id = 4;\"; int i = st.executeUpdate(sql); if (i \u003e 0){ System.out.println(\"删除成功！\"); } } catch (SQLException e) { e.printStackTrace(); } finally { JdbcUtils.releaseResource(conn, st, rs); } } } ","date":"2022-06-28","objectID":"/mysql_learning5/:2:4","tags":["SQL","mysql","navicat"],"title":"MySQL学习5","uri":"/mysql_learning5/"},{"categories":["MySQL学习"],"content":"改 package com.swagger.lesson02; import com.swagger.lesson02.utils.JdbcUtils; import java.sql.Connection; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; public class TestUpdate { public static void main(String[] args) { Connection conn = null; Statement st = null; ResultSet rs = null; try { conn = JdbcUtils.getConnection(); // 获取数据库连接 st = conn.createStatement(); // 获取SQL的执行对象 String sql = \"UPDATE users SET `NAME` = 'swagger', `email` = '12345@qqq.com' WHERE id = 1;\"; int i = st.executeUpdate(sql); if (i \u003e 0){ System.out.println(\"更新成功！\"); } } catch (SQLException e) { e.printStackTrace(); } finally { JdbcUtils.releaseResource(conn, st, rs); } } } ","date":"2022-06-28","objectID":"/mysql_learning5/:2:5","tags":["SQL","mysql","navicat"],"title":"MySQL学习5","uri":"/mysql_learning5/"},{"categories":["MySQL学习"],"content":"查 package com.swagger.lesson02; import com.swagger.lesson02.utils.JdbcUtils; import java.sql.Connection; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; public class TestSelect { public static void main(String[] args) { Connection conn = null; Statement st = null; ResultSet rs = null; try { conn = JdbcUtils.getConnection(); st = conn.createStatement(); String sql = \"select * from `users` where id = 1;\"; rs = st.executeQuery(sql); while (rs.next()){ System.out.println(rs.getString(\"NAME\")); } } catch (SQLException e) { e.printStackTrace(); }finally { JdbcUtils.releaseResource(conn, st, rs); } } } ","date":"2022-06-28","objectID":"/mysql_learning5/:2:6","tags":["SQL","mysql","navicat"],"title":"MySQL学习5","uri":"/mysql_learning5/"},{"categories":["MySQL学习"],"content":"SQL 注入问题 SQL 存在 拼接情况，可能会受到攻击 package com.swagger.lesson02; import com.swagger.lesson02.utils.JdbcUtils; import java.sql.Connection; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; public class QuestionOfSQLDrilling { public static void main(String[] args) { // 正常使用 // login(\"lisi\", \"123456\"); // 非正常使用 SQL非法注入情况 login(\"'or '1=1\", \"'or'1=1\"); } public static void login(String username, String password){ Connection conn = null; Statement st = null; ResultSet rs = null; try { conn = JdbcUtils.getConnection(); st = conn.createStatement(); // SELECT * FROM users WHERE `NAME` = 'lisi' and `PASSWORD` = '123456'; // SELECT * FROM users WHERE `NAME` = '' or '1=1' and `PASSWORD` = ''or'1=1'; // 非法注入sql ，导致意思改变 String sql = \"SELECT * FROM users WHERE `NAME` = '\" + username + \"' and `PASSWORD` = '\" + password + \"';\"; rs = st.executeQuery(sql); while (rs.next()){ System.out.println(rs.getString(\"NAME\")); System.out.println(rs.getString(\"password\")); System.out.println(\"==============\"); } } catch (SQLException e) { e.printStackTrace(); }finally { JdbcUtils.releaseResource(conn, st, rs); } } } ","date":"2022-06-28","objectID":"/mysql_learning5/:3:0","tags":["SQL","mysql","navicat"],"title":"MySQL学习5","uri":"/mysql_learning5/"},{"categories":["MySQL学习"],"content":"PreparedStatement 对象 避免了SQL注入问题 效率更高 ","date":"2022-06-28","objectID":"/mysql_learning5/:4:0","tags":["SQL","mysql","navicat"],"title":"MySQL学习5","uri":"/mysql_learning5/"},{"categories":["MySQL学习"],"content":"增 package com.swagger.lesson03; import com.swagger.lesson02.utils.JdbcUtils; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.SQLException; import java.util.Date; public class TestInsert { public static void main(String[] args) { Connection connection = null; PreparedStatement pst = null; try { connection = JdbcUtils.getConnection(); // 区别 // 使用 ? 占位符替代参数 String sql = \"INSERT into users(`id`, `NAME`, `PASSWORD`, `email`, `birthday`)\" + \"VALUES(?, ?, ?, ?, ?);\"; // 预编译SQL pst = connection.prepareStatement(sql); // 手动为参数赋值 pst.setInt(1, 6); pst.setString(2 ,\"Sinyi\"); pst.setString(3, \"467879\"); pst.setString(4, \"21431421@qq.com\"); // 注意点：sql.Date 数据库 // util.Date Java new Date().getTime() 获得时间戳 pst.setDate(5, new java.sql.Date(new Date().getTime())); // 执行 int i = pst.executeUpdate(); if (i \u003e 0){ System.out.println(\"插入成功\"); } } catch (Exception e) { e.printStackTrace(); } finally { JdbcUtils.releaseResource(connection, pst, null); } } } ","date":"2022-06-28","objectID":"/mysql_learning5/:4:1","tags":["SQL","mysql","navicat"],"title":"MySQL学习5","uri":"/mysql_learning5/"},{"categories":["MySQL学习"],"content":"删 package com.swagger.lesson03; import com.swagger.lesson02.utils.JdbcUtils; import java.sql.Connection; import java.sql.PreparedStatement; import java.util.Date; public class TestDelete { public static void main(String[] args) { Connection connection = null; PreparedStatement pst = null; try { connection = JdbcUtils.getConnection(); // 区别 // 使用 ? 占位符替代参数 String sql = \"DELETE from users where id = ?\"; // 预编译SQL pst = connection.prepareStatement(sql); // 手动为参数赋值 pst.setInt(1, 3); // 执行 int i = pst.executeUpdate(); if (i \u003e 0){ System.out.println(\"删除成功\"); } } catch (Exception e) { e.printStackTrace(); } finally { JdbcUtils.releaseResource(connection, pst, null); } } } ","date":"2022-06-28","objectID":"/mysql_learning5/:4:2","tags":["SQL","mysql","navicat"],"title":"MySQL学习5","uri":"/mysql_learning5/"},{"categories":["MySQL学习"],"content":"改 package com.swagger.lesson03; import com.swagger.lesson02.utils.JdbcUtils; import java.sql.Connection; import java.sql.PreparedStatement; public class TestUpdate { public static void main(String[] args) { Connection connection = null; PreparedStatement pst = null; try { connection = JdbcUtils.getConnection(); // 区别 // 使用 ? 占位符替代参数 String sql = \"UPDATE users SET `NAME` = ? WHERE id = ?;\"; // 预编译SQL pst = connection.prepareStatement(sql); // 手动为参数赋值 pst.setString(1, \"swagger1\"); pst.setInt(2, 1); // 执行 int i = pst.executeUpdate(); if (i \u003e 0){ System.out.println(\"更新成功\"); } } catch (Exception e) { e.printStackTrace(); } finally { JdbcUtils.releaseResource(connection, pst, null); } } } ","date":"2022-06-28","objectID":"/mysql_learning5/:4:3","tags":["SQL","mysql","navicat"],"title":"MySQL学习5","uri":"/mysql_learning5/"},{"categories":["MySQL学习"],"content":"查 package com.swagger.lesson03; import com.swagger.lesson02.utils.JdbcUtils; import java.sql.*; public class QuestionOfSQLDrilling { public static void main(String[] args) { // 正常使用 login(\"lisi\", \"123456\"); // 非正常使用 SQL非法注入情况 // login(\"'or '1=1\", \"'or'1=1\"); } public static void login(String username, String password){ Connection conn = null; PreparedStatement st = null; ResultSet rs = null; try { conn = JdbcUtils.getConnection(); // SELECT * FROM users WHERE `NAME` = 'lisi' and `PASSWORD` = '123456'; // SELECT * FROM users WHERE `NAME` = '' or '1=1' and `PASSWORD` = ''or'1=1'; // 非法注入sql ，导致意思改变 // 防止SQL的本质是把传递进来的参数当作字符，假设其中存在转译字符，会被直接转译 String sql = \"SELECT * FROM `users` WHERE `name1` = ? and `psd` = ?;\"; st = conn.prepareStatement(sql); st.setString(1, username); st.setString(2, password); rs = st.executeQuery(sql); while (rs.next()){ System.out.println(rs.getString(\"name1\")); System.out.println(rs.getString(\"psd\")); System.out.println(\"==============\"); } } catch (SQLException e) { e.printStackTrace(); }finally { JdbcUtils.releaseResource(conn, st, rs); } } } ","date":"2022-06-28","objectID":"/mysql_learning5/:4:4","tags":["SQL","mysql","navicat"],"title":"MySQL学习5","uri":"/mysql_learning5/"},{"categories":["MySQL学习"],"content":"JDBC操作事务 要么都成功，要么都失败 ACID原则：原子性、一致性、隔离性、持久性 ","date":"2022-06-28","objectID":"/mysql_learning5/:5:0","tags":["SQL","mysql","navicat"],"title":"MySQL学习5","uri":"/mysql_learning5/"},{"categories":["MySQL学习"],"content":"代码实战 开启事务 connection.setAutoCommit(false); 一组事务执行完毕，提交事务 如果不成功就会回归（默认），或者在catch中显式调用回滚语句 package com.swagger.lesson04; import com.swagger.lesson02.utils.JdbcUtils; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; public class TestTransaction1 { public static void main(String[] args) { Connection connection = null; PreparedStatement statement = null; ResultSet resultSet = null; try { connection = JdbcUtils.getConnection(); // 关闭数据库的自动提交功能, 会自动开启事务 connection.setAutoCommit(false); String sql1 = \"update account set money = money - 100 where name = 'A'\"; statement = connection.prepareStatement(sql1); statement.executeUpdate(); int x = 1/0; // 会报错失败 String sql2 = \"update account set money = money + 100 where name = 'B'\"; statement = connection.prepareStatement(sql2); statement.executeUpdate(); // 业务完毕，提交事务 connection.commit(); System.out.println(\"提交成功！\"); } catch (SQLException e) { try { // 如果失败，则回滚事务 // 实际上不写，也会默认回滚，不用显式定义 connection.rollback(); } catch (SQLException ex) { ex.printStackTrace(); } e.printStackTrace(); } finally { JdbcUtils.releaseResource(connection, statement, resultSet); } } } ","date":"2022-06-28","objectID":"/mysql_learning5/:5:1","tags":["SQL","mysql","navicat"],"title":"MySQL学习5","uri":"/mysql_learning5/"},{"categories":["MySQL学习"],"content":"数据库连接池 传统数据库连接：数据库连接-执行完毕-释放，实际上连接和释放非常占用系统资源 池化技术：准备一些预先的资源，过来就先连接准备好的 最小连接数：根据常用连接数来设定 最大连接数：业务最高的承载上限 超过最大连接数则排队 等待超时则不再等待了 编写一个连接池，实现一个接口 DataSource ","date":"2022-06-28","objectID":"/mysql_learning5/:6:0","tags":["SQL","mysql","navicat"],"title":"MySQL学习5","uri":"/mysql_learning5/"},{"categories":["MySQL学习"],"content":"开源数据源实现 使用这些数据库连接池之后，就不用再写连接数据库的代码了 DBCP C3P0 Druid ","date":"2022-06-28","objectID":"/mysql_learning5/:6:1","tags":["SQL","mysql","navicat"],"title":"MySQL学习5","uri":"/mysql_learning5/"},{"categories":["MySQL学习"],"content":"DBCP需要用到的jar包 commons-dbcp-1.4 commons-pool-1.6 代码实战 dbcpconfig.properties 配置文件 driverClassName=com.mysql.cj.jdbc.Driver url=jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true\u0026characterEncoding=utf8\u0026useSSL=true\u0026serverTimezone=Asia/Shanghai username=root password=Wby785403310 #\u003c!-- ????? --\u003e initialSize=10 #?????? maxActive=50 #\u003c!-- ?????? --\u003e maxIdle=20 #\u003c!-- ?????? --\u003e minIdle=5 #\u003c!-- ???????????? 6000??/1000??60? --\u003e maxWait=60000 #JDBC?????????????????????????????=property;? #???\"user\" ? \"password\" ???????????????????????? connectionProperties=useUnicode=true;characterEncoding=UTF8 #??????????????????auto-commit???? defaultAutoCommit=true #driver default ????????????????read-only???? #???????????setReadOnly?????????????????????????Informix? defaultReadOnly= #driver default ??????????????????TransactionIsolation?? #??????????????javadoc??NONE,READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE defaultTransactionIsolation=READ_UNCOMMITTED JdbcUtils_DBCP.java 工具类 package com.swagger.lesson05.utils; import org.apache.commons.dbcp.BasicDataSourceFactory; import javax.sql.DataSource; import java.io.InputStream; import java.sql.*; import java.util.Properties; // 数据库连接 工具类 public class JdbcUtils_DBCP { private static DataSource dataSource = null; static { try { InputStream in = JdbcUtils_DBCP.class.getClassLoader().getResourceAsStream(\"dbcpconfig.properties\"); Properties properties = new Properties(); properties.load(in); // 创建数据源 工厂设置模式 --》 创建对象 // 有池化技术，性能会高很多 dataSource = BasicDataSourceFactory.createDataSource(properties); } catch (Exception e) { e.printStackTrace(); } } // 获取连接 public static Connection getConnection() throws SQLException { return dataSource.getConnection(); // 从数据源中获取连接 } // 释放连接资源 public static void releaseResource(Connection conn, Statement st, ResultSet rs){ if (rs != null){ try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if (st != null){ try { st.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn != null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } } TestDBCP.java 测试代码 package com.swagger.lesson05.utils; import org.apache.commons.dbcp.BasicDataSourceFactory; import javax.sql.DataSource; import java.io.InputStream; import java.sql.*; import java.util.Properties; // 数据库连接 工具类 public class JdbcUtils_DBCP { private static DataSource dataSource = null; static { try { InputStream in = JdbcUtils_DBCP.class.getClassLoader().getResourceAsStream(\"dbcpconfig.properties\"); Properties properties = new Properties(); properties.load(in); // 创建数据源 工厂设置模式 --》 创建对象 // 有池化技术，性能会高很多 dataSource = BasicDataSourceFactory.createDataSource(properties); } catch (Exception e) { e.printStackTrace(); } } // 获取连接 public static Connection getConnection() throws SQLException { return dataSource.getConnection(); // 从数据源中获取连接 } // 释放连接资源 public static void releaseResource(Connection conn, Statement st, ResultSet rs){ if (rs != null){ try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if (st != null){ try { st.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn != null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } } ","date":"2022-06-28","objectID":"/mysql_learning5/:6:2","tags":["SQL","mysql","navicat"],"title":"MySQL学习5","uri":"/mysql_learning5/"},{"categories":["MySQL学习"],"content":"C3P0需要用到的jar包 c3p0-0.9.5.5 mchange-commons-java-0.2.19 代码实战 c3p0-config.xml 配置文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cc3p0-config\u003e \u003c!-- c3p0的缺省（默认）配置 如果在代码中\"ComboPooledDataSource ds=new ComboPooledDataSource();\"这样写就表示使用的是c3p0的缺省（默认） --\u003e \u003cdefault-config\u003e \u003cproperty name=\"driverClass\"\u003ecom.mysql.cj.jdbc.Driver\u003c/property\u003e \u003cproperty name=\"jdbcUrl\"\u003ejdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true;characterEncoding=utf8;uesSSL=true;serverTimezone=UTC\u003c/property\u003e \u003cproperty name=\"user\"\u003eroot\u003c/property\u003e \u003cproperty name=\"password\"\u003eWby785403310\u003c/property\u003e \u003cproperty name=\"acquireIncrement\"\u003e5\u003c/property\u003e \u003cproperty name=\"initialPoolSize\"\u003e10\u003c/property\u003e \u003cproperty name=\"minPoolSize\"\u003e5\u003c/property\u003e \u003cproperty name=\"maxPoolSize\"\u003e20\u003c/property\u003e \u003c/default-config\u003e \u003cname-config name=\"MySQL\"\u003e \u003cproperty name=\"driverClass\"\u003ecom.mysql.cj.jdbc.Driver\u003c/property\u003e \u003cproperty name=\"jdbcUrl\"\u003ejdbc:mysql://localhost:3306/jdbcstudy?userUnicode=true;characterEncoding=utf8;useSSL=true;serverTimezone=UTC\u003c/property\u003e \u003cproperty name=\"user\"\u003eroot\u003c/property\u003e \u003cproperty name=\"password\"\u003eWby785403310\u003c/property\u003e \u003cproperty name=\"acquireIncrement\"\u003e5\u003c/property\u003e \u003cproperty name=\"initialPoolSize\"\u003e10\u003c/property\u003e \u003cproperty name=\"minPoolSize\"\u003e5\u003c/property\u003e \u003cproperty name=\"maxPoolSize\"\u003e20\u003c/property\u003e \u003c/name-config\u003e \u003c/c3p0-config\u003e JdbcUtils_C3P0.java 工具类 package com.swagger.lesson05.utils; import com.mchange.v2.c3p0.ComboPooledDataSource; import org.apache.commons.dbcp.BasicDataSourceFactory; import javax.sql.DataSource; import java.io.InputStream; import java.sql.Connection; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import java.util.Properties; public class JdbcUtils_C3P0 { private static DataSource dataSource = null; static { try { // 创建数据源 工厂设置模式 --》 创建对象 // 有池化技术，性能会高很多 dataSource = new ComboPooledDataSource(\"MySQL\"); // 配置文件写法 } catch (Exception e) { e.printStackTrace(); } } // 获取连接 public static Connection getConnection() throws SQLException { return dataSource.getConnection(); // 从数据源中获取连接 } // 释放连接资源 public static void releaseResource(Connection conn, Statement st, ResultSet rs){ if (rs != null){ try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if (st != null){ try { st.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn != null){ try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } } TestC3P0.java 测试代码 package com.swagger.lesson05; import com.swagger.lesson05.utils.JdbcUtils_C3P0; import com.swagger.lesson05.utils.JdbcUtils_DBCP; import java.sql.Connection; import java.sql.PreparedStatement; import java.util.Date; public class TestC3P0 { public static void main(String[] args) { Connection connection = null; PreparedStatement pst = null; try { // 使用C3P0 数据源 connection = JdbcUtils_C3P0.getConnection(); // 区别 // 使用 ? 占位符替代参数 String sql = \"INSERT into users(`id`, `name1`, `psd`, `email`, `birthday`)\" + \"VALUES(?, ?, ?, ?, ?);\"; // 预编译SQL pst = connection.prepareStatement(sql); // 手动为参数赋值 pst.setInt(1, 9); pst.setString(2 ,\"wby9\"); pst.setString(3, \"467879\"); pst.setString(4, \"21431421@qq.com\"); // 注意点：sql.Date 数据库 // util.Date Java new Date().getTime() 获得时间戳 pst.setDate(5, new java.sql.Date(new Date().getTime())); // 执行 int i = pst.executeUpdate(); if (i \u003e 0){ System.out.println(\"插入成功\"); } } catch (Exception e) { e.printStackTrace(); } finally { JdbcUtils_C3P0.releaseResource(connection, pst, null); } } } ","date":"2022-06-28","objectID":"/mysql_learning5/:6:3","tags":["SQL","mysql","navicat"],"title":"MySQL学习5","uri":"/mysql_learning5/"},{"categories":["MySQL学习"],"content":"DQL 查询数据（最重点） 以上所有的顺序不能颠倒 数据库查询语言（Data Query Language：数据查询语言） 所有的查询语言都用：select 简单查询，复杂查询都可以做 数据库中最核心的语言，使用频率最高 ","date":"2022-06-15","objectID":"/mysql_learning4/:1:0","tags":["SQL","mysql","navicat"],"title":"MySQL学习4","uri":"/mysql_learning4/"},{"categories":["MySQL学习"],"content":"指定查询字段 -- 查询全部的学生 SELECT 字段 FROM 表 SELECT*FROM`student`SELECT*FROM`result`-- 查询指定字段 SELECT`StudentNo`,`StudentName`FROM`student`-- 给结果字段或者表取一个名字 AS SELECT`StudentNo`AS学号,`StudentName`AS学生姓名FROM`student`ass-- 函数 concat(a, b) SELECTCONCAT('姓名：',`StudentName`)AS新名字FROM`student` 列名字意义不明确，可以用as 起别名 ","date":"2022-06-15","objectID":"/mysql_learning4/:1:1","tags":["SQL","mysql","navicat"],"title":"MySQL学习4","uri":"/mysql_learning4/"},{"categories":["MySQL学习"],"content":"去重 distinct 去除select 查询结果中重复的数据，只显示一条 -- 查询一下哪些同学参加了考试，成绩 SELECT*FROMresult-- 查询全部成绩 -- 查询哪些同学参加了考试 SELECT`StudentNo`FROMresult-- 查询哪些同学参加了考试 SELECTDISTINCT`StudentNo`FROMresult-- 去重 ","date":"2022-06-15","objectID":"/mysql_learning4/:1:2","tags":["SQL","mysql","navicat"],"title":"MySQL学习4","uri":"/mysql_learning4/"},{"categories":["MySQL学习"],"content":"数据库的列（表达式） 数据库中的表达式： 文本、列、null、函数、计算表达式、系统变量 SELECTVERSION()-- 查看系统版本-函数 SELECT100*3-1as计算结果-- 计算-表达式 select@@auto_increment_increment-- 查询自增步长-变量 -- 查询学员考试成绩加1 SELECT`StudentNo`,`StudentResult`FROMresultSELECT`StudentNo`,`StudentResult`+1AS提分后FROMresult ","date":"2022-06-15","objectID":"/mysql_learning4/:1:3","tags":["SQL","mysql","navicat"],"title":"MySQL学习4","uri":"/mysql_learning4/"},{"categories":["MySQL学习"],"content":"where 条件子句 检索数据中符合条件的值 搜索的条件有一个或者多个表达式组成！结果 布尔值 -- ========= where ========= SELECT`StudentNo`,`StudentResult`FROM`result`-- 查询考试成绩 95 - 100 之间 SELECT`StudentNo`,`StudentResult`FROM`result`WHERE`studentresult`\u003e=95AND`studentresult`\u003c=100-- 模糊查询（区间） BETWEEN SELECT`StudentNo`,`StudentResult`FROM`result`WHERE`studentresult`BETWEEN95AND100-- 除了9999号学生之外的同学的成绩 SELECT`StudentNo`,`StudentResult`FROM`result`where`StudentNo`!=9999 ","date":"2022-06-15","objectID":"/mysql_learning4/:1:4","tags":["SQL","mysql","navicat"],"title":"MySQL学习4","uri":"/mysql_learning4/"},{"categories":["MySQL学习"],"content":"模糊查询：比较运算符 like 通配符只能在like 里用 通配符 % 代表任意个字符 通配符 _ 代表一个字符 -- ====== 模糊查询 LIKE ======= SELECT`StudentNo`,`studentname`FROM`student`WHERE`studentname`LIKE'刘%';-- 刘 开头 SELECT`StudentNo`,`studentname`FROM`student`WHERE`studentname`LIKE'刘_';-- 刘 后面只有一个字 SELECT`StudentNo`,`studentname`FROM`student`WHERE`studentname`LIKE'刘__';-- 刘 后面两个字 SELECT`StudentNo`,`studentname`FROM`student`WHERE`studentname`LIKE'%佳%';-- 名字中间带有佳的，考虑4字名字 in -- ======== in ======== -- 查询1001，1002，1003 号学员的信息 SELECT`StudentNo`,`studentname`FROM`student`WHERE`StudentNo`IN(1001,1002,1003);-- 查询在北京的学生 SELECT`StudentNo`,`studentname`FROM`student`where`address`in('安徽','河南洛阳'); null / not null -- ======== NULL / NOT NULL ========= -- 查询地址为空的学生 SELECT`StudentNo`,`studentname`FROM`student`where`address`=''OR`address`ISNULL-- 查询有出生日期的同学 不为空 SELECT`StudentNo`,`studentname`FROM`student`WHERE`borndate`isNOTNULL; 注意字符串为空和null是不同的 ","date":"2022-06-15","objectID":"/mysql_learning4/:1:5","tags":["SQL","mysql","navicat"],"title":"MySQL学习4","uri":"/mysql_learning4/"},{"categories":["MySQL学习"],"content":"联表查询 leftJoin rightJoin innerJoin 分析查询字段来自哪些表 确定使用那种查询 代码实战 -- =========== 联表查询 join ========== -- 查询学号参加了考试的同学（学号，姓名，科目编号，分数） SELECT*FROMstudentSELECT*FROMresult/* 1 分析查询字段来自哪些表 2 确定使用那种查询 3 确定交叉点（这两个表中，那个数据是相同的） 判断的条件 ： 学生表中的 studentNo = 成绩表 studentNo */-- inner join SELECTs.studentNo,studentName,SubjectNo,StudentResultFROMstudentASsINNERjoinresultASrWHEREs.studentno=r.studentno-- right join SELECTs.studentNo,studentName,SubjectNo,StudentResultFROMstudentsRIGHTJOINresultrONs.studentno=r.studentno-- left join SELECTs.studentNo,studentName,SubjectNo,StudentResultFROMstudentsLEFTJOINresultrONs.studentno=r.studentno-- 查询了参加考试的同学信息：学号，姓名，科目名，分数(三表查询) SELECTs.studentno,studentname,subjectname,studentresultFROMstudentassRIGHTJOINresultasrONr.studentno=s.studentnoINNERJOIN`subject`assubONr.subjectno=sub.subjectno ","date":"2022-06-15","objectID":"/mysql_learning4/:1:6","tags":["SQL","mysql","navicat"],"title":"MySQL学习4","uri":"/mysql_learning4/"},{"categories":["MySQL学习"],"content":"自连接 自己的表和自己的表连接，核心：一张表拆为两张一样的表即可 -- 自连接 查询父子信息(把一张表看成两张一摸一样的表) SELECTa.`categoryname`as'父栏目',b.`categoryname`as'子栏目'FROM`category`asa,`category`asbWHEREa.categoryid=b.pid ","date":"2022-06-15","objectID":"/mysql_learning4/:1:7","tags":["SQL","mysql","navicat"],"title":"MySQL学习4","uri":"/mysql_learning4/"},{"categories":["MySQL学习"],"content":"分页和排序 排序：升序 ASC 降序 DESC -- 排序：升序 ASC 降序 DESC SELECTs.`studentno`,`studentname`,`subjectname`,studentresultFROMstudentsINNERJOIN`result`rons.studentno=r.studentnoINNERJOIN`subject`subonr.subjectno=sub.subjectnoWHEREsubjectname='数据库结构-1'orderbystudentresultDESC 分页 缓解数据库压力 给人的体验更好，一次只显示一页 也有不分页的（拉不到底）—-瀑布流 – 分页：每页只显示五条数据 – 语法：limit 当前页，页面的大小 – LIMIT 0,5 第一页 – LIMIT 5,5 第一页 – LIMIT 10,5 第一页 – （n-1）*pageSize，pageSize -- 分页：每页只显示五条数据 -- 语法：limit 当前页，页面的大小 -- LIMIT 0,5 第一页 -- LIMIT 5,5 第一页 -- LIMIT 10,5 第一页 -- （n-1）*pageSize，pageSize SELECTs.`studentno`,`studentname`,`subjectname`,studentresultFROMstudentsINNERJOIN`result`rons.studentno=r.studentnoINNERJOIN`subject`subonr.subjectno=sub.subjectnoWHEREsubjectname='数据库结构-1'orderbystudentresultDESCLIMIT0,5-- ========= 子查询和嵌套插叙 ========== -- 查询 JAVA第一学年 课程成绩排名前十的学生， 并且分数要大于80的学生信息（学号，姓名，课程名称，分数） SELECTs.studentno,studentname,subjectname,studentresultFROMstudentsINNERJOINresultrONs.studentno=r.studentnoINNERJOIN`subject`subonsub.subjectno=r.subjectnoWHEREsubjectname='JAVA第一学年'ANDstudentresult\u003e=80ORDERBYstudentresultDESCLIMIT0,10 ","date":"2022-06-15","objectID":"/mysql_learning4/:1:8","tags":["SQL","mysql","navicat"],"title":"MySQL学习4","uri":"/mysql_learning4/"},{"categories":["MySQL学习"],"content":"子查询 where （这个值是计算出来的） 本质：在where 语句中嵌套一个子查询语句 where (select * from s) -- 查询 数据库结构-1 课程所有的考试结果（学号，科目编号，成绩），降序排列 -- 方式一：使用连接查询 SELECTstudentno,r.subjectno,studentresultFROMresultrINNERJOIN`subject`subONr.subjectno=sub.subjectnoWHEREsubjectname='数据库结构-1'ORDERBYstudentresultDESC-- 方式二：使用子查询(先执行里面，后执行外面) SELECTstudentno,subjectno,studentresultFROMresultWHEREsubjectno=(-- 查询所有 数据库结构-1 的学生的学号 SELECTsubjectnoFROM`subject`WHEREsubjectname='数据库结构-1') ","date":"2022-06-15","objectID":"/mysql_learning4/:1:9","tags":["SQL","mysql","navicat"],"title":"MySQL学习4","uri":"/mysql_learning4/"},{"categories":["MySQL学习"],"content":"MySQL函数 常用函数 ","date":"2022-06-15","objectID":"/mysql_learning4/:1:10","tags":["SQL","mysql","navicat"],"title":"MySQL学习4","uri":"/mysql_learning4/"},{"categories":["MySQL学习"],"content":"聚合函数 -- ========= 聚合函数 ============ -- 都能够统计表中的数据，查询有多少条记录 SELECTCOUNT(studentname)FROMstudent;-- count (指定列)，会忽略所有的null值 SELECTCOUNT(*)FROMstudent;-- count (*)，不会忽略所有的null值，本质计算行数， SELECTCOUNT(1)FROMstudent;-- count (1)，不会忽略所有的null值 -- 提取总数，平均数，最大值，最小值 SELECTSUM(studentresult)as总和FROMresultSELECTAVG(studentresult)as平均分FROMresultSELECTMAX(studentresult)as最高分FROMresultSELECTMIN(studentresult)as最低分FROMresult-- 查询不同课程的平均分，最高分，最低分，平均分大于80的 -- 核心：根据不同的课程进行分组 SELECTsubjectName,AVG(StudentResult)as平均分,MAX(StudentResult)as最高分,MIN(StudentResult)as最低分FROMresultrINNERJOIN`subject`subonr.subjectNo=sub.subjectNoGROUPBYr.subjectno-- 通过 学科编号来分组 HAVING平均分\u003e=80 ","date":"2022-06-15","objectID":"/mysql_learning4/:1:11","tags":["SQL","mysql","navicat"],"title":"MySQL学习4","uri":"/mysql_learning4/"},{"categories":["MySQL学习"],"content":"数据库级别的 MD5码加密 MD5 主要强调算法的复杂度和不可逆性 -- ========= 聚合函数 ============ -- 都能够统计表中的数据，查询有多少条记录 SELECTCOUNT(studentname)FROMstudent;-- count (指定列)，会忽略所有的null值 SELECTCOUNT(*)FROMstudent;-- count (*)，不会忽略所有的null值，本质计算行数， SELECTCOUNT(1)FROMstudent;-- count (1)，不会忽略所有的null值 -- 提取总数，平均数，最大值，最小值 SELECTSUM(studentresult)as总和FROMresultSELECTAVG(studentresult)as平均分FROMresultSELECTMAX(studentresult)as最高分FROMresultSELECTMIN(studentresult)as最低分FROMresult-- 查询不同课程的平均分，最高分，最低分，平均分大于80的 -- 核心：根据不同的课程进行分组 SELECTsubjectName,AVG(StudentResult)as平均分,MAX(StudentResult)as最高分,MIN(StudentResult)as最低分FROMresultrINNERJOIN`subject`subonr.subjectNo=sub.subjectNoGROUPBYr.subjectno-- 通过 学科编号来分组 HAVING平均分\u003e=80-- ========== 测试MD5码加密效果 =========== CREATETABLEtest_MD5(`id`int(4)notNULL,`name`VARCHAR(20)notnull,`pwd`VARCHAR(50)notnull,PRIMARYKEY(`id`))ENGINE=INNODBDEFAULTCHARSET=utf8-- 明文密码 INSERTintotest_MD5VALUES(1,'zhangsan','123456'),(2,'lisi','123456'),(3,'wangwu','123456')-- 加密 UPDATEtest_MD5setpwd=MD5(pwd)WHEREid=1-- 插入的时候加密 INSERTintotest_MD5VALUES(4,'zhangsan',MD5('123456'))INSERTintotest_MD5VALUES(5,'swagger',MD5('123456'))-- 如何校验：将用户传递进来的密码，进行MD5加密，然后比对加密后值，因为是不可逆，所以没有解密 SELECT*FROMtest_MD5WHERE`name`='swagger'ANDpwd=MD5('123456') ","date":"2022-06-15","objectID":"/mysql_learning4/:2:0","tags":["SQL","mysql","navicat"],"title":"MySQL学习4","uri":"/mysql_learning4/"},{"categories":["MySQL学习"],"content":"事务的处理过程 关闭事务自动提交 开启一个事务 执行成功则提交，然后开启事务自动提交；执行失败则回滚到出事状态 -- == 手动处理事务 == SETautocommit=0-- 关闭 -- 事务开启 STARTTRANSACTION-- 标记一个事务的开始，从这个之后的SQL都在同一个事物内 INSERTxxINSERTxx-- 提交：持久化 （成功） COMMIT-- 回滚：回到原来的状态 (失败) ROLLBACK-- 事务的结束 SETautocommit=1-- 开启 -- 设置一个事务的保存点（了解） SAVEPOINT保存点名ROLLBACKtoSAVEPOINT保存点名-- 回滚到保存点 RELEASESAVEPOINT保存点名-- 撤销保存点 ","date":"2022-06-15","objectID":"/mysql_learning4/:3:0","tags":["SQL","mysql","navicat"],"title":"MySQL学习4","uri":"/mysql_learning4/"},{"categories":["MySQL学习"],"content":"模拟场景 测试事务实现转账 -- ==== 测试事务实现转账 ====== -- 转账 CREATEDATABASEshopCHARACTERsetutf8COLLATEutf8_general_ciuseshopCREATETABLE`account`(`id`INT(3)NOTNULLauto_increment,`name`VARCHAR(30)notnull,`money`DECIMAL(9,2)notNULL,PRIMARYKEY(`id`))ENGINE=INNODBDEFAULTCHARSET=utf8INSERTintoaccount(`name`,`money`)VALUES('A',2000.00),('B',10000.00)-- ==== 模拟转账（事务操作） ==== setautocommit=0;-- 关闭自动提交 STARTTRANSACTION-- 开启一个事务 (一组事务) updateaccountSETmoney=money-500WHERE`name`='A';-- A减500 updateaccountSETmoney=money+500WHERE`name`='B';-- B加500 COMMIT;-- 提交事务，事务一旦提交，就会持久化, 无法再回滚 ROLLBACK;-- 回滚 setautocommit=1;-- 恢复自动提交（默认值） ","date":"2022-06-15","objectID":"/mysql_learning4/:3:1","tags":["SQL","mysql","navicat"],"title":"MySQL学习4","uri":"/mysql_learning4/"},{"categories":["MySQL学习"],"content":"索引 帮助MySQL 高效获取数据的数据结构，相当于一本书的目录 主键索引（primary key）：唯一的标识，逐渐不可重复，只能有一个列作为主键 唯一索引（unique key）：避免重复的列出现，唯一索引可以重复，多个列都可以标识为唯一索引 常规索引（normal key）：默认的，可以用key关键字来设置 全文索引（fullText）：在特定的数据库下才有，MyISAM，用于快速定位数据 ","date":"2022-06-15","objectID":"/mysql_learning4/:4:0","tags":["SQL","mysql","navicat"],"title":"MySQL学习4","uri":"/mysql_learning4/"},{"categories":["MySQL学习"],"content":"基础语法 -- ======= 索引的使用 ======== -- 1. 在创建表的时候给字段增加索引 -- 2. 创建完毕之后，增加索引 -- 显示所有的索引信息 SHOWINDEXFROMstudent-- 增加一个全文索引 ALTERTABLEschool.studentADDFULLTEXTINDEX`studentname`(`studentname`);-- EXPLAIN 分析SQL执行情况 EXPLAINSELECT*FROMstudent;-- 非全文索引 EXPLAINSELECT*FROMstudentWHEREMATCH(studentname)against('刘')-- 发现通过一次索引就找到了数据， ","date":"2022-06-15","objectID":"/mysql_learning4/:4:1","tags":["SQL","mysql","navicat"],"title":"MySQL学习4","uri":"/mysql_learning4/"},{"categories":["MySQL学习"],"content":"测试索引 小数据量用处不大，大数据量的时候十分明显 -- ====== 测试索引 ====== -- 测试一百万条索引的时间 CREATETABLE`app_user`(`id`BIGINT(20)UNSIGNEDnotnullauto_increment,`name`VARCHAR(50)DEFAULT''comment'用户昵称',`email`VARCHAR(50)notNULLCOMMENT'用户邮箱',`phone`VARCHAR(20)DEFAULT''COMMENT'手机号',`gender`TINYINT(4)UNSIGNEDDEFAULT'0'COMMENT'性别（0:男， 1:女）',`password`VARCHAR(100)notNULLCOMMENT'密码',`age`TINYINT(4)DEFAULT'0'COMMENT'年龄',`create_time`datetimeDEFAULTCURRENT_TIMESTAMP,`update_time`TIMESTAMPNULLDEFAULTCURRENT_TIMESTAMPonUPDATECURRENT_TIMESTAMP,PRIMARYKEY(`id`))ENGINE=INNODBDEFAULTcharset=utf8mb4COMMENT='app用户表'-- 写一个函数 delimiter$$-- 写函数之前必须要写，标志 CREATEFUNCTIONmock_data()RETURNSintDETERMINISTICBEGINDECLAREnumintDEFAULT1000000;DECLAREiintDEFAULT0;WHILEi\u003cnumDO-- 插入语句 INSERTintoapp_user(`name`,`email`,`phone`,`gender`,`password`,`age`)VALUES(CONCAT('用户',i),'123141142@qq.com',CONCAT('18',FLOOR(RAND()*((9999999999-100000000)+100000000))),FLOOR(RAND()*2),UUID(),FLOOR(RAND()*100));seti=i+1;ENDWHILE;RETURNi;END;SELECTmock_data();SELECT*FROMapp_userWHERE`name`='用户90130';-- 发现使用了0.3秒多 EXPLAINSELECT*FROMapp_userWHERE`name`='用户90130';-- 常规命名方式 id_表名_字段名 -- 方式三 使用create index 。。。 on 。。。添加索引 CREATEINDEXid_app_user_nameonapp_user(`name`);SELECT*FROMapp_userWHERE`name`='用户90130';-- 创建索引之后，查询非常快，直接定位了数据的位置 EXPLAINSELECT*FROMapp_userWHERE`name`='用户90130';-- 查询的行数为1 ","date":"2022-06-15","objectID":"/mysql_learning4/:4:2","tags":["SQL","mysql","navicat"],"title":"MySQL学习4","uri":"/mysql_learning4/"},{"categories":["MySQL学习"],"content":"索引原则 索引不是越多越好 不要对进行变动数据加索引 小数据量的表不需要索引 索引一般加在用来查询的字段上 ","date":"2022-06-15","objectID":"/mysql_learning4/:4:3","tags":["SQL","mysql","navicat"],"title":"MySQL学习4","uri":"/mysql_learning4/"},{"categories":["MySQL学习"],"content":"索引的数据结构 hash类型的索引 B-树：InnoDB默认数据结构 ","date":"2022-06-15","objectID":"/mysql_learning4/:4:4","tags":["SQL","mysql","navicat"],"title":"MySQL学习4","uri":"/mysql_learning4/"},{"categories":["MySQL学习"],"content":"规范的数据库设计 ","date":"2022-06-15","objectID":"/mysql_learning4/:5:0","tags":["SQL","mysql","navicat"],"title":"MySQL学习4","uri":"/mysql_learning4/"},{"categories":["MySQL学习"],"content":"糟糕的数据库设计 数据冗余，浪费空间 数据库插入和删除都会麻烦，异常（屏蔽使用物理外键） 程序性能差 ","date":"2022-06-15","objectID":"/mysql_learning4/:5:1","tags":["SQL","mysql","navicat"],"title":"MySQL学习4","uri":"/mysql_learning4/"},{"categories":["MySQL学习"],"content":"良好的数据库设计 节省内存空间 保证数据库的完整性 方便我们开发系统 ","date":"2022-06-15","objectID":"/mysql_learning4/:5:2","tags":["SQL","mysql","navicat"],"title":"MySQL学习4","uri":"/mysql_learning4/"},{"categories":["MySQL学习"],"content":"软件开发过程中，关于数据库的设计 分析需求：分析业务和需要处理的数据库需求 概要设计：设计关系图 E-R 图 ","date":"2022-06-15","objectID":"/mysql_learning4/:5:3","tags":["SQL","mysql","navicat"],"title":"MySQL学习4","uri":"/mysql_learning4/"},{"categories":["MySQL学习"],"content":"设计数据库的步骤（个人博客为例） 收集信息，分析需求 用户表 分类表 文章表 评论表 友情链接表 自定义表 说说表 概要设计，E-R图 标识实体，将需求落地到每个字段 标识实体之间的关系 ","date":"2022-06-15","objectID":"/mysql_learning4/:5:4","tags":["SQL","mysql","navicat"],"title":"MySQL学习4","uri":"/mysql_learning4/"},{"categories":["MySQL学习"],"content":"JDBC ","date":"2022-06-15","objectID":"/mysql_learning4/:6:0","tags":["SQL","mysql","navicat"],"title":"MySQL学习4","uri":"/mysql_learning4/"},{"categories":["MySQL学习"],"content":"数据库驱动 程序会通过数据库驱动和数据库进行操作 ","date":"2022-06-15","objectID":"/mysql_learning4/:6:1","tags":["SQL","mysql","navicat"],"title":"MySQL学习4","uri":"/mysql_learning4/"},{"categories":["MySQL学习"],"content":"JDBC SUN公司简化开发人员对于数据库的统一操作，提供了一个Java操作规范，俗称JDBC，这些规范由具体的厂商去做 对于开发人员，只需要掌握JDBC的接口操作即可 java.sql javax.sql mysql-connector-java.jar 还需要导入一个数据库驱动包 ","date":"2022-06-15","objectID":"/mysql_learning4/:6:2","tags":["SQL","mysql","navicat"],"title":"MySQL学习4","uri":"/mysql_learning4/"},{"categories":["MySQL学习"],"content":"第一个JDBC 程序 创建测试数据库 CREATEDATABASE`jdbcStudy`CHARACTERSETutf8COLLATEutf8_general_ci;USE`jdbcStudy`;CREATETABLE`users`(`id`INTPRIMARYKEY,`NAME`VARCHAR(40),`PASSWORD`VARCHAR(40),`email`VARCHAR(60),birthdayDATE);INSERTINTO`users`(`id`,`NAME`,`PASSWORD`,`email`,`birthday`)VALUES('1','zhangsan','123456','zs@sina.com','1980-12-04'),('2','lisi','123456','lisi@sina.com','1981-12-04'),('3','wangwu','123456','wangwu@sina.com','1979-12-04')； 导入数据库驱动 编写测试代码 代码实战 加载驱动 用户信息和URL 连接成功， 数据库对象，代表数据库拿到数据库对象 执行SQL对象 执行SQL对象，去执行SQL，可能存在结果，查看返回结果 释放连接 package com.swagger.lesson01; import java.sql.*; // 第一个JDBC程序 public class JdbcFirstDemo { public static void main(String[] args) throws ClassNotFoundException, SQLException { // 1 加载驱动 Class.forName(\"com.mysql.jdbc.Driver\"); // 固定写法， // 2 用户信息和URL String url = \"jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true\u0026characterEncoding=utf8\u0026useSSL=true\"; String username = \"root\"; String password = \"Wby785403310\"; // 3 连接成功， 数据库对象，代表数据库拿到数据库对象 Connection connection = DriverManager.getConnection(url, username, password); // 4 执行SQL对象 Statement statement = connection.createStatement(); // 5 执行SQL对象，去执行SQL，可能存在结果，查看返回结果 String sql = \"SELECT * FROM users;\"; ResultSet resultSet = statement.executeQuery(sql); // 执行之后返回的结果集,结果集中封装了全部的查询结果 while (resultSet.next()){ System.out.println(\"id = \" + resultSet.getObject(\"id\")); System.out.println(\"name = \" + resultSet.getObject(\"NAME\")); System.out.println(\"pwd = \" + resultSet.getObject(\"PASSWORD\")); System.out.println(\"email = \" + resultSet.getObject(\"email\")); System.out.println(\"birth = \" + resultSet.getObject(\"birthday\")); System.out.println(\"======================\"); } // 6 释放连接 resultSet.close(); statement.close(); connection.close(); } } ","date":"2022-06-15","objectID":"/mysql_learning4/:6:3","tags":["SQL","mysql","navicat"],"title":"MySQL学习4","uri":"/mysql_learning4/"},{"categories":["Leetcode全速通"],"content":"DFS / BFS ","date":"2022-06-12","objectID":"/leetcode_recite3/:1:0","tags":["Java","Leetcode"],"title":"Leetcode全速通3","uri":"/leetcode_recite3/"},{"categories":["Leetcode全速通"],"content":"BFS 模板 ","date":"2022-06-12","objectID":"/leetcode_recite3/:1:1","tags":["Java","Leetcode"],"title":"Leetcode全速通3","uri":"/leetcode_recite3/"},{"categories":["Leetcode全速通"],"content":"DFS / BFS ","date":"2022-06-11","objectID":"/leetcode_recite2/:1:0","tags":["Java","Leetcode"],"title":"Leetcode全速通2","uri":"/leetcode_recite2/"},{"categories":["Leetcode全速通"],"content":"BFS 模板 ","date":"2022-06-11","objectID":"/leetcode_recite2/:1:1","tags":["Java","Leetcode"],"title":"Leetcode全速通2","uri":"/leetcode_recite2/"},{"categories":["Leetcode全速通"],"content":"DFS 模版 backtracking 和 DFS 有些许相似 backtraking 是更加广义上的一个算法 DFS 是backtracking在图数结构中的具体应用形势 ","date":"2022-06-11","objectID":"/leetcode_recite2/:1:2","tags":["Java","Leetcode"],"title":"Leetcode全速通2","uri":"/leetcode_recite2/"},{"categories":["Leetcode全速通"],"content":"DFS BFS 特点 BFS：对于解决最短或最少问题特别有效，而且寻找深度小，但缺点是内存耗费量大（需要开大量的数组单元用来存储状态，取决于树本身的形状，扁平还是长条） DFS：对干解決谝历和求所有问题有效．对干问题搜索深度小的时候外理谏度讯谏 DFS 优缺点 扁平型tree内存开销较小 能处理子节点较多或树层次过深的情况 （相比BFS) 一般用于解决连通性问题（是否有解） 只能寻找有解，但无法最快寻找到最优解，寻找最优解同样要遍历所有路径 数据运用和复杂度 ","date":"2022-06-11","objectID":"/leetcode_recite2/:1:3","tags":["Java","Leetcode"],"title":"Leetcode全速通2","uri":"/leetcode_recite2/"},{"categories":["Leetcode全速通"],"content":"102 Binary Tree Level Order Traversal BFS，层序遍历 注意每层的遍历开始时都要重新new一个level数组 遍历本层的内容时，需要提前将队列大小存储，并以此大小循环，因为后面队列大小的实时变化的 代码实战 package com.swagger.leetcode.bfs_dfs; import java.util.ArrayList; import java.util.LinkedList; import java.util.List; import java.util.Queue; public class leetcode102 { public static List\u003cList\u003cInteger\u003e\u003e levelOrder(TreeNode root) { List\u003cList\u003cInteger\u003e\u003e res = new ArrayList\u003c\u003e(); Queue\u003cTreeNode\u003e q = new LinkedList\u003c\u003e(); // 根节点入队 if (root != null) { q.offer(root); } // 如果队列没有空则进入循环，最后队列空了，说明已经没有子节点了 while (!q.isEmpty()){ // 获取当前队列大小，也就是本层元素的个数 int size = q.size(); // 每次都new一个level， 用以存储本层的所有元素 List\u003cInteger\u003e level = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c size; i++) { // 出队，且向本层level中添加元素 TreeNode cur = q.poll(); level.add(cur.val); // 左右孩子入队，但其实本层不会遍历到，因为size为队列初始大小 if (cur.left != null){ q.offer(cur.left); } if (cur.right != null){ q.offer(cur.right); } } res.add(level); } return res; } } ","date":"2022-06-11","objectID":"/leetcode_recite2/:1:4","tags":["Java","Leetcode"],"title":"Leetcode全速通2","uri":"/leetcode_recite2/"},{"categories":["Leetcode全速通"],"content":"200 Number of Islands DFS 遍历每个点的时候置0 DFS的返回条件是是否达到了边界或者碰到的点为0 如果没有返回，则向四周进行DFS 代码实战 package com.swagger.leetcode.bfs_dfs; public class leetcode200 { public static int numIslands(char[][] grid) { if (grid.length == 0) { return 0; } int M = grid.length; int N = grid[0].length; int res = 0; for (int i = 0; i \u003c M; i++) { for (int j = 0; j \u003c N; j++) { if (grid[i][j] == '1') { res++; dfs(grid, i, j); } } } return res; } public static void dfs(char[][] grid, int row, int col) { if (row \u003c 0 || row \u003e= grid.length || col \u003c 0 || col \u003e= grid[0].length || grid[row][col] == '0') { return; // 如果超出了这个范围 或者已经碰到0了 就 退出 } grid[row][col] = '0'; // 遍历过的点，置为0 // 向四周扩散 dfs(grid, row - 1, col); dfs(grid, row + 1, col); dfs(grid, row, col - 1); dfs(grid, row, col + 1); } } ","date":"2022-06-11","objectID":"/leetcode_recite2/:1:5","tags":["Java","Leetcode"],"title":"Leetcode全速通2","uri":"/leetcode_recite2/"},{"categories":["Leetcode全速通"],"content":"490 The Maze 题目 注意要记录当前的点是否被遍历过 停止条件为是否被遍历过，或者是否为最终点 移动时注意检测边缘和中间的阻挡墙壁 代码实战 工具类leetcode490 中应该还有一个 dirs 的数组，代表移动方向，但是用hugo 打包好push到github时发现build失败，不知道为啥提示错误 dirs数组补充 github build 错误信息提示 package com.swagger.leetcode.bfs_dfs; public class leetcode490 { public boolean hasPath(int[][] maze, int[] start, int[] destination) { int M = maze.length; int N = maze[0].length; // 记录当前位置是否被访问过 boolean[][] visited = new boolean[M][N]; return dfs(maze, visited, start, destination); } private boolean dfs(int[][] maze, boolean[][] visited, int[] cur, int[] destination) { int M = maze.length; int N = maze[0].length; // 两种停止条件 if (visited[cur[0]][cur[1]]) { // 如果已经visited了 return false; } if (cur[0] == destination[0] \u0026\u0026 cur[1] == destination[1]) {// 如果已经到达目标点了 return true; } // 此点标记为visited visited[cur[0]][cur[1]] = true; for (int[] dir : dirs) { int x = cur[0], y = cur[1]; // 移动 while (x + dir[0] \u003e= 0 \u0026\u0026 y + dir[1] \u003e= 0 \u0026\u0026 x + dir[0] \u003c M \u0026\u0026 y + dir[1] \u003c N \u0026\u0026 maze[x + dir[0]][y + dir[1]] == 0) { x = x + dir[0]; y = y + dir[0]; } // 移动之后开始继续向下递归 if (dfs(maze, visited, new int[]{x, y}, destination)) { return true; } } return false; } } ","date":"2022-06-11","objectID":"/leetcode_recite2/:1:6","tags":["Java","Leetcode"],"title":"Leetcode全速通2","uri":"/leetcode_recite2/"},{"categories":["Leetcode全速通"],"content":"297 Serialize and Deserialize Binary Tree 序列化的时候还是套用模板，先看返回条件，再计算，在看如何选择路线向下递归 反序列化的时候建树时，首先将String中的内容存入到Queue当中，然后套用模版进行递归 代码实战 package com.swagger.leetcode.bfs_dfs; import java.util.Arrays; import java.util.LinkedList; import java.util.Queue; public class leetcode297 { public static String serialize(TreeNode root) { if (root == null) return \"#\"; // preOrder 进行serialize return root.val + \",\" + serialize(root.left) + \",\" + serialize(root.right); } public static TreeNode deserialize(String data) { // 逗号隔开 Queue\u003cString\u003e q = new LinkedList\u003c\u003e(Arrays.asList(data.split(\",\"))); return helper(q); } private static TreeNode helper(Queue\u003cString\u003e q) { String s = q.poll(); // 如果为#，则此点没有节点 if (s.equals(\"#\")) return null; // 新建节点 TreeNode root = new TreeNode(Integer.valueOf(s)); // 先左，后右向下递归 root.left = helper(q); root.right = helper(q); return root; } public static void main(String[] args) { TreeNode node1 = new TreeNode(1); TreeNode node2 = new TreeNode(2); TreeNode node3 = new TreeNode(3); TreeNode node4 = new TreeNode(4); TreeNode node5 = new TreeNode(5); node1.left = node2; node1.right = node5; node2.left = node3; node2.right = node4; String s = serialize(node1); System.out.println(s); TreeNode res_root = deserialize(s); System.out.println(res_root.val); } } ","date":"2022-06-11","objectID":"/leetcode_recite2/:1:7","tags":["Java","Leetcode"],"title":"Leetcode全速通2","uri":"/leetcode_recite2/"},{"categories":["Leetcode全速通"],"content":"124 Binary Tree Maximum Path Sum 路线选择的时候先选出非负单边 再找拱形 最后找只保留拱形的一边，寻找纵向路径 代码实战 package com.swagger.leetcode.bfs_dfs; public class leetcode124 { static int maxValue = Integer.MIN_VALUE; public static int maxPathSum (TreeNode root){ helper(root); return maxValue; } public static int helper (TreeNode node){ // 线路结束条件 if (node == null){ return 0; } // 选出非负单边 int left = Math.max(0, helper(node.left)); int right = Math.max(0, helper(node.right)); // 计算拱形是否更大 maxValue = Math.max(maxValue, left + right + node.val); // 只保留一遍，表示为纵向路径 return Math.max(left, right) + node.val; } } ","date":"2022-06-11","objectID":"/leetcode_recite2/:1:8","tags":["Java","Leetcode"],"title":"Leetcode全速通2","uri":"/leetcode_recite2/"},{"categories":["Leetcode全速通"],"content":"339 Nested List Weight Sum 题目 代码实战 工具类 NestedInteger package com.swagger.leetcode.bfs_dfs; import java.util.ArrayList; import java.util.List; public class NestedInteger { private List\u003cNestedInteger\u003e list; private Integer integer; public NestedInteger(List\u003cNestedInteger\u003e list){ this.list = list; } public void add(NestedInteger nestedInteger) { if(this.list != null){ this.list.add(nestedInteger); } else { this.list = new ArrayList(); this.list.add(nestedInteger); } } public void setInteger(int num) { this.integer = num; } public NestedInteger(Integer integer){ this.integer = integer; } public NestedInteger() { this.list = new ArrayList(); } public boolean isInteger() { return integer != null; } public Integer getInteger() { return integer; } public List\u003cNestedInteger\u003e getList() { return list; } public String printNi(NestedInteger thisNi, StringBuilder sb){ if(thisNi.isInteger()) { sb.append(thisNi.integer); sb.append(\",\"); } sb.append(\"[\"); for(NestedInteger ni : thisNi.list){ if(ni.isInteger()) { sb.append(ni.integer); sb.append(\",\"); } else { printNi(ni, sb); } } sb.append(\"]\"); return sb.toString(); } } DFS package com.swagger.leetcode.bfs_dfs; import java.util.List; public class leetcode339 { public int depthSum(List\u003cNestedInteger\u003e nestedList){ return dfs(nestedList, 1); } public int dfs(List\u003cNestedInteger\u003e nestedList, int level){ int res = 0; for (NestedInteger unit : nestedList) { if (unit.isInteger()){ // 如果已经为数字，则乘以层数，加入到结果当中 res = res + unit.getInteger() * level; }else { // 如果不是，则解开此层，向更深层递归，且层数加一 res = res + dfs(unit.getList(), level + 1); } } return res; } } BFS package com.swagger.leetcode.bfs_dfs; import java.util.LinkedList; import java.util.List; import java.util.Queue; public class leetcode339BFS { public int depthSum(List\u003cNestedInteger\u003e nestedList){ int res = 0, level = 1; Queue\u003cNestedInteger\u003e q = new LinkedList\u003c\u003e(nestedList); while (!q.isEmpty()){ int size = q.size(); for (int i = 0; i \u003c size; i++) { NestedInteger temp = q.poll(); if (temp.isInteger()){ // 如果已经为数字，则乘以层数，加入到结果当中 res = res + temp.getInteger() * level; }else { // 如果不是，则解开此层，入队，向更深层递归，且层数加一 q.addAll(temp.getList()); } level ++; } } return res; } } ","date":"2022-06-11","objectID":"/leetcode_recite2/:1:9","tags":["Java","Leetcode"],"title":"Leetcode全速通2","uri":"/leetcode_recite2/"},{"categories":["MySQL学习"],"content":"外键（了解即可） 一半不这样使用 定义外键key 要去外键添加约束，执行引用 被引用的表（主表）不能直接删除，必须先删除引用表（从表） ","date":"2022-06-09","objectID":"/mysql_learning3/:1:0","tags":["SQL","mysql","navicat"],"title":"MySQL学习3","uri":"/mysql_learning3/"},{"categories":["MySQL学习"],"content":"代码实战 (方式1) 定义一个年级表 CREATETABLE`grade`(`gradeid`INT(10)NOTNULLauto_incrementCOMMENT'年级id',`gradename`VARCHAR(50)notnullCOMMENT'年纪名称',PRIMARYKEY(`gradeid`))ENGINE=INNODBDEFAULTCHARSET=utf8 定一个一个学生表，并将其中的gradeid设置为外键，绑定到年级表 -- 学生表的gradeid 字段 要去引用年级表的gradeid -- 定义外键key -- 要去外键添加约束，执行引用 CREATETABLEifnotEXISTS`student`(`id`int(4)NOTNULLauto_incrementCOMMENT'学号',`name`VARCHAR(30)NOTNULLDEFAULT'匿名'COMMENT'姓名',`pwd`VARCHAR(20)NOTNULLDEFAULT'123456'COMMENT'密码',`sex`VARCHAR(2)NOTNULLDEFAULT'女'COMMENT'性别',`gradeid`INT(10)NOTNULLCOMMENT'年级id',`birthday`DATETIMEDEFAULTNULLCOMMENT'出生日期',`address`VARCHAR(100)DEFAULTNULLCOMMENT'家庭住址',`email`VARCHAR(50)DEFAULTNULLCOMMENT'邮箱',PRIMARYKEY(`id`),-- 添加外键 KEY`FK_gradeid`(`gradeid`),CONSTRAINT`FK_gradeid`FOREIGNKEY(`gradeid`)REFERENCES`grade`(gradeid))ENGINE=INNODBDEFAULTCHARSET=utf8 效果 ","date":"2022-06-09","objectID":"/mysql_learning3/:1:1","tags":["SQL","mysql","navicat"],"title":"MySQL学习3","uri":"/mysql_learning3/"},{"categories":["MySQL学习"],"content":"通过alter添加外键关系 -- 创建表的时候没有外键关系 CREATETABLEifnotEXISTS`student`(`id`int(4)NOTNULLauto_incrementCOMMENT'学号',`name`VARCHAR(30)NOTNULLDEFAULT'匿名'COMMENT'姓名',`pwd`VARCHAR(20)NOTNULLDEFAULT'123456'COMMENT'密码',`sex`VARCHAR(2)NOTNULLDEFAULT'女'COMMENT'性别',`gradeid`INT(10)NOTNULLCOMMENT'年级id',`birthday`DATETIMEDEFAULTNULLCOMMENT'出生日期',`address`VARCHAR(100)DEFAULTNULLCOMMENT'家庭住址',`email`VARCHAR(50)DEFAULTNULLCOMMENT'邮箱',PRIMARYKEY(`id`))ENGINE=INNODBDEFAULTCHARSET=utf8-- 通过alter添加外键关系 ALTERTABLE`student`ADDCONSTRAINT`FK_gradeid`FOREIGNKEY(gradeid)REFERENCES`grade`(`gradeid`) ","date":"2022-06-09","objectID":"/mysql_learning3/:1:2","tags":["SQL","mysql","navicat"],"title":"MySQL学习3","uri":"/mysql_learning3/"},{"categories":["MySQL学习"],"content":"tips 上述添加外键操作都为物理外键，为数据库级别的外键，不推荐使用，删除表的时候会造成麻烦（避免表过多造成困扰） 数据库均为单纯的表，只用来存数据，只有行和列 想使用外键，之后使用程序级别来实现 阿里规范：不得使用外键和级联，一切外键概念必须在应用层解决 ","date":"2022-06-09","objectID":"/mysql_learning3/:1:3","tags":["SQL","mysql","navicat"],"title":"MySQL学习3","uri":"/mysql_learning3/"},{"categories":["MySQL学习"],"content":"DML语言 （全部记住） Database manage language：数据库管理语言 数据库的意义：数据存储，数据管理 ","date":"2022-06-09","objectID":"/mysql_learning3/:2:0","tags":["SQL","mysql","navicat"],"title":"MySQL学习3","uri":"/mysql_learning3/"},{"categories":["MySQL学习"],"content":"DML语言 insert update delete ","date":"2022-06-09","objectID":"/mysql_learning3/:2:1","tags":["SQL","mysql","navicat"],"title":"MySQL学习3","uri":"/mysql_learning3/"},{"categories":["MySQL学习"],"content":"插入 insert 如果主键自增，则可以省略插入主键 一半写插入语句，一定要数据和字段一一对应 代码实战 -- 插入语句（添加） -- 如果主键自增，则可以省略插入主键 -- 一半写插入语句，一定要数据和字段一一对应 insertinto`grade`(`gradename`)VALUES('大四')-- 一个字段插入多个记录 insertinto`grade`(`gradename`)VALUES('大二'),('大一')-- 多个字段插入一个数据 insertinto`student`(`name`,`gradeid`)VALUES('swagger',1)insertinto`student`(`name`,`gradeid`,`pwd`,`sex`)VALUES('Boyan',1,'1234567','男')-- 多个字段插入多个数据 insertinto`student`(`name`,`gradeid`,`pwd`,`sex`)VALUES('Boyan',1,'1234567','男'),('Xinyi',2,'12345678','女') ","date":"2022-06-09","objectID":"/mysql_learning3/:2:2","tags":["SQL","mysql","navicat"],"title":"MySQL学习3","uri":"/mysql_learning3/"},{"categories":["MySQL学习"],"content":"修改 update 需要带where 条件 条件，筛选条件，如果不指定条件，会改动所有的表 多个修改的字段之间使用英文逗号隔开 条件判断 where 代码实战 -- 修改学员名字, 带了where 条件， update`student`set`name`='swaggerwei'where`id`=1;-- 如果不指定条件，会改动表中所有的记录 update`student`set`name`='swaggerwei'-- 修改一条记录的多个字段 update`student`set`name`='swaggerwei',`email`='785403@qq.com'where`id`=1; ","date":"2022-06-09","objectID":"/mysql_learning3/:2:3","tags":["SQL","mysql","navicat"],"title":"MySQL学习3","uri":"/mysql_learning3/"},{"categories":["MySQL学习"],"content":"删除 delete/truncate delete -- DELETE 命令 -- 删除数据（最好避免这样写，会全部删除,有其他专门的方法） DELETEFROM`student`-- 删除指定数据 DELETEFROM`student`WHEREid=1; truncate -- TRUNCATE 命令 -- 完全清空一个数据库表，表的结构和索引约束不会变 -- 清空strudent表 TRUNCATE`student` delete/truncate 异同 相同点：都能删除数据，都不会删除表的结构 不同点：truncate 清零自增列，计数器归零； -- 测试truncate和delete的区别 CREATETABLE`test_delete`(`id`INT(4)notnullAUTO_INCREMENT,`name`VARCHAR(10)notnull,PRIMARYKEY(`id`))ENGINE=INNODBDEFAULTCHARSET=utf8INSERTINTO`test_delete`(`name`)VALUES('1'),('2'),('3')DELETEFROM`test_delete`TRUNCATETABLE`test_delete` 删除之后如果重启数据库（InnoDB） delete 自增列也会清零（存在内存当中，会丢失） MyISAM 继续从上一个自增量开始（存在文件当中，不会丢失） ","date":"2022-06-09","objectID":"/mysql_learning3/:2:4","tags":["SQL","mysql","navicat"],"title":"MySQL学习3","uri":"/mysql_learning3/"},{"categories":["MySQL学习"],"content":"数据库的字段属性（重点） ","date":"2022-06-08","objectID":"/mysql_learning2/:1:0","tags":["SQL","mysql","navicat"],"title":"MySQL学习2","uri":"/mysql_learning2/"},{"categories":["MySQL学习"],"content":"options 设置 engine 数据库引擎设置 default character set 默认字符集 default collation 默认核对 ","date":"2022-06-08","objectID":"/mysql_learning2/:1:1","tags":["SQL","mysql","navicat"],"title":"MySQL学习2","uri":"/mysql_learning2/"},{"categories":["MySQL学习"],"content":"Unsigned 无符号整数 声明了该列不能为负数 ","date":"2022-06-08","objectID":"/mysql_learning2/:1:2","tags":["SQL","mysql","navicat"],"title":"MySQL学习2","uri":"/mysql_learning2/"},{"categories":["MySQL学习"],"content":"Zerofill 0 填充 不足位数 使用0来填充 int（3） 5—-005 ","date":"2022-06-08","objectID":"/mysql_learning2/:1:3","tags":["SQL","mysql","navicat"],"title":"MySQL学习2","uri":"/mysql_learning2/"},{"categories":["MySQL学习"],"content":"auto Increment 自增，自动在上一条的基础上**+1** 通常设置为唯一的主键 index 并且必须为整数类型 可以自定义设置主键自增的起始值和步长 ","date":"2022-06-08","objectID":"/mysql_learning2/:1:4","tags":["SQL","mysql","navicat"],"title":"MySQL学习2","uri":"/mysql_learning2/"},{"categories":["MySQL学习"],"content":"非空 null 和 not null 假设为非空，如果不赋值则会报错 如果不填充，默认就是null ","date":"2022-06-08","objectID":"/mysql_learning2/:1:5","tags":["SQL","mysql","navicat"],"title":"MySQL学习2","uri":"/mysql_learning2/"},{"categories":["MySQL学习"],"content":"default value 设置默认值 sex，如果不设置，则为默认值 ","date":"2022-06-08","objectID":"/mysql_learning2/:1:6","tags":["SQL","mysql","navicat"],"title":"MySQL学习2","uri":"/mysql_learning2/"},{"categories":["MySQL学习"],"content":"拓展-做项目代码规范（学习阶段暂时不用） 表示一个记录存在的意义 id 主键 version 乐观锁 is_delete 伪删除 gmt_create 创建时间 —- 更新操作 gmt_update 修改时间 ","date":"2022-06-08","objectID":"/mysql_learning2/:1:7","tags":["SQL","mysql","navicat"],"title":"MySQL学习2","uri":"/mysql_learning2/"},{"categories":["MySQL学习"],"content":"建表格式 CREATETEBLE[IFNOTEXISTS]`表名`(`字段名`列类型[属性][索引][注释],...`字段名`列类型[属性][索引][注释],`字段名`列类型[属性][索引][注释])[表引擎][字符集设置][注释] tips：charset='utf8' 必须要加，如果不加，使用mysql默认的不支持中文 ","date":"2022-06-08","objectID":"/mysql_learning2/:1:8","tags":["SQL","mysql","navicat"],"title":"MySQL学习2","uri":"/mysql_learning2/"},{"categories":["MySQL学习"],"content":"SQL 代码实战创建表 -- 目标：创建一个school 数据库 -- 创建学生表（列， 字段） 使用SQL创建 -- 学号int；登录密码 varchar（20）；姓名；性别varchar（2）；出生日期（datetime）；家庭住址；email -- 注意点：使用英文括号， 表的名称和字段 尽量使用 `` 括起来 -- auto_increment 自增 -- 字符串使用单引号 括起来 -- 所有的语句后加上英文逗号，最后一个不用加 CREATETABLEifnotEXISTS`student`(`id`int(4)NOTNULLauto_incrementCOMMENT'学号',`name`VARCHAR(30)NOTNULLDEFAULT'匿名'COMMENT'姓名',`pwd`VARCHAR(20)NOTNULLDEFAULT'123456'COMMENT'密码',`sex`VARCHAR(2)NOTNULLDEFAULT'女'COMMENT'性别',`birthday`DATETIMEDEFAULTNULLCOMMENT'出生日期',`address`VARCHAR(100)DEFAULTNULLCOMMENT'家庭住址',`email`VARCHAR(50)DEFAULTNULLCOMMENT'邮箱',PRIMARYKEY(`id`))ENGINE=INNODBDEFAULTCHARSET=utf8 ","date":"2022-06-08","objectID":"/mysql_learning2/:1:9","tags":["SQL","mysql","navicat"],"title":"MySQL学习2","uri":"/mysql_learning2/"},{"categories":["MySQL学习"],"content":"简单的常用命令 查看创建数据库语句 SHOW CREATE DATABASE school 查看student数据表定义语句 SHOW CREATE TABLE student 显式student表的结构 DECS student ","date":"2022-06-08","objectID":"/mysql_learning2/:1:10","tags":["SQL","mysql","navicat"],"title":"MySQL学习2","uri":"/mysql_learning2/"},{"categories":["MySQL学习"],"content":"MyISAM 和 InnoDB的区别 事务：InnoDB 支持事务，MyISAM不支持 外键：InnoDB 支持外键，MyISAM不支持 聚集索引：InnoDB是聚集索引，索引和数据文件绑定在一起，MyISAM是非聚集索引 具体行数：InnoDB不保存具体行数，MyISAM保存 全文索引：InnoDB不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM更高 行级锁：InnoDB支持，MyISAM不支持 表空间：InnoDB较大，约为MyISAM的2倍 ","date":"2022-06-08","objectID":"/mysql_learning2/:2:0","tags":["SQL","mysql","navicat"],"title":"MySQL学习2","uri":"/mysql_learning2/"},{"categories":["MySQL学习"],"content":"修改和删除表字段 ","date":"2022-06-08","objectID":"/mysql_learning2/:3:0","tags":["SQL","mysql","navicat"],"title":"MySQL学习2","uri":"/mysql_learning2/"},{"categories":["MySQL学习"],"content":"修改 -- 修改表 -- 修改表名 ALTERTABLEstudentRENAMEASstudent1-- 增加表的字段 ALTERTABLEteacherADDageINT(11)-- 修改表的字段(修改约束) ALTERTABLEteacherMODIFYagevarchar(11)-- 修改表的字段(字段重命名) ALTERTABLEteacherCHANGEageage1int(10) ","date":"2022-06-08","objectID":"/mysql_learning2/:3:1","tags":["SQL","mysql","navicat"],"title":"MySQL学习2","uri":"/mysql_learning2/"},{"categories":["MySQL学习"],"content":"删除 -- 删除表 -- 删除表的字段 ALTERTABLEteacherDROPage1-- 删除表 DROPTABLEIFEXISTSteacher ","date":"2022-06-08","objectID":"/mysql_learning2/:3:2","tags":["SQL","mysql","navicat"],"title":"MySQL学习2","uri":"/mysql_learning2/"},{"categories":["前端学习"],"content":"HTML 概述 Hyper Text Markup Language（超文本标记语言） 包括文字、图片、音频、视频、动画等 目前最新的为HTML5 主流浏览器基本都支持、跨平台、市场的需求 ","date":"2022-06-02","objectID":"/html_learning1/:1:0","tags":["HTML","前端"],"title":"HTML5 学习1","uri":"/html_learning1/"},{"categories":["前端学习"],"content":"W3C World Wide Web Consortium （万维网联盟） 中立性技术标准机构 ","date":"2022-06-02","objectID":"/html_learning1/:1:1","tags":["HTML","前端"],"title":"HTML5 学习1","uri":"/html_learning1/"},{"categories":["前端学习"],"content":"W3C标准包括 结构化标准语言（HTML、XML） 表现标准语言（CSS） 行为标准（DOM、ECMAScript） ","date":"2022-06-02","objectID":"/html_learning1/:1:2","tags":["HTML","前端"],"title":"HTML5 学习1","uri":"/html_learning1/"},{"categories":["前端学习"],"content":"基本结构 \u003cbody\u003e 和 \u003c/body\u003e 等成对的标签分别为开放标签和闭合标签，一个用来打开，一个用来闭合 \u003cmeta charset=\"UTF-8\"\u003e不成对出现的即为自闭合标签 ","date":"2022-06-02","objectID":"/html_learning1/:1:3","tags":["HTML","前端"],"title":"HTML5 学习1","uri":"/html_learning1/"},{"categories":["前端学习"],"content":"网页的基本信息 注释：\u003c!-- --\u003e \u003c!DOCTYPE html\u003e: 告诉浏览器，使用html规范（实际默认标准也是html） \u003cmeta charset=\"UTF-8\"\u003e：描述字符编码类型 \u003ctitle\u003e我的第一个网页\u003c/title\u003e: 网站标题 body描述网页主体 ","date":"2022-06-02","objectID":"/html_learning1/:2:0","tags":["HTML","前端"],"title":"HTML5 学习1","uri":"/html_learning1/"},{"categories":["前端学习"],"content":"基本内容代码实战 \u003c!--告诉浏览器使用的标准为html规范--\u003e \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003c!--head表示网页的头部--\u003e \u003chead\u003e \u003c!-- meta 描述性标签，用来描述网页的信息--\u003e \u003c!-- meta一般用来做SEO--\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"keywords\" content=\"魏博言\"\u003e \u003cmeta name=\"description\" content=\"魏博言的第一个html的第一个测试文件\"\u003e \u003c!-- 网页标题--\u003e \u003ctitle\u003e我的第一个网页\u003c/title\u003e \u003c/head\u003e \u003c!--网页主体--\u003e \u003cbody\u003e hello world！ \u003c/body\u003e \u003c/html\u003e ","date":"2022-06-02","objectID":"/html_learning1/:2:1","tags":["HTML","前端"],"title":"HTML5 学习1","uri":"/html_learning1/"},{"categories":["前端学习"],"content":"网页基本标签 标题标签 段落标签 换行标签 水平线标签 字体样式标签 注释和特殊符号 ","date":"2022-06-02","objectID":"/html_learning1/:3:0","tags":["HTML","前端"],"title":"HTML5 学习1","uri":"/html_learning1/"},{"categories":["前端学习"],"content":"代码实战 \u003c!--测试基本标签--\u003e \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e基本标签学习\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!--1 标题标签--\u003e \u003ch1\u003e一级标签\u003c/h1\u003e \u003ch2\u003e二级标签\u003c/h2\u003e \u003ch3\u003e三级标签\u003c/h3\u003e \u003ch4\u003e四级标签\u003c/h4\u003e \u003ch5\u003e五级标签\u003c/h5\u003e \u003ch6\u003e六级标签\u003c/h6\u003e \u003c!--段落标签--\u003e \u003cp\u003e第一段内容：反射大范德萨发生的范德萨范德萨范德萨范德萨发生大\u003c/p\u003e \u003cp\u003e第二段内容：放大反射大放送范德萨范德萨发生\u003c/p\u003e \u003cp\u003e第三段内容：放大范德萨范德萨范德萨范德萨范德萨范德萨\u003c/p\u003e \u003c!--水平线标签--\u003e \u003chr\u003e \u003c!--换行标签--\u003e 反射大范德萨范德萨范德萨发生大 \u003cbr\u003e 范德萨范德萨范德萨范德萨范德萨范德萨范德萨 \u003cbr\u003e 发反射大范德萨范德萨范德萨范德萨 \u003cbr\u003e \u003c!--字体样式标签--\u003e \u003ch1\u003e字体样式标签\u003c/h1\u003e 粗体标签：\u003cstrong\u003eI love you\u003c/strong\u003e \u003cbr\u003e 斜体标签：\u003cem\u003eI love you\u003c/em\u003e \u003cbr\u003e \u003c!--特殊符号--\u003e \u003ch1\u003e多个空格-特殊符号\u003c/h1\u003e 空 格 \u003cbr\u003e 空\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;格 \u003cbr\u003e \u0026gt; \u003cbr\u003e \u0026lt; \u003cbr\u003e \u0026copy; 版权所有：魏博言\u003cbr\u003e \u003c!-- 特殊符号记忆方式： \u0026 ； 查百度 --\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-06-02","objectID":"/html_learning1/:3:1","tags":["HTML","前端"],"title":"HTML5 学习1","uri":"/html_learning1/"},{"categories":["前端学习"],"content":"图像标签 常见的图像格式：JPG、GIF、PNG、BMP 嵌入图片的格式： \u003cimg src=\"path\" alt=\"text\" title=\"text\" width=\"x\" height=\"y\"\u003e alt为图像替代文字，title为鼠标悬停的文字 ","date":"2022-06-02","objectID":"/html_learning1/:4:0","tags":["HTML","前端"],"title":"HTML5 学习1","uri":"/html_learning1/"},{"categories":["前端学习"],"content":"代码实战 \u003c!--图像标签测试--\u003e \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e图像标签测试\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cimg src=\"../resource/image/pic1.png\" alt=\"图片1\" title=\"悬停文字\" width=\"300\" height=\"200\"\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-06-02","objectID":"/html_learning1/:4:1","tags":["HTML","前端"],"title":"HTML5 学习1","uri":"/html_learning1/"},{"categories":["前端学习"],"content":"链接标签 文本超链接 图像超链接 格式：\u003ca href=\"path\" target=\"目标窗口位置\"\u003e链接文本或图像\u003c/a\u003e ","date":"2022-06-02","objectID":"/html_learning1/:5:0","tags":["HTML","前端"],"title":"HTML5 学习1","uri":"/html_learning1/"},{"categories":["前端学习"],"content":"代码实战 \u003c!--链接标签--\u003e \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e链接标签\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!--使用id作为标记--\u003e \u003ca id=\"top\"\u003e顶部\u003c/a\u003e \u003cbr\u003e \u003c!--文本超链接--\u003e \u003ca href=\"https://www.baidu.com\"\u003e点击我跳转到百度\u003c/a\u003e \u003cbr\u003e \u003ca href=\"page1.html\"\u003e点击我跳转page1\u003c/a\u003e \u003cbr\u003e \u003c!--图片超链接--\u003e \u003ca href=\"page1.html\"\u003e \u003cimg src=\"../resource/image/pic1.png\" alt=\"图片1\" title=\"悬停文字\" width=\"300\" height=\"200\"\u003e \u003c/a\u003e \u003cbr\u003e \u003c!--target 表示窗口在哪里打开--\u003e \u003ca href=\"page1.html\" target=\"_blank\"\u003e点击我跳转page1-新标签中打开\u003c/a\u003e \u003ca href=\"page1.html\" target=\"_self\"\u003e点击我跳转page1-本标签中打开\u003c/a\u003e \u003cp\u003e \u003cimg src=\"../resource/image/pic1.png\" alt=\"图片1\" title=\"悬停文字\" width=\"300\" height=\"200\"\u003e \u003c/p\u003e \u003cp\u003e \u003cimg src=\"../resource/image/pic1.png\" alt=\"图片1\" title=\"悬停文字\" width=\"300\" height=\"200\"\u003e \u003c/p\u003e \u003cp\u003e \u003cimg src=\"../resource/image/pic1.png\" alt=\"图片1\" title=\"悬停文字\" width=\"300\" height=\"200\"\u003e \u003c/p\u003e \u003cp\u003e \u003cimg src=\"../resource/image/pic1.png\" alt=\"图片1\" title=\"悬停文字\" width=\"300\" height=\"200\"\u003e \u003c/p\u003e \u003cp\u003e \u003cimg src=\"../resource/image/pic1.png\" alt=\"图片1\" title=\"悬停文字\" width=\"300\" height=\"200\"\u003e \u003c/p\u003e \u003cp\u003e \u003cimg src=\"../resource/image/pic1.png\" alt=\"图片1\" title=\"悬停文字\" width=\"300\" height=\"200\"\u003e \u003c/p\u003e \u003cp\u003e \u003cimg src=\"../resource/image/pic1.png\" alt=\"图片1\" title=\"悬停文字\" width=\"300\" height=\"200\"\u003e \u003c/p\u003e \u003cp\u003e \u003cimg src=\"../resource/image/pic1.png\" alt=\"图片1\" title=\"悬停文字\" width=\"300\" height=\"200\"\u003e \u003c/p\u003e \u003cp\u003e \u003cimg src=\"../resource/image/pic1.png\" alt=\"图片1\" title=\"悬停文字\" width=\"300\" height=\"200\"\u003e \u003c/p\u003e \u003cp\u003e \u003cimg src=\"../resource/image/pic1.png\" alt=\"图片1\" title=\"悬停文字\" width=\"300\" height=\"200\"\u003e \u003c/p\u003e \u003cp\u003e \u003cimg src=\"../resource/image/pic1.png\" alt=\"图片1\" title=\"悬停文字\" width=\"300\" height=\"200\"\u003e \u003c/p\u003e \u003c!-- 锚链接 1 需要一个锚标记 2 跳转到标记 # 表示 --\u003e \u003c!--锚链接--\u003e \u003c!--也可以从另一个页面跳到指定位置--\u003e \u003ca href=\"#top\"\u003e回到顶部\u003c/a\u003e \u003ca id=\"down\"\u003e\u003c/a\u003e \u003cbr\u003e \u003c!--功能性链接--\u003e \u003c!--邮件链接 mailto --\u003e \u003ca href=\"mailto:785403310@qq.com\"\u003e点击联系我\u003c/a\u003e \u003c!--功能性链接 qq推广链接--\u003e \u003ca target=\"_blank\" href=\"http://wpa.qq.com/msgrd?v=3\u0026uin=\u0026site=qq\u0026menu=yes\"\u003e\u003cimg border=\"0\" src=\"http://wpa.qq.com/pa?p=2::52\" alt=\"点击联系我qq交谈\" title=\"点击联系我qq交谈\"/\u003e\u003c/a\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-06-02","objectID":"/html_learning1/:5:1","tags":["HTML","前端"],"title":"HTML5 学习1","uri":"/html_learning1/"},{"categories":["Leetcode全速通"],"content":"总览 ","date":"2022-06-01","objectID":"/leetcode_recite1/:1:0","tags":["Java","Leetcode"],"title":"Leetcode全速通1","uri":"/leetcode_recite1/"},{"categories":["Leetcode全速通"],"content":"算法：27题 ","date":"2022-06-01","objectID":"/leetcode_recite1/:1:1","tags":["Java","Leetcode"],"title":"Leetcode全速通1","uri":"/leetcode_recite1/"},{"categories":["Leetcode全速通"],"content":"数据结构：18题 ","date":"2022-06-01","objectID":"/leetcode_recite1/:1:2","tags":["Java","Leetcode"],"title":"Leetcode全速通1","uri":"/leetcode_recite1/"},{"categories":["Leetcode全速通"],"content":"图：6题 ","date":"2022-06-01","objectID":"/leetcode_recite1/:1:3","tags":["Java","Leetcode"],"title":"Leetcode全速通1","uri":"/leetcode_recite1/"},{"categories":["Leetcode全速通"],"content":"dp：9题 ","date":"2022-06-01","objectID":"/leetcode_recite1/:1:4","tags":["Java","Leetcode"],"title":"Leetcode全速通1","uri":"/leetcode_recite1/"},{"categories":["Leetcode全速通"],"content":"二分查找-binary search 一堆数中\"找到指定的数\"这类问题 一堆数必须要存在于数组中、有序排列（无序的话可以用二分法来当猜答案的方法） 所以链表存储就无法使用二分查找了 ","date":"2022-06-01","objectID":"/leetcode_recite1/:2:0","tags":["Java","Leetcode"],"title":"Leetcode全速通1","uri":"/leetcode_recite1/"},{"categories":["Leetcode全速通"],"content":"模板 ","date":"2022-06-01","objectID":"/leetcode_recite1/:2:1","tags":["Java","Leetcode"],"title":"Leetcode全速通1","uri":"/leetcode_recite1/"},{"categories":["Leetcode全速通"],"content":"模板代码 package com.swagger.leetcode.binary_search; public class main { public static int binarySearch1(int[] nums, int target){ int start = 0; int end = nums.length - 1; while (start \u003c= end){ int mid = start + (end - start)/2; if (nums[mid] == target){ return mid; }else if (nums[mid] \u003c target){ start = mid + 1; }else { end = mid - 1; } } return -1; } } ","date":"2022-06-01","objectID":"/leetcode_recite1/:2:2","tags":["Java","Leetcode"],"title":"Leetcode全速通1","uri":"/leetcode_recite1/"},{"categories":["Leetcode全速通"],"content":"leetcode 278 package com.swagger.leetcode.binary_search; public class leetcode278 { public static int firstBadVersion(int n){ int left = 1; int right = n; while (left \u003c= right){ int mid = left + (right - left)/2; if (!isBadVersion(mid)){ left = mid + 1; } else { right = mid - 1; } } return left; // mid是最后一个good version，所以left = mid + 1 之后直接返回left即可 } // 这个没有实现 public static boolean isBadVersion(int version){ return false; } } ","date":"2022-06-01","objectID":"/leetcode_recite1/:2:3","tags":["Java","Leetcode"],"title":"Leetcode全速通1","uri":"/leetcode_recite1/"},{"categories":["Leetcode全速通"],"content":"leetcode 410 二分法去猜最后的答案 关键在于valid()中如何判断是猜大了还是猜小了 package com.swagger.leetcode.binary_search; import java.util.Arrays; public class leetcode410 { public static int splitArray(int[] nums, int m){ int sum = Arrays.stream(nums).sum(); int max = Arrays.stream(nums).max().getAsInt(); return binary(nums, m, sum, max); } public static int binary(int[] nums, int m, int high, int low){ int mid = 0; while (low \u003c= high){ mid = low + (high - low)/2; if (valid(nums, m, mid)){ high = mid - 1; }else { low = mid + 1; } } return low; } public static boolean valid(int[] nums, int m, int subArraySum){ int curSum = 0; int count = 1; for (int num : nums) { curSum += num; if (curSum \u003e subArraySum){ // 第一次分割，不能让curSum超过自己猜的subArraySum curSum = 0; curSum += num; count ++ ; // 分割块数+1 if (count \u003e m){ return false; // 为了让每块和不超过自己猜的subArraySum，导致块数超过m，说明猜小了 } } } return true; // 整个数组遍历完了，都满足，说明猜大了 } } ","date":"2022-06-01","objectID":"/leetcode_recite1/:2:4","tags":["Java","Leetcode"],"title":"Leetcode全速通1","uri":"/leetcode_recite1/"},{"categories":["Leetcode全速通"],"content":"同类型题目 leetcode 1552 leetcode 1482 leetcode 1283 leetcode 1292 ","date":"2022-06-01","objectID":"/leetcode_recite1/:2:5","tags":["Java","Leetcode"],"title":"Leetcode全速通1","uri":"/leetcode_recite1/"},{"categories":["Leetcode全速通"],"content":"leetcode 300 方法1：传统dp + 双指针 方法2：暴力构架subsequence，使用二分法进行优化查找 代码实战 package com.swagger.leetcode.binary_search; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.Map; public class leetcode300 { public static int lengthOfLIS(int[] nums){ // dp + 双指针 // if (nums.length == 0){ // return 0; // } // // int[] dp = new int[nums.length]; // Arrays.fill(dp, 1); // int res = 1; // for (int i = 1; i \u003c nums.length; i++) { // for (int j = 0; j \u003c i; j++) { // if (nums[j] \u003c nums[i]){ // dp[i] = Math.max(dp[j] + 1, dp[i]); // } // res = Math.max(res, dp[i]); // } // } // return res; // 暴力构造subsequence ArrayList\u003cInteger\u003e sub = new ArrayList\u003c\u003e(); sub.add(nums[0]); for (int i = 1; i \u003c nums.length; i++) { int num = nums[i]; if (num \u003e sub.get(sub.size() - 1)){ sub.add(num); // 如果是递增，则加入到递增序列当中 }else { // 更新sub中的element int j = 0; while (num \u003e sub.get(j)){ // 从左开始扫描 // 此处还可以不用从左开始扫描，使用二分法查找进行优化，将n方优化成nlogn j++; } // 比他大才更新 // 但是这种方法构造出来的subsequence 不是最终的序列 // 如果要构造最终的序列不能用这种方法 sub.set(j, num); } } return sub.size(); } } ","date":"2022-06-01","objectID":"/leetcode_recite1/:2:6","tags":["Java","Leetcode"],"title":"Leetcode全速通1","uri":"/leetcode_recite1/"},{"categories":["Leetcode全速通"],"content":"双指针-two pointer 同向双指针 283 move zero；2sum；3sum 对向双指针 11 Container with most water；75 sort color；判断回文字符串；字符串反转；中心扩散法 快慢指针 142 LinkedList quick sort 单调队列和单调栈，sliding window，扫描线 ","date":"2022-06-01","objectID":"/leetcode_recite1/:3:0","tags":["Java","Leetcode"],"title":"Leetcode全速通1","uri":"/leetcode_recite1/"},{"categories":["Leetcode全速通"],"content":"283 move zeros 解法1：开辟额外的空间，碰到非0元素append进去，最后末尾添加0 解法2：同向双指针，left记录最左0的位置，right 向右找到第一个非0数与left交换，然后移动left，具体实现时忽略了swap操作，直接left控制添加非0数，结尾补0 代码实战 package com.swagger.leetcode.two_pointers; public class leetcode283 { public static void moveZeroes(int[] nums){ int left = 0; for (int i = 0; i \u003c nums.length; i++) { if (nums[i] != 0){ nums[left] = nums[i]; left ++ ; } } while (left \u003c nums.length){ nums[left] = 0; left++; } } } ","date":"2022-06-01","objectID":"/leetcode_recite1/:3:1","tags":["Java","Leetcode"],"title":"Leetcode全速通1","uri":"/leetcode_recite1/"},{"categories":["Leetcode全速通"],"content":"11 Container with most water 对向双指针法，哪个矮移动哪个，因为宽度肯定是减少的，所以应该保留更高的那个，才有可能找到更大的存水量 实施维护res 存储最大的存水量 代码实战 package com.swagger.leetcode.two_pointers; public class leetcode11 { public static int maxArea(int[] height) { int res = 0; int left = 0; int right = height.length - 1; while (left \u003c right){ int minHeight = Math.min(height[left], height[right]); int area = minHeight * (right - left); res = Math.max(area, res); // 哪边矮就向内移动哪边，因为宽度肯定是减少的，所以应该保留更高的那个，才有可能找到更大的存水量 if (height[left] \u003c height[right]){ left ++; }else { right --; } } return res; } } ","date":"2022-06-01","objectID":"/leetcode_recite1/:3:2","tags":["Java","Leetcode"],"title":"Leetcode全速通1","uri":"/leetcode_recite1/"},{"categories":["Leetcode全速通"],"content":"16 3Sum Closest 首先进行排序 然后使用三个指针 第一个指针a从左往右，为最外层循环 第二、三（b、c）个指针在a右侧相向而行， 代码实战 package com.swagger.leetcode.two_pointers; import java.util.Arrays; public class leetcode16 { public static void main(String[] args) { int[] nums = {0, 2, 1, -3}; int target = 1; int res = threeSumClosest(nums, target); } public static int threeSumClosest(int[] nums, int target) { int res = nums[0] + nums[1] + nums[nums.length - 1]; Arrays.sort(nums); for (int i = 0; i \u003c nums.length - 2; i++) { int left = i + 1; int right = nums.length - 1; while (left \u003c right){ int sum = nums[i] + nums[left] + nums[right]; if (Math.abs(sum - target) \u003c Math.abs(res - target)){ res = sum; } if (sum \u003e target){ right --; }else { left ++; } } } return res; } } ","date":"2022-06-01","objectID":"/leetcode_recite1/:3:3","tags":["Java","Leetcode"],"title":"Leetcode全速通1","uri":"/leetcode_recite1/"},{"categories":["Leetcode全速通"],"content":"142 Linked List Cycle 2 快慢指针 首先用快慢指针判断是否有环 如果有环则将fast = head 然后开始同速行驶 如果在此相遇，fast的所处的地方即为环的入口 代码实战 package com.swagger.leetcode.two_pointers; public class leetcode142 { public static ListNode detectCycle(ListNode head){ ListNode slow = head; ListNode fast = head; while (fast != null \u0026\u0026 fast.next != null){ fast = fast.next.next; slow = slow.next; if (fast == slow){ // 说明成环了 // 开始寻找入口的索引 fast = head; // 同速行驶再次相遇时，即为入口的索引 while (slow != fast){ fast = fast.next; slow = slow.next; } return slow; } } return null; } } ","date":"2022-06-01","objectID":"/leetcode_recite1/:3:4","tags":["Java","Leetcode"],"title":"Leetcode全速通1","uri":"/leetcode_recite1/"},{"categories":["Leetcode全速通"],"content":"滑动窗口法-sliding window 也是双指针的一种变形，一般为同向 也有的题目和pq或者是单调栈结合 窗口大小可变 窗口大小不变 ","date":"2022-06-01","objectID":"/leetcode_recite1/:4:0","tags":["Java","Leetcode"],"title":"Leetcode全速通1","uri":"/leetcode_recite1/"},{"categories":["Leetcode全速通"],"content":"模板 一般外层为窗口的右端循环，内层为窗口的左端循环，分为如下三个步骤： 1 进：当前遍历的i（窗口右端）进入窗口 2 出：当前不符合条件时（窗口左端）退出窗口 3 算：计算窗口，更新结果 ","date":"2022-06-01","objectID":"/leetcode_recite1/:4:1","tags":["Java","Leetcode"],"title":"Leetcode全速通1","uri":"/leetcode_recite1/"},{"categories":["Leetcode全速通"],"content":"209 Minimum Size Subarray sum 滑动窗口，外层循环为右边界，内层循环为左边界 如果窗口的内容达到了要求，判断size是否更小，更新答案，随后左端右移 代码实战 package com.swagger.leetcode.slidingWindow; public class leetcode209 { public static int minSubArrayLen(int[] nums, int target){ // 求满足要求的最小窗口size int left = 0; int res = Integer.MAX_VALUE; int sum = 0; // 外层循环为右边界 for (int i = 0; i \u003c nums.length; i++) { sum = sum + nums[i]; // 内层循环为左边界 while (sum \u003e= target){ // 如果窗口的内容达到了要求 res = Math.min(res, i - left + 1); // 判断是否更小， 更新答案 // 窗口左端右移 sum = sum - nums[left]; left ++; } } return res == Integer.MAX_VALUE ? 0 : res; } } ","date":"2022-06-01","objectID":"/leetcode_recite1/:4:2","tags":["Java","Leetcode"],"title":"Leetcode全速通1","uri":"/leetcode_recite1/"},{"categories":["Leetcode全速通"],"content":"340 Longest Substring with At Most K Distinct Characters HashMap 记录窗口内每个元素出现的次数 key 为元素，value为出现次数 思路和模板一样，计算时判读HashMap的大小是否超出k的范围 代码实战 package com.swagger.leetcode.slidingWindow; import java.util.HashMap; public class leetcode340 { public static int lengthOfLongestSubstringKDistinct(String s, int k){ HashMap\u003cCharacter, Integer\u003e map = new HashMap\u003c\u003e(); int left = 0; int res = 0; for (int i = 0; i \u003c s.length(); i++) { // 进 char cur = s.charAt(i); map.put(cur, map.getOrDefault(cur, 0) + 1); // 出 while (map.size() \u003e k){// 判断窗口是否符合大小，如果不符合大小，则进入循环内部 char c = s.charAt(left); // 改变left的字符对应key的value-1 map.put(c, map.get(c) - 1); // 如果已经置0了，则移除map中的对应字符 if (map.get(c) == 0){ map.remove(c); } // 窗口左端右移 left++; } // 算 res = Math.max(res, i - left + 1); } return res; } } ","date":"2022-06-01","objectID":"/leetcode_recite1/:4:3","tags":["Java","Leetcode"],"title":"Leetcode全速通1","uri":"/leetcode_recite1/"},{"categories":["注解和反射"],"content":"获取类的运行时结构 ","date":"2022-06-01","objectID":"/java_annotation2/:1:0","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射2","uri":"/java_annotation2/"},{"categories":["注解和反射"],"content":"可以获取到的结构 实现的全部接口 所继承的父类 全部的构造器 全部的方法 全部的Field 注解 ","date":"2022-06-01","objectID":"/java_annotation2/:1:1","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射2","uri":"/java_annotation2/"},{"categories":["注解和反射"],"content":"代码实战 package com.swagger.reflection; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Method; // 获取类的所有信息 public class test06 { public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException { Class c1 = Class.forName(\"com.swagger.reflection.User\"); // 获取类的名字 System.out.println(c1.getName()); // 获取包名+类名 System.out.println(c1.getSimpleName()); // 获取类名 // 获取类的属性 System.out.println(\"=================\"); Field[] fields = c1.getFields(); // 只能找到 public的属性 for (Field field : fields) { System.out.println(field); } Field[] fields2 = c1.getDeclaredFields(); // 可以找到所有的属性 for (Field field : fields2) { System.out.println(field); } // 获取指定属性的方法 Field name = c1.getDeclaredField(\"name\"); System.out.println(name); // 获得类的方法 System.out.println(\"==================\"); Method[] methods = c1.getDeclaredMethods(); // 获取本类的所有方法 for (Method method : methods) { System.out.println(method); } methods = c1.getMethods(); // 获取本类和父类的所有public方法啊 for (Method method : methods) { System.out.println(method); } // 获取指定方法 // 第二个参数是指定方法的所需要的参数列表，因为要考虑到重载的情况 System.out.println(\"======================\"); Method getName = c1.getMethod(\"getName\", null); Method setName = c1.getMethod(\"setName\", String.class); System.out.println(getName); System.out.println(setName); // 获取构造器 System.out.println(\"======================\"); Constructor[] constructors = c1.getConstructors(); for (Constructor constructor : constructors) { System.out.println(constructor); } constructors = c1.getDeclaredConstructors(); for (Constructor constructor : constructors) { System.out.println(constructor); } // 获取指定构造器 Constructor constructor = c1.getConstructor(String.class, int.class, int.class); System.out.println(constructor); constructor = c1.getDeclaredConstructor(String.class, int.class, int.class); System.out.println(constructor); } } ","date":"2022-06-01","objectID":"/java_annotation2/:1:2","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射2","uri":"/java_annotation2/"},{"categories":["注解和反射"],"content":"动态创建对象的执行方法 反射获取类的方法时候如何将其利用起来 实际操作中，获取类信息的操作代码并不会经常开发 一定要熟悉java.lang.reflect包的作用，反射机制 如何获取属性、方法、构造器的名称、修饰符等 ","date":"2022-06-01","objectID":"/java_annotation2/:2:0","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射2","uri":"/java_annotation2/"},{"categories":["注解和反射"],"content":"创建类的对象基本步骤 获取class对象 通过构造器（无参或者有参都是可以的）构造一个对象 实例化对象 ","date":"2022-06-01","objectID":"/java_annotation2/:2:1","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射2","uri":"/java_annotation2/"},{"categories":["注解和反射"],"content":"通过反射调用类中的方法 使用Class类的getMethod方法获取得到一个Method对象 使用invoke激活，并向方法中传入要设置obj对象的参数信息 如果方法为私有，则需要将方法对象的setAccessible设置为真，这样才可以访问到（破坏了封装性） ","date":"2022-06-01","objectID":"/java_annotation2/:2:2","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射2","uri":"/java_annotation2/"},{"categories":["注解和反射"],"content":"代码实战 package com.swagger.reflection; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; // 动态创建对象，通过反射 public class test07 { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException { // 获得class对象 Class\u003c?\u003e c1 = Class.forName(\"com.swagger.reflection.User\"); // 构造一个对象 User user = (User) c1.newInstance(); // 本质上是调用的无参数构造器 System.out.println(user); // 通过构造器构造一个对象 Constructor\u003c?\u003e constructor = c1.getDeclaredConstructor(String.class, int.class, int.class); User user1 = (User) constructor.newInstance(\"swagger\", 001, 18); System.out.println(user1); // 通过反射调用普通方法 User user2 = (User) c1.getDeclaredConstructor().newInstance(); // 通过反射获取一个普通方法 Method setName = c1.getDeclaredMethod(\"setName\", String.class); // invoke 激活 // 反射操作方法 setName.invoke(user2, \"swagger\"); System.out.println(user2.getName()); // 通过反射操作属性 System.out.println(\"===============\"); User user4 = (User) c1.getDeclaredConstructor().newInstance(); Field name = c1.getDeclaredField(\"name\"); name.setAccessible(true); // 取消操作私有属性的安全检测，降低程序效率 name.set(user4, \"swagger2\"); System.out.println(user4.getName()); } } ","date":"2022-06-01","objectID":"/java_annotation2/:2:3","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射2","uri":"/java_annotation2/"},{"categories":["注解和反射"],"content":"性能对比分析 new方法的方法最快 普通反射方式最慢 开放访问权限的反射方式快于普通反射，但是还是大幅落后于new方法 ","date":"2022-06-01","objectID":"/java_annotation2/:3:0","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射2","uri":"/java_annotation2/"},{"categories":["注解和反射"],"content":"代码实战 package com.swagger.reflection; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; // 性能分析 public class test10 { public static void main(String[] args) throws InvocationTargetException, NoSuchMethodException, IllegalAccessException { func1(); func2(); func3(); } // 普通方法调用 public static void func1(){ User user = new User(); long startTime = System.currentTimeMillis(); for (int i = 0; i \u003c 1000000000; i++) { user.getName(); } long endTime = System.currentTimeMillis(); System.out.println(\"普通方法执行10亿次：\" + (endTime - startTime) + \"ms\"); } // 反射方法调用 public static void func2() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { User user = new User(); Class\u003c? extends User\u003e c1 = user.getClass(); Method getName = c1.getDeclaredMethod(\"getName\", null); long startTime = System.currentTimeMillis(); for (int i = 0; i \u003c 1000000000; i++) { getName.invoke(user, null); } long endTime = System.currentTimeMillis(); System.out.println(\"反射方法执行10亿次：\" + (endTime - startTime) + \"ms\"); } // 反射方法调用，关闭检测setAccessible(true) public static void func3() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { User user = new User(); Class\u003c? extends User\u003e c1 = user.getClass(); Method getName = c1.getDeclaredMethod(\"getName\", null); getName.setAccessible(true); long startTime = System.currentTimeMillis(); for (int i = 0; i \u003c 1000000000; i++) { getName.invoke(user, null); } long endTime = System.currentTimeMillis(); System.out.println(\"反射方法(关闭访问限制)执行10亿次：\" + (endTime - startTime) + \"ms\"); } } ","date":"2022-06-01","objectID":"/java_annotation2/:3:1","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射2","uri":"/java_annotation2/"},{"categories":["注解和反射"],"content":"反射操作泛型 package com.swagger.reflection; import java.lang.reflect.Method; import java.lang.reflect.ParameterizedType; import java.lang.reflect.Type; import java.util.List; import java.util.Map; // 通过反射获取泛型 public class test11 { public static void func1(Map\u003cString, User\u003e map, List\u003cUser\u003e list){ System.out.println(\"func1\"); } public Map\u003cString, User\u003e func2(){ System.out.println(\"func2\"); return null; } public static void main(String[] args) throws NoSuchMethodException { Method func1 = test11.class.getMethod(\"func1\", Map.class, List.class); Type[] genericParameterTypes = func1.getGenericParameterTypes(); // 反射获取方法参数泛型 for (Type genericParameterType : genericParameterTypes) { System.out.println(\"#\" + genericParameterType); if (genericParameterType instanceof ParameterizedType){ Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments(); for (Type actualTypeArgument : actualTypeArguments) { System.out.println(actualTypeArgument); } } } // 反射获取方法返回值泛型 System.out.println(\"=============\"); Method func2 = test11.class.getMethod(\"func2\", null); Type genericReturnType = func2.getGenericReturnType(); if (genericReturnType instanceof ParameterizedType){ Type[] actualTypeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments(); for (Type actualTypeArgument : actualTypeArguments) { System.out.println(actualTypeArgument); } } } } ","date":"2022-06-01","objectID":"/java_annotation2/:4:0","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射2","uri":"/java_annotation2/"},{"categories":["注解和反射"],"content":"反射获取注解信息 ","date":"2022-06-01","objectID":"/java_annotation2/:5:0","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射2","uri":"/java_annotation2/"},{"categories":["注解和反射"],"content":"实例 ORM - Object Relationship Mapping 对象关系映射 类和表结构对应 属性和字段对应 对象和记录对应 要求：利用注解和反射完成类和表结构的映射关系 ","date":"2022-06-01","objectID":"/java_annotation2/:5:1","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射2","uri":"/java_annotation2/"},{"categories":["注解和反射"],"content":"代码实战 package com.swagger.reflection; import java.lang.annotation.*; import java.lang.reflect.Field; // 反射操作注解 public class test12 { public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException { Class\u003c?\u003e c1 = Class.forName(\"com.swagger.reflection.Student2\"); // 通过反射获得注解 Annotation[] annotations = c1.getAnnotations(); for (Annotation annotation : annotations) { System.out.println(annotation); } // 获取注解value的值 TableSwagger annotation = c1.getAnnotation(TableSwagger.class); System.out.println(annotation.value()); // 获得类指定的注解 Field name = c1.getDeclaredField(\"name\"); FieldSwagger annotation1 = name.getAnnotation(FieldSwagger.class); System.out.println(annotation1.columnName()); System.out.println(annotation1.type()); System.out.println(annotation1.length()); } } @TableSwagger(\"db_student\") class Student2{ @FieldSwagger(columnName = \"db_id\", type = \"int\", length = 10) private int id; @FieldSwagger(columnName = \"db_age\", type = \"int\", length = 10) private int age; @FieldSwagger(columnName = \"db_name\", type = \"varchar\", length = 3) private String name; public Student2(int id, int age, String name) { this.id = id; this.age = age; this.name = name; } public Student2() { } public int getId() { return id; } public void setId(int id) { this.id = id; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"Student2{\" + \"id=\" + id + \", age=\" + age + \", name='\" + name + '\\'' + '}'; } } // 类名的注解 @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @interface TableSwagger{ String value(); } // 属性的注解 @Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) @interface FieldSwagger{ String columnName(); String type(); int length(); } ","date":"2022-06-01","objectID":"/java_annotation2/:5:2","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射2","uri":"/java_annotation2/"},{"categories":["注解和反射"],"content":"注解 Annotation 如图所示，以@开头的修饰符 注释为comment，注意区分开，以 //开头 ","date":"2022-05-31","objectID":"/java_annotation/:1:0","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射1","uri":"/java_annotation/"},{"categories":["注解和反射"],"content":"什么是注解 JDK5.0引入的新技术 Annotation的作用：不是程度本身，可以对程序做出解释； 可以被其他程序（比如编译器）读取 格式：注解是用@开头的修饰符在代码中存在的，还可以添加一些参数值，例如@SuppressWarnings(value=“unchecked”) 哪里使用：可以附加在package，class，method，field等上面，相当于给他们添加了额外的辅助信息，我么你可以通过反射机制编程实现对这些元数据的访问 ","date":"2022-05-31","objectID":"/java_annotation/:1:1","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射1","uri":"/java_annotation/"},{"categories":["注解和反射"],"content":"内置注解 @Override：定义在java.lang.Override中，此注释只适用于修辞方法，表示一个方法声明打算重写超累中的另一个方法申明，只能用来修饰方法 @Deprecated：定义在java.lang.Deprecated中，此注释可以用于修辞方法，表示不鼓励程序员使用，通常有更好的选择，但是可以使用 @SuppressWarnings：抑制编译时的警告信息，这个内置注解需要参数，可以用来修饰类或者方法 ","date":"2022-05-31","objectID":"/java_annotation/:2:0","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射1","uri":"/java_annotation/"},{"categories":["注解和反射"],"content":"代码测试 package com.swagger.annotation; import java.util.ArrayList; import java.util.List; public class test01 { // @Override 重写注解，只能用来修饰方法 @Override public String toString() { return super.toString(); } // @Deprecated 不推荐程序员使用，但是可以使用，或者存在更好的方式 @Deprecated public static void test(){ System.out.println(\"Deprecated\"); } // @SuppressWarnings(\"all\")，镇压警告，所有的警告都不提醒，也可以用来修饰类 @SuppressWarnings(\"all\") public static void test1(){ List list = new ArrayList(); } public static void main(String[] args) { test(); test1(); } } ","date":"2022-05-31","objectID":"/java_annotation/:2:1","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射1","uri":"/java_annotation/"},{"categories":["注解和反射"],"content":"元注解 meta-annotation 元注解的作用就是负责注解其他注解，Java定一了4个标准的meta-annotation类型 ","date":"2022-05-31","objectID":"/java_annotation/:3:0","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射1","uri":"/java_annotation/"},{"categories":["注解和反射"],"content":"分类 @Target：注解的使用范围 @Retention：什么级别保存该注解，用于描述注解的声明周期（SOURCE\u003cCLASS\u003cRUNTIME一般都是RUNTIME） @Document：该注释将会被包含在javadoc中 @Inherited：说明子类可以继承父类中的该注解 ","date":"2022-05-31","objectID":"/java_annotation/:3:1","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射1","uri":"/java_annotation/"},{"categories":["注解和反射"],"content":"代码 package com.swagger.annotation; import java.lang.annotation.*; // 测试元注解 public class test20 { @MyAnnotation public void test(){ } } // 定一个一个注解 // Target表示注解可以用在那个地方 @Target(value = {ElementType.METHOD, ElementType.TYPE}) // Retention表示什么级别才有效 @Retention(value = RetentionPolicy.RUNTIME) // Document表示是否将注解生成在javadoc中 @Documented // Inherited 表示子类可以继承父类的注解 @Inherited @interface MyAnnotation{ } ","date":"2022-05-31","objectID":"/java_annotation/:3:2","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射1","uri":"/java_annotation/"},{"categories":["注解和反射"],"content":"自定义注解 使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口 格式 public @interface 注解名 {定义内容} 其中每一个方法实际上是声明了一个配置参数 方法的名称就是参数的名称 返回值类型就是参数的类型，返回值只能是基本类型（Class，String，enum） 可以通过default来声明参数的默认值 如果只有一个参数成员，一般参数名为value 注解元素必须要有值，我们定义注解元素是，经常使用空字符串，0作为默认值 ","date":"2022-05-31","objectID":"/java_annotation/:4:0","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射1","uri":"/java_annotation/"},{"categories":["注解和反射"],"content":"实战代码 package com.swagger.annotation; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; // 自定义注解 public class test03 { // 注解可以显式赋值，如果没有默认值，就一定要直接赋值 @MyAnnotation2(name = \"swagger\", schools = {\"1高\", \"12高\"}) // 有默认值就可以不写 public void test(){} @MyAnnotation3(value = \"1\") public void test2(){} } @Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @interface MyAnnotation2{ // 注解的参数：参数类型 + 参数名（） String name() default \"\"; int age() default 0; int id() default -1; // 如果默认值为-1，代表不存在 String[] schools() default {\"清华\", \"北大\"}; } @Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @interface MyAnnotation3{ String value(); // 如果只有一个参数，直接使用value作为参数名, 并且使用时参数列表中可以省略value } ","date":"2022-05-31","objectID":"/java_annotation/:4:1","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射1","uri":"/java_annotation/"},{"categories":["注解和反射"],"content":"反射概述 ","date":"2022-05-31","objectID":"/java_annotation/:5:0","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射1","uri":"/java_annotation/"},{"categories":["注解和反射"],"content":"动态语言 运行的时候代码可以根据某些条件改变自身的结构 主要动态语言：Object-C、C#、JavaScript、PHP、Pyhton ","date":"2022-05-31","objectID":"/java_annotation/:5:1","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射1","uri":"/java_annotation/"},{"categories":["注解和反射"],"content":"静态语言 运行时结构不变的语言就是静态语言：Java、C、C++ Java不是动态语言，但是可以称为准动态语言，可以通过反射机制让其活的类似动态语言的特性 ","date":"2022-05-31","objectID":"/java_annotation/:5:2","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射1","uri":"/java_annotation/"},{"categories":["注解和反射"],"content":"Java Reflection 反射机制运行程序在执行期借助于Reflection API去的任何类的内部信息，并能直接操作任意对象的内部属性及方法 加载完成类之后，在堆内存中就有一个Clss类型的对象，通过反射可以看到类的结构 ","date":"2022-05-31","objectID":"/java_annotation/:5:3","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射1","uri":"/java_annotation/"},{"categories":["注解和反射"],"content":"Java 反射机制提供的功能 运行时判断任意一个对象所属的类 运行时构造任意一个类的对象 运行时判断任意一个类所具有的方法和成员变量 运行时获取泛型信息 运行时调用任意一个对象的成员变量和方法 运行时处理注解 生成动态代理 ","date":"2022-05-31","objectID":"/java_annotation/:5:4","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射1","uri":"/java_annotation/"},{"categories":["注解和反射"],"content":"反射的优点和缺点 优点 可以动态创建对象和编译，体现出很大的灵活性 缺点 对性能有影响，为解释行操作，我们可以告诉JVM希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作 破坏封装性，影响安全 ","date":"2022-05-31","objectID":"/java_annotation/:5:5","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射1","uri":"/java_annotation/"},{"categories":["注解和反射"],"content":"反射获取对象 ","date":"2022-05-31","objectID":"/java_annotation/:6:0","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射1","uri":"/java_annotation/"},{"categories":["注解和反射"],"content":"class 类 对象照镜子之后可以得到的信息，某个类的属性、方法、构造器、某个类实现了哪些接口 对于每个类而言，JRE都为妻保留了一个不变的Class类型的对象。 一个Class对象包含了特定某个结构（class/interface/enum/annotation/primitive type/void/[]）的有关信息 Class本身也是一个类 Class对象只能由系统建立对象 一个加载的类在JVM中只会有一个Class实例 一个Class对象对应的是一个加载到JVM中的一个class文件 每个类的实例都会记得自己是由哪个Class实例所生成的 通过Class可以完整地得到一个类中所有被加载的结构 Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获取相应的Class对象 ","date":"2022-05-31","objectID":"/java_annotation/:6:1","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射1","uri":"/java_annotation/"},{"categories":["注解和反射"],"content":"如何获取Class类的实例 若已知具体的类，通过类的class属性获取（最为安全可靠，性能最高）Class clazz = Person.class; 已知某个类的实例，通过实例的getClass()方法获取Class对象 Class clazz = person.getClass(); 已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException异常 Class clazz = Class.forName(\"demo.Student\") 内置基本数据类型可以直接用类名.Type 还可以利用ClassLoader ","date":"2022-05-31","objectID":"/java_annotation/:6:2","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射1","uri":"/java_annotation/"},{"categories":["注解和反射"],"content":"代码实战 package com.swagger.reflection; public class test02 { public static void main(String[] args) throws ClassNotFoundException { Person person = new Student(); System.out.println(\"这个人是：\" + person.name); // 获取Class // 方法1： 通过对象获得 Class c1 = person.getClass(); System.out.println(c1.hashCode()); // 方式2：forName获取 Class c2 = Class.forName(\"com.swagger.reflection.Student\"); System.out.println(c2.hashCode()); // 方式3：通过 类名.class Class c3 = Student.class; System.out.println(c3.hashCode()); // 方法4：基本内置类型的包装类都有一个Type属性 Class c4 = Integer.TYPE; System.out.println(c4); // 获得父类类型 System.out.println(c1.getSuperclass()); } } class Person{ public String name; public Person() { } public Person(String name) { this.name = name; } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + '}'; } } class Student extends Person{ public Student() { this.name = \"学生\"; } } class Teacher extends Person{ public Teacher() { this.name = \"老师\"; } } ","date":"2022-05-31","objectID":"/java_annotation/:6:3","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射1","uri":"/java_annotation/"},{"categories":["注解和反射"],"content":"所有类型的Class对象 ","date":"2022-05-31","objectID":"/java_annotation/:7:0","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射1","uri":"/java_annotation/"},{"categories":["注解和反射"],"content":"哪些类型可以有Class对象 class：外部类、成员（成员内部类，静态内部类）、局部内部类、匿名内部类 interface：接口 []：数组 enum：枚举 annotation：注解@interface primitive type：基本数据类型 void ","date":"2022-05-31","objectID":"/java_annotation/:7:1","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射1","uri":"/java_annotation/"},{"categories":["注解和反射"],"content":"代码实战 package com.swagger.reflection; import java.lang.annotation.ElementType; // 所有类型的Class对象 public class test03 { public static void main(String[] args) { Class c1 = Object.class; // 类 Class c2 = Comparable.class; // 接口 Class c3 = String[].class; // 一维数组 Class c4 = int[][].class; // 二维数组 Class c5 = Override.class; // 注解 Class c6 = ElementType.class; // 枚举 Class c7 = Integer.class; // 基本数据类型 Class c8 = void.class; // void Class c9 = Class.class; // Class System.out.println(c1); System.out.println(c2); System.out.println(c3); System.out.println(c4); System.out.println(c5); System.out.println(c6); System.out.println(c7); System.out.println(c8); System.out.println(c9); // 只要元素类型与维度一样，就是同一个class对象 int[] a = new int[10]; int[] b = new int[100]; System.out.println(a.getClass().hashCode()); System.out.println(b.getClass().hashCode()); } } ","date":"2022-05-31","objectID":"/java_annotation/:7:2","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射1","uri":"/java_annotation/"},{"categories":["注解和反射"],"content":"类加载内存分析 1 加载：类的数据（静态变量、静态方法、常量迟、代码）加载到内存，会产生对应java.lang.Class对象对应方法去中加载的各个类 2 链接：分配内存，并输入一个默认的值 3 初始化：静态方法块合并起来 ","date":"2022-05-31","objectID":"/java_annotation/:8:0","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射1","uri":"/java_annotation/"},{"categories":["注解和反射"],"content":"代码实战 package com.swagger.reflection; // 类加载内存分析 public class test04 { public static void main(String[] args) { A a = new A(); System.out.println(A.m); /* 1 加载到内存，会产生一个类对应Class对象 2 链接，链接结束后m的初始化值为0 3 初始化, 静态代码块全部合并，执行后发现m为100 \u003cclinit\u003e(){ System.out.println(\"A类静态代码块初始化\"); m = 300; m = 100; } */ } } class A{ static { System.out.println(\"A类静态代码块初始化\"); m = 300; } static int m = 100; public A(){ System.out.println(\"A类的无参构造方法初始化\"); } } ","date":"2022-05-31","objectID":"/java_annotation/:8:1","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射1","uri":"/java_annotation/"},{"categories":["注解和反射"],"content":"分析类的初始化（何时一个类会被初始化） ","date":"2022-05-31","objectID":"/java_annotation/:9:0","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射1","uri":"/java_annotation/"},{"categories":["注解和反射"],"content":"主动初始化 new 关键字：如果父类没有初始化，会主动初始化父类 反射：如果父类没有初始化，会主动初始化父类 ","date":"2022-05-31","objectID":"/java_annotation/:9:1","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射1","uri":"/java_annotation/"},{"categories":["注解和反射"],"content":"被动初始化 当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量时，不会导致子类的初始化 通过数组定义类的引用 引用常量(常量在链接阶段就已经存入调用类的常量池了) ","date":"2022-05-31","objectID":"/java_annotation/:9:2","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射1","uri":"/java_annotation/"},{"categories":["注解和反射"],"content":"代码实战 package com.swagger.reflection; public class test05 { static { System.out.println(\"Main类被加载\"); } public static void main(String[] args) throws ClassNotFoundException { // 1 主动引用 // new 关键字：如果父类没有初始化，会主动初始化父类 // Son son = new Son(); // 反射：如果父类没有初始化，会主动初始化父类 // Class.forName(\"com.swagger.reflection.Son\"); // 3 被动引用 // 当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量时，不会导致子类的初始化 // System.out.println(Son.b); // 通过数组定义类的引用 Son[] Array = new Son[10]; // 引用常量 System.out.println(Son.x); } } class Father{ static int b = 2; static { System.out.println(\"父类被加载\"); } } class Son extends Father{ static { System.out.println(\"子类被加载\"); m = 300; } static int m = 100; static final int x = 1; } ","date":"2022-05-31","objectID":"/java_annotation/:9:3","tags":["Java","注解","反射"],"title":"Java Annotation注解和反射1","uri":"/java_annotation/"},{"categories":["Java网络编程"],"content":"TCP 实现文件上传 ","date":"2022-05-13","objectID":"/java_net2/:1:0","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"客户端 创建一个Socket连接 创建一个输出流，用于发送TCP连接中的数据 创建一个文件输入流fis，用于读取文件 通过文件输入流fis，将文件写出到输出流os中 通过shutdownOutput提示服务器已经传输完毕 确定服务器已经接收完毕了 最后关闭资源，顺序和创建顺序相反 tips：注意尽量不要抛出，否则会有很多异常需要抛出，尽量用try catch来处理 package com.swagger.lesson02; import java.io.*; import java.net.InetAddress; import java.net.Socket; import java.net.UnknownHostException; // TCP上传文件 客户端发送 public class TCPClientDemo02 { public static void main(String[] args) throws IOException { // 尽量不要抛出，否则会有很多异常需要抛出 // 1 创建一个Socket连接 Socket socket = new Socket(InetAddress.getByName(\"127.0.0.1\"), 9000); // 2 创建一个输出流 OutputStream os = socket.getOutputStream(); // 3 读取文件 FileInputStream fis = new FileInputStream(new File(\"pic.png\")); // 4 写出文件 到输出流 os中去 byte[] buffer = new byte[1024]; int len; while ((len = fis.read(buffer)) != -1){ os.write(buffer); } // 5 通知服务器，我已经结束了 socket.shutdownOutput();// 我已经传输完了 // 6 确定服务端接收完毕了 InputStream inputStream = socket.getInputStream(); ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] buffer2 = new byte[1024]; int len2; while ((len2 = inputStream.read(buffer2)) != -1){ baos.write(buffer2); } System.out.println(baos.toString()); // 7 关闭资源，关闭顺序和创建顺序相反 baos.close(); inputStream.close(); fis.close(); os.close(); socket.close(); } } ","date":"2022-05-13","objectID":"/java_net2/:1:1","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"服务端 创建一个服务 监听客户端的请求连接，阻塞式监听，会一直等待客户端的连接请求 读取客户端的消息, 获取输入流 读取文件，将文件进行输出 通知客户端我已经接收完了 关闭资源 package com.swagger.lesson02; import java.io.*; import java.net.ServerSocket; import java.net.Socket; // TCP上传文件 服务端接收端 public class TCPServerDemo02 { public static void main(String[] args) throws IOException { // 1 创建一个服务 ServerSocket serverSocket = new ServerSocket(9000); // 2 监听客户端的请求连接 // 阻塞式监听，会一直等待客户端的连接请求 Socket socket = serverSocket.accept(); // 3 读取客户端的消息, 获取输入流 InputStream is = socket.getInputStream(); // 4 读取文件，将文件进行输出 FileOutputStream fileOutputStream = new FileOutputStream(new File(\"received.png\")); byte[] buffer = new byte[1024]; int len; while ((len = is.read(buffer)) != -1){ fileOutputStream.write(buffer, 0, len); } // 5 通知客户端我已经接收完了 OutputStream outputStream = socket.getOutputStream(); outputStream.write(\"我接受完毕了，你可以断开了\".getBytes()); // 6 关闭资源 fileOutputStream.close(); is.close(); socket.close(); serverSocket.close(); } } ","date":"2022-05-13","objectID":"/java_net2/:1:2","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"Tomcat tomcat是一个免费的，开放源代码的Web应用服务器，是Apache软件基金会项目中的一个核心项目，由Apache ，Sun和一些公司以及个人共同开发而成，深受Java爱好者的喜爱，是一款比较流行的web应用服务器 可以自定义服务端和客户端，就像前文的TCP实现消息传输和文件上传一样 也可以使用已经写好的开源Web应用服务项目Tomcat ","date":"2022-05-13","objectID":"/java_net2/:2:0","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"Tomcat 核心组件 web容器:完成web服务器的功能 servlet容器:名字为catalina，用于处理Servlet代码。 JSP容器:用于将JSP动态网页翻译成Servlet代码 因此Tomcat是web应用服务器，也是一个Servlet/JSP容器。Tomcat作为 Servlet容器，负责处理客户请求，把请求传送给servlet，并将servlet的响应传送回给客户 ","date":"2022-05-13","objectID":"/java_net2/:2:1","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"什么是servlet Servlet 是 Java Servlet 的简称，可以理解为是一个服务连接器，是用Java编写的服务器端程序，具有独立于平台和协议的特性，简单的理解: servlet就是一个中间件，包含了接口和方法，将客户端和数据库连接，从而实现动态网页的创建 ","date":"2022-05-13","objectID":"/java_net2/:2:2","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"什么是JSP JSP 全称 Java Server Pages，是一种动态网页开发技术。它使用JSP 标签在HTML,网页中插入Java代码。标签通常以 \u003c% 开头，以 %\u003e 结束。 JSP是一种Java servlet，主要用于实现Java web 应用程序的用户界面部分 JSP通过网页表单获取用户输入数据、访问数据库及其他数据源，然后动态地创建网页 ","date":"2022-05-13","objectID":"/java_net2/:2:3","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"Tomcat 功能组件结构 负责接收和反馈外部请求的连接器Connector，和负责处理请求的容器Container 连接器和容器相辅相成，一起构成了基本的 web服务Service。每个Tomcat服务器可以管理多个Service Conector: 负责对外接收和响应请求。它是Tomcat与外界的交通枢纽，监听端口接收外界请求，并将请求处理后传递给容器做业务处理，最后将容器处理后的结果响应给外界 Container: 负责对内处理业务逻辑。其内部由 Engine、Host、Context和wrapper 四个容器组成，用于管理和调用Servlet相关逻辑 Service:对外提供的web服务。主要包含Connector和 Container两个核心组件，以及其他功能组件。Tomcat可以管理多个Service，且各Service 之间相互独立 ","date":"2022-05-13","objectID":"/java_net2/:2:4","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"Container结构分析 每个Service 会包含一个Container容器。在Container内部包含了4个子容器:4个子容器的作用分别是 Engine:引擎，用来管理多个虚拟主机，一个Service最多只能有一个Engine； Host:代表一个虚拟主机，也可以叫站点，通过配置 Host 就可以添加站点 Context:代表一个 web 应用，包含多个Servlet封装器 wrapper:封装器，容器的最底层。每一Wrapper封装着一个Servlet，负责对象实例的创建、执行和销毁功能 Engine、Host、Context和 wrapper，这四个容器之间属于父子关系。 容器由一个引擎可以管理多个虚拟主机。每个虚拟主机可以管理多个web应用。每个web应用会有多个Servlet封装器 ","date":"2022-05-13","objectID":"/java_net2/:2:5","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"Tomcat请求过程 用户在浏览器中输入网址，请求被发送到本机端口8080，被在那里监听的 Connector获得； Connector 把该请求交给它所在的Service 的 Engine (Container）来处理，并等待Engine的回应; 请求在Engine、Host、Context和Wwrapper 这四个容器之间层层调用，最后在Servlet 中执行对应的业务逻辑、数据存储等 执行完之后的请求响应在Context、Host、Engine容器之间层层返回，最后返回给Connector，并通过Connector 返回给客户端 ","date":"2022-05-13","objectID":"/java_net2/:2:6","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"UDP消息发送 不用连接上，就可以发送消息，只用知道对方的地址 ","date":"2022-05-13","objectID":"/java_net2/:3:0","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"客户端 建立一个UDP Socket 建一个数据包 指明packet中的参数，说明发送给谁 发送数据包 关闭流close 不需要服务器端打开就可以发送消息，不保证消息的一定可达，所以直接运行客户端是不报错的 package com.swagger.lesson03; import java.io.IOException; import java.net.*; public class UdpClientDemo01 { public static void main(String[] args) throws IOException { // 1 建立一个UDP Socket DatagramSocket socket = new DatagramSocket(); // 2 建一个数据包 String msg = \"你好服务器\"; // 3 发送给谁 InetAddress inetAddress = InetAddress.getByName(\"localhost\"); int port = 9090; DatagramPacket packet = new DatagramPacket(msg.getBytes(), 0, msg.getBytes().length, inetAddress, port); // 4 发送数据包 socket.send(packet); // 5 关闭流 socket.close(); // 不需要服务器端打开就可以发送消息，不保证消息的一定可达，所以直接运行客户端是不报错的 } } ","date":"2022-05-13","objectID":"/java_net2/:3:1","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"接收端 开放端口 接收数据包，并且打印接收的数据 关闭连接 实际上不存在TCP中的服务端，因为服务端也可以用客户端的方式发送消息 package com.swagger.lesson03; import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.SocketException; // 只有保持服务端在监听状态，才能接收到数据包 public class UdpServerDemo01 { public static void main(String[] args) throws IOException { // 1 开放端口 DatagramSocket socket = new DatagramSocket(9090); // 2 接收数据包 byte[] buffer = new byte[1024]; DatagramPacket packet = new DatagramPacket(buffer, 0, buffer.length); socket.receive(packet); System.out.println(packet.getAddress().getHostAddress()); System.out.println(new String(packet.getData(), 0, packet.getLength())); // 3 关闭连接 socket.close(); } } ","date":"2022-05-13","objectID":"/java_net2/:3:2","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"UDP聊天实现 ","date":"2022-05-13","objectID":"/java_net2/:4:0","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"发送方 新建一个UDP Socket 新建一个Buffer Reader 用于读取发送的消息 新建一个UDP Packet ，并将发送的数据填入其中，发送 如果检测到bye，字样的消息，则结束 消息可以循环发送 最后关闭socket package com.swagger.lesson04_chat; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; import java.net.SocketException; public class UdpSenderDemo01 { public static void main(String[] args) throws IOException { DatagramSocket socket = new DatagramSocket(8888); // 准备数据：控制台读取数据 System.in BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); while (true){ String data = reader.readLine(); byte[] datas = data.getBytes(); InetAddress inetAddress = InetAddress.getByName(\"localhost\"); int port = 6666; DatagramPacket packet = new DatagramPacket(datas, 0, datas.length, inetAddress, port); socket.send(packet); if (data.equals(\"bye\")){ break; } } socket.close(); } } ","date":"2022-05-13","objectID":"/java_net2/:4:1","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"接收方 新建一个UDP Socket 新建一个UDP Packet，并将接收到的数据填入到容器中 阻塞式接收包裹 socket.receive(packet); 使用packet中的getData 取出接收的数据 打印出接收的消息 检测如果消息为bye，则停止接收消息 package com.swagger.lesson04_chat; import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.SocketException; public class UdpReceiverDemo01 { public static void main(String[] args) throws IOException { DatagramSocket socket = new DatagramSocket(6666); while (true){ // 准备接收包裹 byte[] container = new byte[1024]; DatagramPacket packet = new DatagramPacket(container, 0, container.length); socket.receive(packet); // 阻塞式接收包裹 // 断开连接 如果为bye，则断开连接 byte[] data = packet.getData(); String receive_data = new String(data, 0, packet.getLength()); System.out.println(receive_data); if (receive_data.equals(\"bye\")){ break; } } socket.close(); } } ","date":"2022-05-13","objectID":"/java_net2/:4:2","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"UDP多线程实现咨询 多线程实现 聊天的双方都需要有发送线程和接收线程 互相之间的发送线程和接收线程需要对应 ","date":"2022-05-13","objectID":"/java_net2/:5:0","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"发送线程类 实现Runnable接口即可 package com.swagger.lesson04_chat; import java.io.BufferedReader; import java.io.InputStreamReader; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; import java.net.InetSocketAddress; public class TalkSend implements Runnable{ DatagramSocket socket = null; BufferedReader reader = null; private int fromPort; private String toIP; private int toPort; public TalkSend(int fromPort, String toIP, int toPort) { this.fromPort = fromPort; this.toIP = toIP; this.toPort = toPort; try{ socket = new DatagramSocket(this.fromPort); reader = new BufferedReader(new InputStreamReader(System.in)); }catch (Exception e){ e.printStackTrace(); } } @Override public void run() { while (true){ try{ String data = reader.readLine(); byte[] datas = data.getBytes(); InetAddress inetAddress = InetAddress.getByName(\"localhost\"); int port = 6666; DatagramPacket packet = new DatagramPacket(datas, 0, datas.length, new InetSocketAddress(this.toIP, this.toPort)); socket.send(packet); if (data.equals(\"bye\")){ break; } }catch (Exception e){ e.printStackTrace(); } } socket.close(); } } ","date":"2022-05-13","objectID":"/java_net2/:5:1","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"接收线程类 实现Runnable 接口 package com.swagger.lesson04_chat; import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; public class TalkReceive implements Runnable{ DatagramSocket socket = null; private int port; private String msgFrom; public TalkReceive(int port, String msgFrom) { this.port = port; this.msgFrom = msgFrom; try{ socket = new DatagramSocket(port); }catch (Exception e){ e.printStackTrace(); } } @Override public void run() { while (true){ try { // 准备接收包裹 byte[] container = new byte[1024]; DatagramPacket packet = new DatagramPacket(container, 0, container.length); socket.receive(packet); // 阻塞式接收包裹 // 断开连接 如果为bye，则断开连接 byte[] data = packet.getData(); String receive_data = new String(data, 0, packet.getLength()); System.out.println(msgFrom+\":\"+receive_data); if (receive_data.equals(\"bye\")){ break; } } catch (IOException e) { e.printStackTrace(); } } socket.close(); } } ","date":"2022-05-13","objectID":"/java_net2/:5:2","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"聊天双方 均同时创建发送和接收线程 总共四个线程之间在通信 package com.swagger.lesson04_chat; public class TalkStudent { public static void main(String[] args) { // 开启线程 // 静态代理模式 new Thread(new TalkSend(777, \"localhost\", 9999)).start(); new Thread(new TalkReceive(8888, \"老师\")).start(); } } package com.swagger.lesson04_chat; public class TalkTeacher { public static void main(String[] args) { // 开启线程 // 静态代理模式 new Thread(new TalkSend(5555, \"localhost\", 8888)).start(); new Thread(new TalkReceive(9999, \"学生\")).start(); } } ","date":"2022-05-13","objectID":"/java_net2/:5:3","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"URL 下载网路资源 同意资源定位符号，定位网络上的某一个资源 DNS域名解析，将一个网址解析为一个IP地址 协议://ip地址: 端口号/项目名/资源 ","date":"2022-05-13","objectID":"/java_net2/:6:0","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"测试url中的主要方法 package com.swagger.lesson05; import java.net.MalformedURLException; import java.net.URL; public class URLDemo01 { public static void main(String[] args) { try { URL url = new URL(\"http://localhost:8080/helloworld/index.jsp?username=swagger\u0026password=123\"); System.out.println(url.getProtocol()); // 协议 System.out.println(url.getHost()); // 主机ip System.out.println(url.getPort()); // 端口 System.out.println(url.getPath()); // 文件 System.out.println(url.getFile()); // 全路径 System.out.println(url.getQuery()); // 参数 } catch (MalformedURLException e) { e.printStackTrace(); } } } ","date":"2022-05-13","objectID":"/java_net2/:6:1","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"url 下载文件 package com.swagger.lesson05; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.net.HttpURLConnection; import java.net.MalformedURLException; import java.net.URL; public class URLDownload { public static void main(String[] args) { try { // 1. 下载地址 URL url = new URL(\"http://localhost:8080/swagger/testURL_learning.txt\"); // 2 连接到这个资源 HTTP HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection(); // 3 下载 InputStream inputStream = urlConnection.getInputStream(); // 4 写入到文件 FileOutputStream fileOutputStream = new FileOutputStream(\"testURL_learning.txt\"); byte[] buffer = new byte[1024]; int len; while ((len = inputStream.read(buffer)) != -1){ fileOutputStream.write(buffer, 0, len); } // 5 关闭资源 fileOutputStream.close(); inputStream.close(); urlConnection.disconnect(); } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } } ","date":"2022-05-13","objectID":"/java_net2/:6:2","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["小开发"],"content":" 游戏名：贪吃蛇 github 地址：https://github.com/SwaggerWei/SnakeGame ","date":"2022-05-12","objectID":"/develop_gamesnake/:0:0","tags":["Java游戏","awt","swing"],"title":"贪吃蛇开发","uri":"/develop_gamesnake/"},{"categories":["小开发"],"content":"资源导入 ","date":"2022-05-12","objectID":"/develop_gamesnake/:1:0","tags":["Java游戏","awt","swing"],"title":"贪吃蛇开发","uri":"/develop_gamesnake/"},{"categories":["小开发"],"content":"步骤 单独定一个资源类，所有的数据变量都定义为静态变量，方便获取 使用 java.net.URL 获取文件地址 然后转换为swing中的ImageIcon格式 ","date":"2022-05-12","objectID":"/develop_gamesnake/:1:1","tags":["Java游戏","awt","swing"],"title":"贪吃蛇开发","uri":"/develop_gamesnake/"},{"categories":["小开发"],"content":"源码 package com.swagger.snake; import javax.swing.*; import java.net.URL; // 存放外部数据 public class Data { // 头部图片 使用URL类，定位图片地址 public static URL headerUrl = Data.class.getResource(\"/statics/header1.png\"); public static ImageIcon header = new ImageIcon(headerUrl); // // 头部图片 public static URL upUrl = Data.class.getResource(\"/statics/up1.png\"); public static URL downUrl = Data.class.getResource(\"/statics/down1.png\"); public static URL leftUrl = Data.class.getResource(\"/statics/left1.png\"); public static URL rightUrl = Data.class.getResource(\"/statics/right1.png\"); public static ImageIcon up = new ImageIcon(upUrl); public static ImageIcon down = new ImageIcon(downUrl); public static ImageIcon left = new ImageIcon(leftUrl); public static ImageIcon right = new ImageIcon(rightUrl); // // 身体 public static URL bodyUrl1 = Data.class.getResource(\"/statics/body1.png\"); public static ImageIcon body1 = new ImageIcon(bodyUrl1); // // 食物 public static URL foodUrl = Data.class.getResource(\"/statics/food1.png\"); public static ImageIcon food = new ImageIcon(foodUrl); } ","date":"2022-05-12","objectID":"/develop_gamesnake/:1:2","tags":["Java游戏","awt","swing"],"title":"贪吃蛇开发","uri":"/develop_gamesnake/"},{"categories":["小开发"],"content":"绘制主窗口 ","date":"2022-05-12","objectID":"/develop_gamesnake/:2:0","tags":["Java游戏","awt","swing"],"title":"贪吃蛇开发","uri":"/develop_gamesnake/"},{"categories":["小开发"],"content":"步骤 使用JFrame绘制一个静态窗口 设置页面打洗哦啊 设置窗口是否可调整大小 设置关闭事件,可以通过右上角叉叉进行关闭 加入一个JPanel到JFrame窗口当中 设置窗口的可见性，这一步应该放到最后，不然画板中的内容不能生效 ","date":"2022-05-12","objectID":"/develop_gamesnake/:2:1","tags":["Java游戏","awt","swing"],"title":"贪吃蛇开发","uri":"/develop_gamesnake/"},{"categories":["小开发"],"content":"源码 package com.swagger.snake; import javax.swing.*; public class StartGames { public static void main(String[] args) { // 1 绘制一个静态窗口 JFrame JFrame jFrame = new JFrame(\"swagger-Java-贪吃蛇小游戏\"); // 设置页面大小 jFrame.setBounds(10, 10, 900, 720); // 设置窗口是否可调整大小 jFrame.setResizable(true); // 设置关闭事件,可以通过右上角叉叉进行关闭 jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 2 面板 JPanel 可以加入到JFrame jFrame.add(new GamePanel()); // 设置窗口的可见性，这一步应该放到最后，不然画板中的内容不能生效 jFrame.setVisible(true); } } ","date":"2022-05-12","objectID":"/develop_gamesnake/:2:2","tags":["Java游戏","awt","swing"],"title":"贪吃蛇开发","uri":"/develop_gamesnake/"},{"categories":["小开发"],"content":"GamePanel 类：继承JPanel，实现KeyListener和ActionListener ","date":"2022-05-12","objectID":"/develop_gamesnake/:3:0","tags":["Java游戏","awt","swing"],"title":"贪吃蛇开发","uri":"/develop_gamesnake/"},{"categories":["小开发"],"content":"构造函数 调用init() 完成各种初始化操作 获取键盘监听事件，是的键盘聚焦到游戏上，然后添加一个键盘监听者 让事件定义的Timer实例动起来start public GamePanel(){ init(); // 获取键盘的监听事件 this.setFocusable(true);// 键盘聚焦到游戏上 this.addKeyListener(this); // 时间动起来 timer.start(); } ","date":"2022-05-12","objectID":"/develop_gamesnake/:3:1","tags":["Java游戏","awt","swing"],"title":"贪吃蛇开发","uri":"/develop_gamesnake/"},{"categories":["小开发"],"content":"初始化init 初始化长度和蛇头蛇身坐标 初始化食物坐标，注意不能和蛇重合 初始化分数为0 public void init(){ length = 3; snakeX[0] = 100; snakeY[0] = 100; // 蛇头坐标 snakeX[1] = 75; snakeY[1] = 100; // 第一节身体坐标 snakeX[2] = 50; snakeY[2] = 100; // 蛇头坐标 boolean isFoodCoveredByBody = false; while (true){ // 重新生成食物坐标 foodx = 25 + 25 * random.nextInt(34); foody = 75 + 25 * random.nextInt(24); for (int i = 0; i \u003c length; i++) { if (foodx == snakeX[i] \u0026\u0026 foody == snakeY[i]){ isFoodCoveredByBody = true; } } if (isFoodCoveredByBody == true){ continue; }else { break; } } score = 0; } ","date":"2022-05-12","objectID":"/develop_gamesnake/:3:2","tags":["Java游戏","awt","swing"],"title":"贪吃蛇开发","uri":"/develop_gamesnake/"},{"categories":["小开发"],"content":"绘制静态画板 调用父类，达到清屏效果 设置背景的颜色 从Data中获取header绘制头部广告栏 绘制游戏区域 画一条静态小蛇，注意头方向的判断，然后绘制身体 画积分，设置画积分的各种参数 画一个食物 提示游戏开始，注意判断是否为开始状态 失败提醒，注意判断是否为失败状态 protected void paintComponent(Graphics g) { // 1 绘制静态面板 // 调用父类，达到清屏效果 super.paintComponent(g); // 设置背景的颜色 this.setBackground(Color.WHITE); // 绘制头部广告栏 Data.header.paintIcon(this, g, 25, 11); // 绘制游戏区域 g.fillRect(25, 75, 850, 600); // 2 画一条静态的小蛇 // 画蛇头 if (direction.equals(\"R\")){ Data.right.paintIcon(this, g, snakeX[0], snakeY[0]); }else if (direction.equals(\"L\")){ Data.left.paintIcon(this, g, snakeX[0], snakeY[0]); }else if (direction.equals(\"U\")){ Data.up.paintIcon(this, g, snakeX[0], snakeY[0]); }else if (direction.equals(\"D\")){ Data.down.paintIcon(this, g, snakeX[0], snakeY[0]); } // 画蛇身体 for (int i = 1; i \u003c length; i++) { // 蛇的身体长度，通过length 参数来控制 Data.body1.paintIcon(this, g, snakeX[i], snakeY[i]); } String font = \"微软雅黑\"; // 字体类型 // 3 画积分 g.setColor(Color.WHITE); // 设置画笔的颜色 g.setFont(new Font(font, Font.BOLD, 18)); g.drawString(\"长度：\" + length, 750, 30); g.drawString(\"分数：\" + score, 750, 50); // 4 画一个食物 Data.food.paintIcon(this, g, foodx, foody); // 5 游戏提示，是否开始 if (isStart == false){ // 画一个文字 g.setColor(Color.WHITE); // 设置画笔的颜色 g.setFont(new Font(font, Font.BOLD, 40)); g.drawString(\"按下空格开始游戏\", 300, 300); } // 6 失败提醒 if (isFail == true){ // 画一个文字 g.setColor(Color.RED); // 设置画笔的颜色 g.setFont(new Font(font, Font.BOLD, 40)); g.drawString(\"游戏失败，按下空格重新开始\", 200, 300); } } ","date":"2022-05-12","objectID":"/develop_gamesnake/:3:3","tags":["Java游戏","awt","swing"],"title":"贪吃蛇开发","uri":"/develop_gamesnake/"},{"categories":["小开发"],"content":"接受键盘输入 空格键控制暂停和开始，注意首先判断是否为失败状态，如果为失败状态，则重新init，重制各项数据，如果没有失败则进把是否开始状态置反 接受键盘输入，改变方向，注意控制相反方向不能改变 public void keyPressed(KeyEvent e) { // 键盘：按下（未释放） // 获取按下的键盘是哪一个键 int keyCode = e.getKeyCode(); if (keyCode == KeyEvent.VK_SPACE){ // 如果按下的是空格键 if (isFail == true){ isFail = false; init(); // 重新初始化游戏 }else { isStart = !isStart; } // 刷新界面 repaint(); } // 键盘控制走向 if (keyCode == KeyEvent.VK_LEFT){ if (direction != \"R\"){direction = \"L\";} }else if (keyCode == KeyEvent.VK_RIGHT){ if (direction != \"L\"){direction = \"R\";} }else if (keyCode == KeyEvent.VK_UP){ if (direction != \"D\"){direction = \"U\";} }else if (keyCode == KeyEvent.VK_DOWN){ if (direction != \"U\"){direction = \"D\";} } } ","date":"2022-05-12","objectID":"/develop_gamesnake/:3:4","tags":["Java游戏","awt","swing"],"title":"贪吃蛇开发","uri":"/develop_gamesnake/"},{"categories":["小开发"],"content":"actionPerformed 首先身体移动，再移动头部，注意控制边界判断 判断蛇头是否和食物重合，如果重合则重新生成食物，注意重新生成的食物不能和蛇重合 进行失败判断，蛇头不能和蛇身重合 刷新界面repaint，进入下一帧 public void actionPerformed(ActionEvent e) { // 如果游戏处于开始状态, 并且游戏没有失败 if (isStart \u0026\u0026 isFail == false){ for (int i = length - 1; i \u003e 0 ; i--) { // 身体移动 snakeX[i] = snakeX[i-1]; snakeY[i] = snakeY[i-1]; } // 通过控制方向让头部移动 if (direction == \"R\"){ if (snakeX[0] \u003e 825){snakeX[0] = 0;}// 边界判断 snakeX[0] = snakeX[0] + 25; // 头部移动 }else if (direction == \"L\"){ if (snakeX[0] \u003c 50){snakeX[0] = 825;}// 边界判断 snakeX[0] = snakeX[0] - 25; // 头部移动 }else if (direction == \"U\"){ if (snakeY[0] \u003c 100){snakeY[0] = 675;}// 边界判断 snakeY[0] = snakeY[0] - 25; // 头部移动 }else if (direction == \"D\"){ if (snakeY[0] \u003e 625){snakeY[0] = 75;}// 边界判断 snakeY[0] = snakeY[0] + 25; // 头部移动 } // 如果蛇头和食物的坐标重合，说明吃到了食物 if (snakeX[0] == foodx \u0026\u0026 snakeY[0] == foody){ // 蛇的长度+1 length ++; score = score+10; // 重新生成食物 // 如果重新生成的食物坐标和蛇身或者头部相重合，则重新生成 boolean isFoodCoveredByBody = false; while (true){ // 重新生成食物坐标 foodx = 25 + 25 * random.nextInt(34); foody = 75 + 25 * random.nextInt(24); for (int i = 0; i \u003c length; i++) { if (foodx == snakeX[i] \u0026\u0026 foody == snakeY[i]){ isFoodCoveredByBody = true; } } if (isFoodCoveredByBody == true){ continue; }else { break; } } } // 失败判断 for (int i = 1; i \u003c length; i++) { if (snakeX[0] == snakeX[i] \u0026\u0026 snakeY[0] == snakeY[i]){ isFail = true; } } // 刷新界面 this.repaint(); } timer.start();// 时间动起来 } ","date":"2022-05-12","objectID":"/develop_gamesnake/:3:5","tags":["Java游戏","awt","swing"],"title":"贪吃蛇开发","uri":"/develop_gamesnake/"},{"categories":["小开发"],"content":"源码 package com.swagger.snake; import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.KeyEvent; import java.awt.event.KeyListener; import java.util.Random; public class GamePanel extends JPanel implements KeyListener, ActionListener{ // 定义一个蛇 int length; // 蛇的长度 int[] snakeX = new int[600];// 蛇的坐标X int[] snakeY = new int[500];// 蛇的坐标Y boolean isStart = false;// 游戏是否开始 String direction = \"R\";// 蛇的方向 Timer timer = new Timer(100, this); // 间隔100ms 触发一次 // 定义一个食物 int foodx; int foody; Random random = new Random(); // 判断失败 boolean isFail = false; // 游戏积分榜 int score; // 构造函数 public GamePanel(){ init(); // 获取键盘的监听事件 this.setFocusable(true);// 键盘聚焦到游戏上 this.addKeyListener(this); // 时间动起来 timer.start(); } // 初始化 public void init(){ length = 3; snakeX[0] = 100; snakeY[0] = 100; // 蛇头坐标 snakeX[1] = 75; snakeY[1] = 100; // 第一节身体坐标 snakeX[2] = 50; snakeY[2] = 100; // 蛇头坐标 boolean isFoodCoveredByBody = false; while (true){ // 重新生成食物坐标 foodx = 25 + 25 * random.nextInt(34); foody = 75 + 25 * random.nextInt(24); for (int i = 0; i \u003c length; i++) { if (foodx == snakeX[i] \u0026\u0026 foody == snakeY[i]){ isFoodCoveredByBody = true; } } if (isFoodCoveredByBody == true){ continue; }else { break; } } score = 0; } // 画板： 画界面、画蛇 // Graphics：为一个画笔 @Override protected void paintComponent(Graphics g) { // 1 绘制静态面板 // 调用父类，达到清屏效果 super.paintComponent(g); // 设置背景的颜色 this.setBackground(Color.WHITE); // 绘制头部广告栏 Data.header.paintIcon(this, g, 25, 11); // 绘制游戏区域 g.fillRect(25, 75, 850, 600); // 2 画一条静态的小蛇 // 画蛇头 if (direction.equals(\"R\")){ Data.right.paintIcon(this, g, snakeX[0], snakeY[0]); }else if (direction.equals(\"L\")){ Data.left.paintIcon(this, g, snakeX[0], snakeY[0]); }else if (direction.equals(\"U\")){ Data.up.paintIcon(this, g, snakeX[0], snakeY[0]); }else if (direction.equals(\"D\")){ Data.down.paintIcon(this, g, snakeX[0], snakeY[0]); } // 画蛇身体 for (int i = 1; i \u003c length; i++) { // 蛇的身体长度，通过length 参数来控制 Data.body1.paintIcon(this, g, snakeX[i], snakeY[i]); } String font = \"微软雅黑\"; // 字体类型 // 3 画积分 g.setColor(Color.WHITE); // 设置画笔的颜色 g.setFont(new Font(font, Font.BOLD, 18)); g.drawString(\"长度：\" + length, 750, 30); g.drawString(\"分数：\" + score, 750, 50); // 4 画一个食物 Data.food.paintIcon(this, g, foodx, foody); // 5 游戏提示，是否开始 if (isStart == false){ // 画一个文字 g.setColor(Color.WHITE); // 设置画笔的颜色 g.setFont(new Font(font, Font.BOLD, 40)); g.drawString(\"按下空格开始游戏\", 300, 300); } // 6 失败提醒 if (isFail == true){ // 画一个文字 g.setColor(Color.RED); // 设置画笔的颜色 g.setFont(new Font(font, Font.BOLD, 40)); g.drawString(\"游戏失败，按下空格重新开始\", 200, 300); } } // 接受键盘输入 @Override public void keyPressed(KeyEvent e) { // 键盘：按下（未释放） // 获取按下的键盘是哪一个键 int keyCode = e.getKeyCode(); if (keyCode == KeyEvent.VK_SPACE){ // 如果按下的是空格键 if (isFail == true){ isFail = false; init(); // 重新初始化游戏 }else { isStart = !isStart; } // 刷新界面 repaint(); } // 键盘控制走向 if (keyCode == KeyEvent.VK_LEFT){ if (direction != \"R\"){direction = \"L\";} }else if (keyCode == KeyEvent.VK_RIGHT){ if (direction != \"L\"){direction = \"R\";} }else if (keyCode == KeyEvent.VK_UP){ if (direction != \"D\"){direction = \"U\";} }else if (keyCode == KeyEvent.VK_DOWN){ if (direction != \"U\"){direction = \"D\";} } } // 定时器，监听时间 帧：执行定时操作 @Override public void actionPerformed(ActionEvent e) { // 如果游戏处于开始状态, 并且游戏没有失败 if (isStart \u0026\u0026 isFail == false){ for (int i = length - 1; i \u003e 0 ; i--) { // 身体移动 snakeX[i] = snakeX[i-1]; snakeY[i] = snakeY[i-1]; } // 通过控制方向让头部移动 if (direction == \"R\"){ if (snakeX[0] \u003e 825){snakeX[0] = 0;}// 边界判断 snakeX[0] = snakeX[0] + 25; // 头部移动 }else if (direction == \"L\"){ if (snakeX[0] \u003c 50){snakeX[0] = 825;}// 边界判断 snakeX[0] = snakeX[0] - 25; // 头部移动 }else if (direction == \"U\"){ if (snakeY[0] \u003c 100){snakeY[0] = 675;}// 边界判断 snakeY[0] = snakeY[0] - 25; // 头部移动 }else if (direction == \"D\"){ if (snakeY[0] \u003e 625){snakeY[0] = 75;}// 边界判断 snakeY[0] = snakeY[0] + 25; // 头部移动 } // 如果蛇头和食物的坐标重合，说明吃到了食物 if (snakeX[0] == foodx \u0026\u0026 snakeY[0] == foody){ // 蛇的长度+1 length ++; score = score+1","date":"2022-05-12","objectID":"/develop_gamesnake/:3:6","tags":["Java游戏","awt","swing"],"title":"贪吃蛇开发","uri":"/develop_gamesnake/"},{"categories":["pytorch"],"content":"Loss损失函数与反向传播 ","date":"2022-05-11","objectID":"/pytorch_learning2/:1:0","tags":["Pytorch","深度学习"],"title":"pytorch学习2","uri":"/pytorch_learning2/"},{"categories":["pytorch"],"content":"loss 损失函数 描述输出与真实值之间的差距 为更新输出提供一定的证据 ","date":"2022-05-11","objectID":"/pytorch_learning2/:1:1","tags":["Pytorch","深度学习"],"title":"pytorch学习2","uri":"/pytorch_learning2/"},{"categories":["pytorch"],"content":"L1Loss 衡量Groud Truth 和 output 之间的平均绝对误差 MAE（Mean Absolute Error）平均绝对误差 ","date":"2022-05-11","objectID":"/pytorch_learning2/:1:2","tags":["Pytorch","深度学习"],"title":"pytorch学习2","uri":"/pytorch_learning2/"},{"categories":["pytorch"],"content":"MSELoss MSE Mean square Error 平局平方误差 ","date":"2022-05-11","objectID":"/pytorch_learning2/:1:3","tags":["Pytorch","深度学习"],"title":"pytorch学习2","uri":"/pytorch_learning2/"},{"categories":["pytorch"],"content":"CrossEntropyLoss 交叉熵误差， 适用于分类问题 输入参数：target 真实分类数、x 每一个类别的可能性数组 EG：target = 0 在第0,1,2三个类别中属于第1类；x = [0.2, 0.3, 0.1] (对应每一种类别的可能性) ","date":"2022-05-11","objectID":"/pytorch_learning2/:1:4","tags":["Pytorch","深度学习"],"title":"pytorch学习2","uri":"/pytorch_learning2/"},{"categories":["pytorch"],"content":"反向传播 计算完loss之后反向传播, 计算每个节点梯度 每一次计算出一个每一个数据计算出一个loss，就会对应一个梯度；然后根据梯度进行下降，更新参数节点，达到使得loss 越来越小的机制 ","date":"2022-05-11","objectID":"/pytorch_learning2/:1:5","tags":["Pytorch","深度学习"],"title":"pytorch学习2","uri":"/pytorch_learning2/"},{"categories":["pytorch"],"content":"各种loss源码测试 import torch from torch import nn input = torch.tensor([1, 2, 3], dtype=float) target = torch.tensor([1, 2, 5], dtype=float) input = torch.reshape(input, (1, 1, 1, 3)) target = torch.reshape(target, (1, 1, 1, 3)) # loss = nn.L1Loss(reduction=\"sum\") loss_mae = nn.L1Loss() loss_mse = nn.MSELoss() output_mae = loss_mae(input, target) output_mse = loss_mse(input, target) print(output_mae) print(output_mse) ","date":"2022-05-11","objectID":"/pytorch_learning2/:1:6","tags":["Pytorch","深度学习"],"title":"pytorch学习2","uri":"/pytorch_learning2/"},{"categories":["pytorch"],"content":"loss 训练测试 import torchvision from torch import nn from torch.nn import Sequential, Conv2d, MaxPool2d from torch.nn import Flatten, Linear, CrossEntropyLoss from torch.utils.data import DataLoader # 准备数据集 # 代码在src中， 把数据集下载到 \"../data\"， 也就是退到上一层目录， 新建一个目data dataset = torchvision.datasets.CIFAR10(\"../data\", train=False, transform=torchvision.transforms.ToTensor(), download=True) # 将数据转换为tensor数据类型 一个batch为64 dataloader = DataLoader(dataset=dataset, batch_size=1) class SwaggerCifar(nn.Module): def __init__(self): super(SwaggerCifar, self).__init__() self.model1 = Sequential( Conv2d(in_channels=3, out_channels=32, kernel_size=5, stride=1, padding=2), MaxPool2d(kernel_size=2), Conv2d(in_channels=32, out_channels=32, kernel_size=5, stride=1, padding=2), MaxPool2d(kernel_size=2), Conv2d(in_channels=32, out_channels=64, kernel_size=5, stride=1, padding=2), MaxPool2d(kernel_size=2), Flatten(), Linear(in_features=1024, out_features=64), Linear(in_features=64, out_features=10) ) def forward(self, x): x = self.model1(x) return x swagger = SwaggerCifar() # print(swagger) # 创建loss函数 loss = CrossEntropyLoss() # 从dataloader中取数据 for data in dataloader: imgs, targets = data outputs = swagger(imgs) loss_result = loss(input=outputs, target=targets) loss_result.backward() # print(outputs) # print(targets) print(loss_result) ","date":"2022-05-11","objectID":"/pytorch_learning2/:1:7","tags":["Pytorch","深度学习"],"title":"pytorch学习2","uri":"/pytorch_learning2/"},{"categories":["pytorch"],"content":"optim优化器使用 ","date":"2022-05-11","objectID":"/pytorch_learning2/:2:0","tags":["Pytorch","深度学习"],"title":"pytorch学习2","uri":"/pytorch_learning2/"},{"categories":["pytorch"],"content":"原理 在求出loss之后执行backward 得到每个节点的梯度（gradient） 然后使用优化器进行优化 ","date":"2022-05-11","objectID":"/pytorch_learning2/:2:1","tags":["Pytorch","深度学习"],"title":"pytorch学习2","uri":"/pytorch_learning2/"},{"categories":["pytorch"],"content":"常用的优化器及其参数 Adam optimizer SGD optimizer 参数：模型参数、学习率LR、momentum ","date":"2022-05-11","objectID":"/pytorch_learning2/:2:2","tags":["Pytorch","深度学习"],"title":"pytorch学习2","uri":"/pytorch_learning2/"},{"categories":["pytorch"],"content":"SGD optimizer 在循环外定义一个优化器 型中上一步计算的梯度进行清零 输入经过网络 计算loss 反向传播计算梯度 梯度下降法更新梯度 ","date":"2022-05-11","objectID":"/pytorch_learning2/:2:3","tags":["Pytorch","深度学习"],"title":"pytorch学习2","uri":"/pytorch_learning2/"},{"categories":["pytorch"],"content":"学习率设置 太大容易模型优化不稳定 太小模型一直是保持正向优化， 但是优化速度过慢 应该设置一个合适的学习率 或者开始的时候设置一个大的学习率，在后期设置一个小的学习率 ","date":"2022-05-11","objectID":"/pytorch_learning2/:2:4","tags":["Pytorch","深度学习"],"title":"pytorch学习2","uri":"/pytorch_learning2/"},{"categories":["pytorch"],"content":"源码测试 import torchvision from torch import nn, optim from torch.nn import Sequential, Conv2d, MaxPool2d from torch.nn import Flatten, Linear, CrossEntropyLoss from torch.utils.data import DataLoader # 准备数据集 # 代码在src中， 把数据集下载到 \"../data\"， 也就是退到上一层目录， 新建一个目data dataset = torchvision.datasets.CIFAR10(\"../data\", train=False, transform=torchvision.transforms.ToTensor(), download=True) # 将数据转换为tensor数据类型 一个batch为64 dataloader = DataLoader(dataset=dataset, batch_size=64) class SwaggerCifar(nn.Module): def __init__(self): super(SwaggerCifar, self).__init__() self.model1 = Sequential( Conv2d(in_channels=3, out_channels=32, kernel_size=5, stride=1, padding=2), MaxPool2d(kernel_size=2), Conv2d(in_channels=32, out_channels=32, kernel_size=5, stride=1, padding=2), MaxPool2d(kernel_size=2), Conv2d(in_channels=32, out_channels=64, kernel_size=5, stride=1, padding=2), MaxPool2d(kernel_size=2), Flatten(), Linear(in_features=1024, out_features=64), Linear(in_features=64, out_features=10) ) def forward(self, x): x = self.model1(x) return x swagger = SwaggerCifar() # print(swagger) # 创建loss函数 loss = CrossEntropyLoss() # 定义optimizer optimizer = optim.SGD(swagger.parameters(), lr=0.01) # 从dataloader中取数据 for epoch in range(20): loss_per_epoch = 0.0 for data in dataloader: # 清零上一个循环计算的梯度grad optimizer.zero_grad() # 取数据 imgs, targets = data # 数据输入进神经网络 outputs = swagger(imgs) # 计算loss loss_result = loss(input=outputs, target=targets) # 反向传播计算梯度 loss_result.backward() # 优化器根据梯度对网络参数进行更新（step） optimizer.step() loss_per_epoch = loss_per_epoch + loss_result # print(outputs) # print(targets) # print(loss_result) print(loss_per_epoch) ","date":"2022-05-11","objectID":"/pytorch_learning2/:2:5","tags":["Pytorch","深度学习"],"title":"pytorch学习2","uri":"/pytorch_learning2/"},{"categories":["pytorch"],"content":"完整模型训练验证源码 # -*- coding:utf-8 -*- import torch import torchvision from torch import nn, optim from torch.nn import Sequential, Conv2d, MaxPool2d from torch.nn import Flatten, Linear, CrossEntropyLoss from torch.utils.data import DataLoader from torch.utils.tensorboard import SummaryWriter gpu_device = 7 train_data = torchvision.datasets.CIFAR10(\"../data_cifar10\", train=True, transform=torchvision.transforms.ToTensor(), download=True) test_data = torchvision.datasets.CIFAR10(\"../data_cifar10\", train=False, transform=torchvision.transforms.ToTensor(), download=True) train_data_size = train_data.__len__() test_data_size = test_data.__len__() print(\"train dataset length: {}\".format(train_data_size)) print(\"test dataset length: {}\".format(test_data_size)) batchsize = 64 train_dataloader = DataLoader(train_data, batch_size=batchsize) test_dataloader = DataLoader(test_data, batch_size=batchsize) class SwaggerCifar(nn.Module): def __init__(self): super(SwaggerCifar, self).__init__() self.module1 = Sequential( Conv2d(in_channels=3, out_channels=32, kernel_size=5, stride=1, padding=2), MaxPool2d(kernel_size=2), Conv2d(in_channels=32, out_channels=32, kernel_size=5, stride=1, padding=2), MaxPool2d(kernel_size=2), Conv2d(in_channels=32, out_channels=64, kernel_size=5, stride=1, padding=2), MaxPool2d(kernel_size=2), Flatten(), Linear(in_features=1024, out_features=64), Linear(in_features=64, out_features=10) ) def forward(self, x): x = self.module1(x) return x swagger = SwaggerCifar() if torch.cuda.is_available(): swagger = swagger.cuda(gpu_device) loss = CrossEntropyLoss() if torch.cuda.is_available(): loss = loss.cuda(gpu_device) learing_rate = 0.01 optimizer = optim.SGD(swagger.parameters(), learing_rate) writer = SummaryWriter(\"../logs_cifar\") total_train_step = 0 total_test_step = 0 epoch = 2 for i in range(epoch): print(\"------the {}th epoch------\".format(i + 1)) total_train_loss = 0.0 swagger.train() for data in train_dataloader: imgs, targets = data if torch.cuda.is_available(): imgs = imgs.cuda(gpu_device) targets = targets.cuda(gpu_device) outputs = swagger(imgs) loss_result = loss(input=outputs, target=targets) optimizer.zero_grad() loss_result.backward() optimizer.step() total_train_step = total_train_step + 1 total_train_loss = total_train_loss + loss_result if total_train_step % 50 == 0: print(\"train step: {}, loss: {}\".format(total_train_step, loss_result.item())) writer.add_scalar(\"train_loss\", loss_result.item(), total_train_step) swagger.eval() total_test_loss = 0.0 total_accuracy = 0.0 with torch.no_grad(): for data in test_dataloader: imgs, targets = data if torch.cuda.is_available(): imgs = imgs.cuda(gpu_device) targets = targets.cuda(gpu_device) outputs = swagger(imgs) loss_result = loss(input=outputs, target=targets) total_test_loss = total_test_loss + loss_result.item() preds = outputs.argmax(1) accuracy = (preds == targets).sum() total_accuracy = total_accuracy + accuracy.item() print(\"total test loss: {}\".format(total_test_loss)) print(\"total accuracy: {}\".format(total_accuracy / test_data_size)) writer.add_scalar(\"test_loss\", total_test_loss, total_test_step) writer.add_scalar(\"test_accuracy\", total_accuracy / test_data_size, total_test_step) total_test_step = total_test_step + 1 torch.save(swagger, \"../models/swagger_cifar_{}.pth\".format(i)) print(\"The model has been saved\") writer.close() ","date":"2022-05-11","objectID":"/pytorch_learning2/:3:0","tags":["Pytorch","深度学习"],"title":"pytorch学习2","uri":"/pytorch_learning2/"},{"categories":["pytorch"],"content":"卷机层的使用 ","date":"2022-05-11","objectID":"/pytorch_learning/:1:0","tags":["Pytorch","深度学习"],"title":"pytorch学习1","uri":"/pytorch_learning/"},{"categories":["pytorch"],"content":"准备数据集 定义自己的数据集：做必要的transform等 定义自己数据集的data、label dataset = torchvision.datasets.CIFAR10(\"../data_cifar10\", train=False, transform=torchvision.transforms.ToTensor(), download=False) ","date":"2022-05-11","objectID":"/pytorch_learning/:1:1","tags":["Pytorch","深度学习"],"title":"pytorch学习1","uri":"/pytorch_learning/"},{"categories":["pytorch"],"content":"根据数据集准备dataloader 输入batchsize， dataset等参数 dataloader = DataLoader(dataset=dataset, batch_size=64) ","date":"2022-05-11","objectID":"/pytorch_learning/:1:2","tags":["Pytorch","深度学习"],"title":"pytorch学习1","uri":"/pytorch_learning/"},{"categories":["pytorch"],"content":"定义自己的网络结构 继承父辈的init函数 定义自己的网络结构-卷积层：输入通道数、输出通道数、卷机核大小等参数 定义前向传播：依次前向顺序调用自己的各个层 class SwaggerConv(nn.Module): def __init__(self): super(SwaggerConv, self).__init__() self.conv1 = Conv2d(in_channels=3, out_channels=6, kernel_size=3, stride=1, padding=0) # 前向传播， 输入为x， 输出为y def forward(self, x): y = self.conv1(x) return y ","date":"2022-05-11","objectID":"/pytorch_learning/:1:3","tags":["Pytorch","深度学习"],"title":"pytorch学习1","uri":"/pytorch_learning/"},{"categories":["pytorch"],"content":"后续操作 实例化网络结构 通过dataloader 取数据 将取出的数据 输送入网络结构当中 前向传播得到输出 将输出写入到tensorboard日志当中 swagger = SwaggerConv() writer = SummaryWriter(\"../logs\") step = 0 for data in dataloader: imgs, targets = data output = swagger(imgs) # 原图写入到tensorboard当中 writer.add_images(\"input\", img_tensor=imgs, global_step=step) # 经过卷积之后的图像 # output为6通道，无法在tensorboard中以图片的格式显示， # 将其使用reshape 改成三通道（不严谨操作方式） output = torch.reshape(output, (-1, 3, 30, 30)) writer.add_images(\"output\", img_tensor=output, global_step=step) step = step + 1 writer.close() ","date":"2022-05-11","objectID":"/pytorch_learning/:1:4","tags":["Pytorch","深度学习"],"title":"pytorch学习1","uri":"/pytorch_learning/"},{"categories":["pytorch"],"content":"测试源码 # 卷积层的使用 torch.nn.Conv2d import torch import torchvision from torch.utils.data import DataLoader from torch import nn from torch.nn import Conv2d from torch.utils.tensorboard import SummaryWriter # 准备数据集 # 代码在src中， 把数据集下载到 \"../data\"， 也就是退到上一层目录， 新建一个目data # dataset = torchvision.datasets.CIFAR10(\"../data\", train=False, transform=torchvision.transforms.ToTensor(), # download=True) # 不下载该数据集download=False，数据集在本地的路径为../data_cifar10， dataset = torchvision.datasets.CIFAR10(\"../data_cifar10\", train=False, transform=torchvision.transforms.ToTensor(), download=False) # 将数据转换为tensor数据类型 一个batch为64 dataloader = DataLoader(dataset=dataset, batch_size=64) # 定义自己的网络结构， 输入通道为3， 输出通道为6（意味着有两个卷积核）， 卷积核的大小为3， 步长为1， 不增加padding class SwaggerConv(nn.Module): def __init__(self): super(SwaggerConv, self).__init__() self.conv1 = Conv2d(in_channels=3, out_channels=6, kernel_size=3, stride=1, padding=0) # 前向传播， 输入为x， 输出为y def forward(self, x): y = self.conv1(x) return y swagger = SwaggerConv() writer = SummaryWriter(\"../logs\") step = 0 for data in dataloader: imgs, targets = data output = swagger(imgs) # 原图写入到tensorboard当中 writer.add_images(\"input\", img_tensor=imgs, global_step=step) # 经过卷积之后的图像 # output为6通道，无法在tensorboard中以图片的格式显示， # 将其使用reshape 改成三通道（不严谨操作方式） output = torch.reshape(output, (-1, 3, 30, 30)) writer.add_images(\"output\", img_tensor=output, global_step=step) step = step + 1 writer.close() ","date":"2022-05-11","objectID":"/pytorch_learning/:1:5","tags":["Pytorch","深度学习"],"title":"pytorch学习1","uri":"/pytorch_learning/"},{"categories":["pytorch"],"content":"最大池化层使用 ","date":"2022-05-11","objectID":"/pytorch_learning/:2:0","tags":["Pytorch","深度学习"],"title":"pytorch学习1","uri":"/pytorch_learning/"},{"categories":["pytorch"],"content":"最大池化-取窗口中的最大值 MaxPool2d — 最大池化 （下采样） MaxUnPool2d — 最大池化 （上采样） ","date":"2022-05-11","objectID":"/pytorch_learning/:2:1","tags":["Pytorch","深度学习"],"title":"pytorch学习1","uri":"/pytorch_learning/"},{"categories":["pytorch"],"content":"参数使用 kernel_size：核 窗口大小 the size of the window to take a max over stride：步长 the stride of the window. Default value is kernel_size padding：边缘补零 implicit zero padding to be added on both sides dilation：核的数字之间是否紧密相连 a parameter that controls the stride of elements in the window ceil_mode：是使用ceil还是floor 模式进行计算 （ceil-》不足填充整个窗口丢弃） ","date":"2022-05-11","objectID":"/pytorch_learning/:2:2","tags":["Pytorch","深度学习"],"title":"pytorch学习1","uri":"/pytorch_learning/"},{"categories":["pytorch"],"content":"源码测试 # 最大池化层的使用 # 非线性激活的使用 # sigmoid 层 # relu 层 import torch import torchvision from torch.utils.data import DataLoader from torch import nn from torch.nn import Conv2d from torch.nn import MaxPool2d from torch.nn import ReLU from torch.nn import Sigmoid from torch.utils.tensorboard import SummaryWriter # 准备数据集 # 代码在src中， 把数据集下载到 \"../data\"， 也就是退到上一层目录， 新建一个目data dataset = torchvision.datasets.CIFAR10(\"../data\", train=False, transform=torchvision.transforms.ToTensor(), download=True) # 将数据转换为tensor数据类型 一个batch为64 dataloader = DataLoader(dataset=dataset, batch_size=64) # 定义自己的网络结构， 输入通道为3， 输出通道为6（意味着有两个卷积核）， 卷积核的大小为3， 步长为1， 不增加padding class SwaggerMaxPool(nn.Module): def __init__(self): super(SwaggerMaxPool, self).__init__() self.conv1 = Conv2d(in_channels=3, out_channels=6, kernel_size=3, stride=1, padding=0) self.maxpool1 = MaxPool2d(kernel_size=3, stride=3, padding=0) self.relu1 = ReLU() self.sigmoid1 = Sigmoid() # 前向传播， 输入为x， 输出为y def forward(self, x): # y = self.conv1(x) # y = self.maxpool1 # y = self.relu1(x) y = self.sigmoid1(x) return y swagger = SwaggerMaxPool() writer = SummaryWriter(\"../logs\") step = 0 for data in dataloader: imgs, targets = data output = swagger(imgs) # 原图写入到tensorboard当中 writer.add_images(\"input\", img_tensor=imgs, global_step=step) writer.add_images(\"output\", img_tensor=output, global_step=step) step = step + 1 writer.close() ","date":"2022-05-11","objectID":"/pytorch_learning/:2:3","tags":["Pytorch","深度学习"],"title":"pytorch学习1","uri":"/pytorch_learning/"},{"categories":["pytorch"],"content":"非线性激活 nn.ReLU 对非0数字进行截断，其中的参数inplace， 如果为TRUE，则对input 进行原地替换操作，默认为False，不进行原地操作。 nn.Sigmoid 使得模型能够使用各种非线性结构的特征，增强模型的泛化能力 ","date":"2022-05-11","objectID":"/pytorch_learning/:3:0","tags":["Pytorch","深度学习"],"title":"pytorch学习1","uri":"/pytorch_learning/"},{"categories":["pytorch"],"content":"线性层和及其他层 Normalization Layers：标准化层：映射到指定的区间，可以增加训练的速度 Recurrent Layers：文字识别网络结构 Transformer Layers：特定的网络结构（paper： attention is all you need） Dropout Layers：满足服从B-p分布的特性将输入中的数据随机置零—-\u003e防止过拟合（Efficient Object Localization Using Convolutional networks） Sparse Layers：自然语言处理（NLP）网络 Distance Functions：计算距离的函数 Loss Function：计算loss Linear Layers：线性层，全连接层 fully connected layers ","date":"2022-05-11","objectID":"/pytorch_learning/:4:0","tags":["Pytorch","深度学习"],"title":"pytorch学习1","uri":"/pytorch_learning/"},{"categories":["pytorch"],"content":"sequential和网络搭建实战 ","date":"2022-05-11","objectID":"/pytorch_learning/:5:0","tags":["Pytorch","深度学习"],"title":"pytorch学习1","uri":"/pytorch_learning/"},{"categories":["pytorch"],"content":"不使用sequential init 当中定义网络结构 forward当中按照顺序调用各层网络 ","date":"2022-05-11","objectID":"/pytorch_learning/:5:1","tags":["Pytorch","深度学习"],"title":"pytorch学习1","uri":"/pytorch_learning/"},{"categories":["pytorch"],"content":"使用sequential init 使用sequential定义model 在model中按照顺序添加网络结构 forward 中直接调用model ","date":"2022-05-11","objectID":"/pytorch_learning/:5:2","tags":["Pytorch","深度学习"],"title":"pytorch学习1","uri":"/pytorch_learning/"},{"categories":["pytorch"],"content":"测试网络是否正确小技巧 torch.ones / torch.zeros 生成input 输入到网络当中看是否出错 ","date":"2022-05-11","objectID":"/pytorch_learning/:5:3","tags":["Pytorch","深度学习"],"title":"pytorch学习1","uri":"/pytorch_learning/"},{"categories":["pytorch"],"content":"源码测试 import torch import torchvision from torch.nn import Flatten from torch.utils.data import DataLoader from torch import nn from torch.nn import Conv2d from torch.nn import MaxPool2d from torch.nn import ReLU from torch.nn import Sigmoid from torch.nn import Linear from torch.nn import Sequential from collections import OrderedDict from torch.utils.tensorboard import SummaryWriter # 准备数据集 # 代码在src中， 把数据集下载到 \"../data\"， 也就是退到上一层目录， 新建一个目data dataset = torchvision.datasets.CIFAR10(\"../data\", train=False, transform=torchvision.transforms.ToTensor(), download=True) # 将数据转换为tensor数据类型 一个batch为64 dataloader = DataLoader(dataset=dataset, batch_size=64) class SwaggerCifar(nn.Module): def __init__(self): super(SwaggerCifar, self).__init__() # self.conv1 = Conv2d(in_channels=3, out_channels=32, kernel_size=5, # stride=1, padding=2) # self.maxpool1 = MaxPool2d(kernel_size=2) # self.conv2 = Conv2d(in_channels=32, out_channels=32, kernel_size=5, # stride=1, padding=2) # self.maxpool2 = MaxPool2d(kernel_size=2) # self.conv3 = Conv2d(in_channels=32, out_channels=64, kernel_size=5, # stride=1, padding=2) # self.maxpool3 = MaxPool2d(kernel_size=2) # self.flatten = Flatten() # self.linear1 = Linear(in_features=1024, out_features=64) # self.linear2 = Linear(in_features=64, out_features=10) self.model1 = Sequential( Conv2d(in_channels=3, out_channels=32, kernel_size=5, stride=1, padding=2), MaxPool2d(kernel_size=2), Conv2d(in_channels=32, out_channels=32, kernel_size=5, stride=1, padding=2), MaxPool2d(kernel_size=2), Conv2d(in_channels=32, out_channels=64, kernel_size=5, stride=1, padding=2), MaxPool2d(kernel_size=2), Flatten(), Linear(in_features=1024, out_features=64), Linear(in_features=64, out_features=10) ) def forward(self, x): # x = self.conv1(x) # x = self.maxpool1(x) # x = self.conv2(x) # x = self.maxpool2(x) # x = self.conv3(x) # x = self.maxpool3(x) # x = self.flatten(x) # x = self.linear1(x) # x = self.linear2(x) x = self.model1(x) return x swagger = SwaggerCifar() # 使用torch的数字生成器简单检验网络的输入输出是否正确 input = torch.ones(64, 3, 32, 32) output = swagger(input) # print(output[0]) print(output.shape) print(swagger) # tensorboard 网络结构的可视化 writer = SummaryWriter(\"../logs\") writer.add_graph(swagger, input) writer.close() ","date":"2022-05-11","objectID":"/pytorch_learning/:5:4","tags":["Pytorch","深度学习"],"title":"pytorch学习1","uri":"/pytorch_learning/"},{"categories":["6D pose"],"content":"Object Localization的三种分类 object localization without classification：输出物体的区域 object detection：输出物体在图像中所处的bounding box、物体的类别 object instance segmentation：输出像素级或者点级别的目标物体区域、物体类别 ","date":"2022-05-01","objectID":"/6dpose_survey_2_object_localization/:1:0","tags":["6D Pose","Category level","Instance level","Object Localization"],"title":"6DPose—Object Localization总结","uri":"/6dpose_survey_2_object_localization/"},{"categories":["6D pose"],"content":"object localization without classification ","date":"2022-05-01","objectID":"/6dpose_survey_2_object_localization/:2:0","tags":["6D Pose","Category level","Instance level","Object Localization"],"title":"6DPose—Object Localization总结","uri":"/6dpose_survey_2_object_localization/"},{"categories":["6D pose"],"content":"Fitting 2D shape primitives 对目标物体进行轮廓提取 然后对基础形状原语进行拟合，从而得出目标物体的位置 ","date":"2022-05-01","objectID":"/6dpose_survey_2_object_localization/:2:1","tags":["6D Pose","Category level","Instance level","Object Localization"],"title":"6DPose—Object Localization总结","uri":"/6dpose_survey_2_object_localization/"},{"categories":["6D pose"],"content":"2D salient object detection 没有任何形状原语，对任意的形状的物体都可以进行拟合 深度学习方法：对原图进行特征提取之后，进行聚类或者回归 深度学习方法分类：MLP、Fully Connected Convolutional Network、Capsule Based Method 工业上物体多为固定形状的物体，所以多用形状拟合的方式进行识别，性能高，速度快 共融机器人抓取对于多用深度学习方法 ","date":"2022-05-01","objectID":"/6dpose_survey_2_object_localization/:2:2","tags":["6D Pose","Category level","Instance level","Object Localization"],"title":"6DPose—Object Localization总结","uri":"/6dpose_survey_2_object_localization/"},{"categories":["6D pose"],"content":"Fitting 3D shape primitives 对目标物体进行3D点云的轮廓提取 然后对基础形状原语进行拟合，提取得到物体的位置 ","date":"2022-05-01","objectID":"/6dpose_survey_2_object_localization/:2:3","tags":["6D Pose","Category level","Instance level","Object Localization"],"title":"6DPose—Object Localization总结","uri":"/6dpose_survey_2_object_localization/"},{"categories":["6D pose"],"content":"3D salient object detection ","date":"2022-05-01","objectID":"/6dpose_survey_2_object_localization/:2:4","tags":["6D Pose","Category level","Instance level","Object Localization"],"title":"6DPose—Object Localization总结","uri":"/6dpose_survey_2_object_localization/"},{"categories":["Java网络编程"],"content":"网络编程的必要条件 定位互联网上的一台主机 192.168.16.124:port 定位到计算机的某个资源 找到了这个主机，如果传输数据（UDP， TCP） ","date":"2022-04-09","objectID":"/java_net1/:1:0","tags":["Java","网络编程"],"title":"Java网络编程学习1","uri":"/java_net1/"},{"categories":["Java网络编程"],"content":"混淆概念 JavaWeb：网页编程 B/S TCP/IP：网络编程 C/S ","date":"2022-04-09","objectID":"/java_net1/:2:0","tags":["Java","网络编程"],"title":"Java网络编程学习1","uri":"/java_net1/"},{"categories":["Java网络编程"],"content":"网络通信的要素 ","date":"2022-04-09","objectID":"/java_net1/:3:0","tags":["Java","网络编程"],"title":"Java网络编程学习1","uri":"/java_net1/"},{"categories":["Java网络编程"],"content":"通信双方的地址 IP地址（唯一） 端口号 ","date":"2022-04-09","objectID":"/java_net1/:3:1","tags":["Java","网络编程"],"title":"Java网络编程学习1","uri":"/java_net1/"},{"categories":["Java网络编程"],"content":"规则，网络通信协议 HTTP：互联网网络通信协议（超文本传输协议） FTP：文件上传协议 SMTP: QQ邮件的发送 Telnet：远程登陆相关 DNS：域名解析 网络层的东西为封包使用 数据链路层有无线也有有线 ","date":"2022-04-09","objectID":"/java_net1/:3:2","tags":["Java","网络编程"],"title":"Java网络编程学习1","uri":"/java_net1/"},{"categories":["Java网络编程"],"content":"两个主要问题 如何主要定位到一个和几个主机 找到主机之后如何进行通信 ","date":"2022-04-09","objectID":"/java_net1/:3:3","tags":["Java","网络编程"],"title":"Java网络编程学习1","uri":"/java_net1/"},{"categories":["Java网络编程"],"content":"网络编程重的要素 IP和端口号—–IP 网络通信协议——UDP，TCP协议 ","date":"2022-04-09","objectID":"/java_net1/:3:4","tags":["Java","网络编程"],"title":"Java网络编程学习1","uri":"/java_net1/"},{"categories":["Java网络编程"],"content":"IP java.net.InetAddress 都是和网络编程相关的内容 唯一定位一台网络中的计算机 127.0.0.1 localhost 默认本机ip地址 IP地址分为广域网和局域网 IPv4：形如127.0.0.1，由四个字节组成，每个字节的范围为0-255，大概有42亿个，30亿都在北美，亚洲4亿。2011年就用尽了 IPv6：形如fe80::2852:63ff:fe79:8013%anpi0, 128 位，8个无符号整数 2001:0bb2:aaaa:0015:0000:0000:1aaa:1312 局域网：192.168.xx.xx IP地址四大分类：ABCD类 域名：IP地址是一串数字，难以记忆，所以可以通过申请域名的方式，得到www.vip.com此类的域名地址，方便记忆 ","date":"2022-04-09","objectID":"/java_net1/:4:0","tags":["Java","网络编程"],"title":"Java网络编程学习1","uri":"/java_net1/"},{"categories":["Java网络编程"],"content":"InetAddress 测试源码 package com.swagger.lesson01; import java.net.InetAddress; import java.net.UnknownHostException; // IP public class TestInetAddress { public static void main(String[] args) throws UnknownHostException { // 查询本机地址 // InetAddress 没有构造函数，不能被new出来，直接调用其中的静态方法即可 InetAddress inetAddress = InetAddress.getByName(\"127.0.0.1\"); InetAddress inetAddress_local = InetAddress.getByName(\"localhost\"); InetAddress local_name = InetAddress.getLocalHost(); System.out.println(inetAddress); System.out.println(inetAddress_local); System.out.println(local_name); // 查询域名的IP地址 InetAddress inetAddress2 = InetAddress.getByName(\"www.baidu.com\"); System.out.println(inetAddress2); // 常用方法 System.out.println(inetAddress2.getAddress()); // 地址 通常为一组 System.out.println(inetAddress2.getCanonicalHostName()); // 获取规范主机名 System.out.println(inetAddress2.getHostAddress()); // ip System.out.println(inetAddress2.getHostName()); // 获取域名，或者自己的主机名 } } ","date":"2022-04-09","objectID":"/java_net1/:4:1","tags":["Java","网络编程"],"title":"Java网络编程学习1","uri":"/java_net1/"},{"categories":["Java网络编程"],"content":"端口 port 不同的进程有不同的端口号，用来区分软件 被规定为0-65535 分为TCP和UDP端口号，总共有0-65535 * 2，单个协议下端口号不能冲突 ","date":"2022-04-09","objectID":"/java_net1/:5:0","tags":["Java","网络编程"],"title":"Java网络编程学习1","uri":"/java_net1/"},{"categories":["Java网络编程"],"content":"端口分类 公有端口 0-1023 HTTP：80 HTTPS：443 FTP：21 Telnet：23 程序注册端口 1014-49151 分配给用户或者程序的 Tomcat：8080 MySQL：3306 ORACLE：1521 动态、私有 49152 - 65535 IDEA HTML 默认端口：63342 常见的命令-MacOS 查看端口占用情况：netstat -AaLlnW 查看指定端口情况：lsof -i:80 ","date":"2022-04-09","objectID":"/java_net1/:5:1","tags":["Java","网络编程"],"title":"Java网络编程学习1","uri":"/java_net1/"},{"categories":["Java网络编程"],"content":"通信协议 统一的通信标准 TCP：传输控制协议 UDP：用户数据报协议 IP：网路互联协议，实际上 TCP/IP是一个协议簇 ","date":"2022-04-09","objectID":"/java_net1/:6:0","tags":["Java","网络编程"],"title":"Java网络编程学习1","uri":"/java_net1/"},{"categories":["Java网络编程"],"content":"TCP 实现聊天 ","date":"2022-04-09","objectID":"/java_net1/:7:0","tags":["Java","网络编程"],"title":"Java网络编程学习1","uri":"/java_net1/"},{"categories":["Java网络编程"],"content":"客户端 得到服务器的地址 创建一个Socket连接 通过IO流发送消息 package com.swagger.lesson02; import java.io.IOException; import java.io.OutputStream; import java.net.InetAddress; import java.net.Socket; import java.net.UnknownHostException; // 客户端 public class TCPClientDemo01 { public static void main(String[] args) { Socket socket = null; OutputStream os = null; try { // 1 得到服务器的地址 InetAddress serverIp = InetAddress.getByName(\"127.0.0.1\"); // 2 端口号 int port = 9999; // 3 创建一个socket 链接 socket = new Socket(serverIp, port); // 4 发送消息 IO流 os = socket.getOutputStream(); os.write(\"你好，欢迎学习javanet\".getBytes()); } catch (UnknownHostException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { if (os != null){ try { os.close(); } catch (IOException e) { e.printStackTrace(); } } if (socket != null){ try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } } } } ","date":"2022-04-09","objectID":"/java_net1/:7:1","tags":["Java","网络编程"],"title":"Java网络编程学习1","uri":"/java_net1/"},{"categories":["Java网络编程"],"content":"服务器 建立服务的端口 ServerSocket 等待用户连接过来 accept 读取客户端的消息 package com.swagger.lesson02; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.InputStream; import java.net.ServerSocket; import java.net.Socket; // 服务器段 public class TCPServerDemo01 { public static void main(String[] args) { ServerSocket serverSocket = null; Socket socket = null; InputStream is = null; ByteArrayOutputStream baos = null; try { // 1 有一个地址 serverSocket = new ServerSocket(9999); // 2 等待客户端链接过来 socket = serverSocket.accept(); // 这里即为得到的客户端socket // 3 读取客户端的消息 is = socket.getInputStream(); // 4 管道流, 将输入的is 进行管道过滤 baos = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len; while ((len = is.read(buffer)) != -1){ baos.write(buffer, 0, len); } System.out.println(baos.toString()); } catch (IOException e) { e.printStackTrace(); } finally { // 5 关闭资源 if (baos != null){ try { baos.close(); } catch (IOException e) { e.printStackTrace(); } } if (is != null){ try { is.close(); } catch (IOException e) { e.printStackTrace(); } } if (socket != null){ try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } if (serverSocket != null){ try { serverSocket.close(); } catch (IOException e) { e.printStackTrace(); } } } } } ","date":"2022-04-09","objectID":"/java_net1/:7:2","tags":["Java","网络编程"],"title":"Java网络编程学习1","uri":"/java_net1/"},{"categories":["Java多线程学习"],"content":"同步方法和同步块 同步方法：public synchronized void method(int args){} 使用synchronized方法控制对对象的访问 每个对象都有一把锁，synchronized方法必须要获得对象的锁才能够执行，否则线程阻塞 一旦得到该对象锁，同步方法才开始执行，直到方法返回才释放锁，后面阻塞的线程才能获得这个锁，继续执行 ","date":"2022-04-08","objectID":"/java_threads_learning4/:1:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"同步方法的弊端 缺陷：如果将一个大的方法声明为synchronized 将会影响效率 方法里面需要写的部分才需要加锁，读不用加锁，锁太多会浪费资源 ","date":"2022-04-08","objectID":"/java_threads_learning4/:1:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"同步块 同步块synchronized(Obj){} Obj为同步监视器，Obj可以是任何对象，推荐使用共享资源作为同步监视器 同步方法中无需指定监视器，因为监视器就是this，这个对象本身 同步监视器的执行过程 第一个线程访问，锁定同步监视器，执行其中代码 第二个线程访问，发现同步监视器被锁定，无法访问 第一个线程访问完毕，解锁同步监视器 第二个线程访问，发现同步监视器没有锁，然后锁定之后进行访问 ","date":"2022-04-08","objectID":"/java_threads_learning4/:1:2","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"具体实现（同步方法）–安全地买票 package MultiThread_learning.syncron; public class SafeBuyTicket { public static void main(String[] args) { SafeBuy safeBuy = new SafeBuy(); new Thread(safeBuy, \"swagger\").start(); new Thread(safeBuy, \"psyche\").start(); new Thread(safeBuy, \"dad\").start(); } } class SafeBuy implements Runnable{ // 票 private int ticketNums = 10; boolean flag = true; @Override public void run() { // 买票操作 while(flag){ buy(); } } private synchronized void buy(){ // 判断是否有票 if (ticketNums \u003c= 0){ flag = false; return; } // 模拟延时 try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } // 买票 System.out.println(Thread.currentThread().getName() + \"拿到票\" + ticketNums--); } } 将买票这个方法加上synchronized 修饰符之后就变成了同步方法 ","date":"2022-04-08","objectID":"/java_threads_learning4/:1:3","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"具体实现（同步代码块） —安全地取钱 package MultiThread_learning.syncron; public class SafeBank { public static void main(String[] args) { SafeAccount safeAccount = new SafeAccount(100, \"结婚基金\"); SafeWithdraw swagger = new SafeWithdraw(safeAccount, 50, \"swagger\"); SafeWithdraw psyche = new SafeWithdraw(safeAccount, 100, \"psyche\"); swagger.start(); psyche.start(); } } // 账户 class SafeAccount{ int money; String name; SafeAccount(int money, String name) { this.money = money; this.name = name; } } // 银行：模拟取钱 class SafeWithdraw extends Thread{ SafeAccount safeAccount; int withdrawNums; int nowMoney; public SafeWithdraw(SafeAccount safeAccount, int withdrawNums, String name){ super(name); this.safeAccount = safeAccount; this.withdrawNums = withdrawNums; this.nowMoney = 0; } @Override public void run() { synchronized (safeAccount){ if(safeAccount.money - withdrawNums \u003c 0){ System.out.println(Thread.currentThread().getName() + \"要取钱，\" + \"基金钱不够，取不了了\"); return; } // 延时，放大问题发生性 try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } safeAccount.money = safeAccount.money - withdrawNums; nowMoney = nowMoney + withdrawNums; System.out.println(safeAccount.name + \"账户余额为\" + this.safeAccount.money); System.out.println(Thread.currentThread().getName() + \"手里的钱为\" + this.nowMoney); } } } 代码块中地加锁参数只要为多个线程需要增删改地对象即可 这里结婚基金为多个线程修改，所以需要在run方法中加锁 ","date":"2022-04-08","objectID":"/java_threads_learning4/:1:4","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"具体实现（同步代码块） —安全的集合 package MultiThread_learning.syncron; import java.util.ArrayList; import java.util.List; public class SafeList { public static void main(String[] args) { List\u003cString\u003e list = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c 10000; i++) { new Thread(()-\u003e{ synchronized (list){ list.add(Thread.currentThread().getName()); } }).start(); } System.out.println(list.size()); } } list被多个线程同时修改 对list进行加锁，就不会出问题 ","date":"2022-04-08","objectID":"/java_threads_learning4/:1:5","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"JUC（Java Util Concurrent） Java 并发包 此包里的类都是线程安全的，不用再使用synchronized package MultiThread_learning.syncron; import java.util.concurrent.CopyOnWriteArrayList; public class TestJUC { public static void main(String[] args) throws InterruptedException { CopyOnWriteArrayList\u003cString\u003e list = new CopyOnWriteArrayList\u003c\u003e(); for (int i = 0; i \u003c 10000; i++) { new Thread(()-\u003e{ list.add(Thread.currentThread().getName()); }).start(); } Thread.sleep(3000); System.out.println(list.size()); } } ","date":"2022-04-08","objectID":"/java_threads_learning4/:2:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"死锁 两个活着多个线程都在等待对方释放资源 具体来说：一个同步块同时拥有两个以上的对象锁，就有可能发生死锁 ","date":"2022-04-08","objectID":"/java_threads_learning4/:3:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"产生死锁的四个条件 互斥：一个资源每次只能被一个线程使用 请求与保持：一个进程因请求资源而阻塞时，对已获得的资源保持不放 不剥夺：线程已获得的资源，在未使用完之前，不能强行剥夺 循环等待条件：若干进行之间形成一种头尾相接的循环等待资源关系 ","date":"2022-04-08","objectID":"/java_threads_learning4/:3:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"具体实现，产生死锁 package MultiThread_learning.syncron; // 多个线程互相抱着对方的资源，形成僵持 public class DeadLock { public static void main(String[] args) { MakeUp makeUp1 = new MakeUp(0, \"swagger\"); MakeUp makeUp2 = new MakeUp(1, \"psyche\"); makeUp1.start(); makeUp2.start(); } } class Lipstick{ } class Mirror{ } class MakeUp extends Thread{ // 需要只有一份的资源 static Lipstick lipstick = new Lipstick(); static Mirror mirror = new Mirror(); int choice; String girlName; MakeUp(int choice, String girlName){ this.choice = choice; this.girlName = girlName; } @Override public void run() { super.run(); try { makeup(); } catch (InterruptedException e) { e.printStackTrace(); } } private void makeup () throws InterruptedException { if (choice == 0){ synchronized (lipstick){ System.out.println(this.girlName + \"get lipstick's lock\"); Thread.sleep(1000); synchronized (mirror){ System.out.println(this.girlName + \"get mirror's lock\"); } } }else { synchronized (mirror){ System.out.println(this.girlName + \"get mirror's lock\"); Thread.sleep(2000); synchronized (lipstick){ System.out.println(this.girlName + \"get lipstick's lock\"); } } } } } 产生死锁，程序停不下来 互相想要得到对方资源的锁 但是不放开自己手中资源的锁 ","date":"2022-04-08","objectID":"/java_threads_learning4/:3:2","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"具体实现，解开死锁 package MultiThread_learning.syncron; // 多个线程互相抱着对方的资源，形成僵持 public class DeadLock { public static void main(String[] args) { MakeUp makeUp1 = new MakeUp(0, \"swagger\"); MakeUp makeUp2 = new MakeUp(1, \"psyche\"); makeUp1.start(); makeUp2.start(); } } class Lipstick{ } class Mirror{ } class MakeUp extends Thread{ // 需要只有一份的资源 static Lipstick lipstick = new Lipstick(); static Mirror mirror = new Mirror(); int choice; String girlName; MakeUp(int choice, String girlName){ this.choice = choice; this.girlName = girlName; } @Override public void run() { super.run(); try { makeup(); } catch (InterruptedException e) { e.printStackTrace(); } } private void makeup () throws InterruptedException { if (choice == 0){ synchronized (lipstick){ System.out.println(this.girlName + \"get lipstick's lock\"); Thread.sleep(1000); } synchronized (mirror){ System.out.println(this.girlName + \"get mirror's lock\"); } }else { synchronized (mirror){ System.out.println(this.girlName + \"get mirror's lock\"); Thread.sleep(2000); } synchronized (lipstick){ System.out.println(this.girlName + \"get lipstick's lock\"); } } } } 解开死锁 获取对方资源的锁之前，放开手中持有资源的锁 ","date":"2022-04-08","objectID":"/java_threads_learning4/:3:3","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"Lock（锁） 显式定义同步锁 JUC包下的内容 java.util.concurrent.locks Lock对象开始访问共享资源之前应先活着Lock对象 ReentrantLock类实现了Lock，他拥有和synchronized相同的并发性和内存语义 在实现线程安全控制中，比较常用的是ReentrantLock，可以显式地加锁和释放锁 如果有异常，需要将解锁放入到finally之中 ","date":"2022-04-08","objectID":"/java_threads_learning4/:4:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"lock和synchronized 的区别 lock 是显示锁（手动开启和关闭）；synchronized是隐式锁，出了作用域自动关闭 Lock 只能锁代码块，synchronized既可以锁方法，也可以锁代码块 使用Lock，JVM将花费较少的时间来调度线程，性能更好，并且扩展性更好 优先使用顺序：Lock \u003e 同步代码块（已经进入了方法体，非配了相应资源）\u003e 同步方法（在方法体之外） ","date":"2022-04-08","objectID":"/java_threads_learning4/:4:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"具体实现 package MultiThread_learning.SeniorMethod; import java.util.concurrent.locks.ReentrantLock; // 测试Lock锁 public class TestLock { public static void main(String[] args) { TestLock2 testLock2 = new TestLock2(); new Thread(testLock2).start(); new Thread(testLock2).start(); new Thread(testLock2).start(); } } class TestLock2 implements Runnable{ int ticketNums = 10; // 定义Lock锁 private final ReentrantLock lock = new ReentrantLock(); @Override public void run() { while (true){ try { // 加锁 lock.lock(); if(ticketNums \u003e 0){ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(ticketNums--); }else { break; } }finally { // 解锁 // 如果有异常，需要将解锁放入到finally之中 lock.unlock(); } } } } ","date":"2022-04-08","objectID":"/java_threads_learning4/:4:2","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"线程通信 ","date":"2022-04-08","objectID":"/java_threads_learning4/:5:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"生产者消费者问题 仓库只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将仓库中的产品取走消费 对于生产者，如果仓库中没有产品，则生产者将产品放入仓库，如果仓库中已经有产品，生产者停止生产，直到产品被消费者取走为止 对于消费者，仓库中如果放有产品，消费者可以将产品取走，否则停止消费并等待，直到仓库中有产品为止 生产者消费者问题之中synchronized是不够的，只能加锁，但是无法实现通信 ","date":"2022-04-08","objectID":"/java_threads_learning4/:5:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"Java 线程通信问题的方法 注意：局势Object类的方法，都只能在同步方法和同步代码块中使用，否则会抛出IllegalMonitorStateException异常 ","date":"2022-04-08","objectID":"/java_threads_learning4/:5:2","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"通信解决方式1-管程法 设置一个缓冲区 ","date":"2022-04-08","objectID":"/java_threads_learning4/:6:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"具体实现 package MultiThread_learning.SeniorMethod; /** * @author swaggerwei * @version 1.0 * @since 1.8 */ // 测试：生产者消费者问题 利用缓冲区（管程法） public class TestPandC { public static void main(String[] args) { SynContainer container = new SynContainer(); new Producer(container).start(); new Consumer(container).start(); } } // 生产者 class Producer extends Thread{ SynContainer container; public Producer(SynContainer container){ this.container = container; } @Override public void run() { super.run(); for (int i = 0; i \u003c 100; i++) { try { container.push(new Chicken(i)); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"生产了\" + i + \"只鸡\"); } } } // 消费者 class Consumer extends Thread{ SynContainer container; public Consumer(SynContainer container){ this.container = container; } @Override public void run() { super.run(); for (int i = 0; i \u003c 100; i++) { try { System.out.println(\"消费了\" + container.pop().id + \"只鸡\"); } catch (InterruptedException e) { e.printStackTrace(); } } } } // 产品 class Chicken{ int id;// 产品编号 public Chicken(int id) { this.id = id; } } // 缓冲区 class SynContainer{ // 容器大小 Chicken[] chickens = new Chicken[10]; // 容器计数器 int count = 0; // 生产者上货 public synchronized void push(Chicken chicken) throws InterruptedException { // 如果容器满了，就要等待消费者消费 if(count == chickens.length){ // 通知消费者消费，生产等待 this.wait(); } // 如果没有满，就要上货 chickens[count] = chicken; count++; // 可以通知消费这消费了 this.notifyAll(); } // 消费者消费产品 public synchronized Chicken pop() throws InterruptedException { // 判断是否可以消费 if(count == 0){ this.wait(); // 等待生产者生产，消费者等待 } // 如果可以消费 count--; Chicken chicken = chickens[count]; // 通知生产者开始上货 this.notifyAll(); return chicken; } } ","date":"2022-04-08","objectID":"/java_threads_learning4/:6:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"通信解决方式2-信号灯法 设置一个标志位 ","date":"2022-04-08","objectID":"/java_threads_learning4/:7:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"具体实现 package MultiThread_learning.SeniorMethod; /** * @author swaggerwei * @since 1.8 */ // 生产者消费者问题 // 信号灯法解决 public class TestPandC2 { public static void main(String[] args) { TV tv = new TV(); new Player(tv).start(); new Audience(tv).start(); } } // 生产者---演员 class Player extends Thread{ TV tv; public Player(TV tv){ this.tv = tv; } @Override public void run() { for (int i = 0; i \u003c 20; i++) { if (i%2 == 0){ try { this.tv.play(\"甄嬛传\"); } catch (InterruptedException e) { e.printStackTrace(); } }else { try { this.tv.play(\"天下足球\"); } catch (InterruptedException e) { e.printStackTrace(); } } } } } // 消费者---观众 class Audience extends Thread{ TV tv; public Audience(TV tv){ this.tv = tv; } @Override public void run() { for (int i = 0; i \u003c 20; i++) { try { tv.watch(); } catch (InterruptedException e) { e.printStackTrace(); } } } } // 产品---节目 class TV{ // 演员表演，观众等待 // 观众观看，演员等待 String voice;//表演节目 boolean flag = true; // 表演 public synchronized void play(String voice) throws InterruptedException { if (!flag){ this.wait(); } System.out.println(\"演员表演了节目：\" + voice); // 通知观众观看 this.voice = voice; this.notifyAll(); this.flag = !this.flag; } // 观看 public synchronized void watch() throws InterruptedException { if(flag){ this.wait(); } System.out.println(\"观众观看了\" + voice); // 通知演员表演 notifyAll(); this.flag = !this.flag; } } ","date":"2022-04-08","objectID":"/java_threads_learning4/:7:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"线程池 经常创建和销毁线程非常浪费资源，对性能影响很大 提前创建好多个线程池，使用时直接获取，使用完放回池中 优点：提高了相应速度 优点：降低了资源消耗，重复利用线程池中线程，不需要重复创建 便于线程管理：corePoolSize核心池大小, maximumPoolSize最大线程数，keepAliveTime线程没有任务时最多保持多长时间后终止 ","date":"2022-04-08","objectID":"/java_threads_learning4/:8:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"具体使用 JDK5 开始提供线程池相关的API：ExecutorService 和 Executors ExecutorService为真正的线程池接口，常见的子类ThreadPoolExecutor Executors为工具类，线程池的工厂类，用于创建并返回不同类型的线程池 ","date":"2022-04-08","objectID":"/java_threads_learning4/:8:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"具体实现 package MultiThread_learning.SeniorMethod; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.ForkJoinPool; /** * @author swaggerwei * @since 1.8 * @version 1.0 */ // 测试线程池 public class TestPool { public static void main(String[] args) { // 1 创建线程池, 参数为线程池的大小（线程的数目） ExecutorService service = Executors.newFixedThreadPool(10); service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); // 关闭链接 service.shutdown(); } } class MyThread implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()); } } ","date":"2022-04-08","objectID":"/java_threads_learning4/:8:2","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"线程强制执行 Join合并线程，此线程执行完成后再执行其他线程，其他线程阻塞 可以想像成插队 线程中尽量少使用次方法，会让其他线程陷入阻塞 ","date":"2022-04-06","objectID":"/java_threads_learning3/:1:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习3","uri":"/java_threads_learning3/"},{"categories":["Java多线程学习"],"content":"具体实现 package MultiThread_learning; // 测试join方法,想象为插队 public class TestJoin implements Runnable{ @Override public void run() { for (int i = 0; i \u003c 500; i++) { System.out.println(\"线程VIP来了\" + i); } } public static void main(String[] args) { // 启动线程 TestJoin testJoin = new TestJoin(); Thread thread = new Thread(testJoin); thread.start(); // 主线程 for (int i = 0; i \u003c 500; i++) { if (i == 200){ try { thread.join(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"main\" + i); } } } ","date":"2022-04-06","objectID":"/java_threads_learning3/:1:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习3","uri":"/java_threads_learning3/"},{"categories":["Java多线程学习"],"content":"线程状态观测（Thread.State） NEW：尚未启动的线程 RUNNABLE：在执行中的线程 BLOCKED：被阻塞等待监视器锁定的线程处于次状态 WAITING：正在等待另一个线程执行特定动作的线程处于次状态 TIMED_WAITING：正在等待另一个线程执行动作达到到指定等待时间的线程处于次状态 TERMINATED：已退出的线程 ","date":"2022-04-06","objectID":"/java_threads_learning3/:2:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习3","uri":"/java_threads_learning3/"},{"categories":["Java多线程学习"],"content":"观测线程状态具体实现 package MultiThread_learning; // 观察线程状态 public class TestState { public static void main(String[] args) throws InterruptedException { Thread thread = new Thread(()-\u003e{ for (int i = 0; i \u003c 5; i++) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"////////\"); }); // 观察线程状态 NEW Thread.State state = thread.getState(); System.out.println(state.toString()); // 观察线程启动后状态 RUNNABLE thread.start(); state = thread.getState(); System.out.println(state.toString()); while (state != Thread.State.TERMINATED){// 只要线程不终止，就一直出状态 Thread.sleep(100); state = thread.getState();//更新线程状态 System.out.println(state.toString()); } } } 线程在死亡之后无法在启动 ","date":"2022-04-06","objectID":"/java_threads_learning3/:2:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习3","uri":"/java_threads_learning3/"},{"categories":["Java多线程学习"],"content":"线程优先级 Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行 线程的优先级用数字表示，范围从1～10 Thread.MIN_PRIORITY = 1 Thread.MAX_PRIORITY = 10 Thread.NORM_PRIORITY = 5 获取优先级：getPriority() 修改优先级：setPriority() 需要先设置优先级，再启动 ","date":"2022-04-06","objectID":"/java_threads_learning3/:3:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习3","uri":"/java_threads_learning3/"},{"categories":["Java多线程学习"],"content":"具体实现 package MultiThread_learning; // 测试线程优先级 public class TestPriority { public static void main(String[] args) { // 主线程优先级 System.out.println(Thread.currentThread().getName() + \"---\u003e\" + Thread.currentThread().getPriority()); MyPriority myPriority = new MyPriority(); Thread thread1 = new Thread(myPriority); Thread thread2 = new Thread(myPriority); Thread thread3 = new Thread(myPriority); Thread thread4 = new Thread(myPriority); Thread thread5 = new Thread(myPriority); Thread thread6 = new Thread(myPriority); // 设置优先级 thread1.start(); thread2.setPriority(1); thread2.start(); thread3.setPriority(4); thread3.start(); thread4.setPriority(Thread.MAX_PRIORITY); thread4.start(); thread5.setPriority(2); thread5.start(); thread6.setPriority(8); thread6.start(); } } class MyPriority implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName() + \"---\u003e\" + Thread.currentThread().getPriority()); } } 实际上优先级高的不一定先跑 最终的执行还是看CPU调度器的心情 可能CPU会执行优先级低的线程（性能倒置） ","date":"2022-04-06","objectID":"/java_threads_learning3/:3:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习3","uri":"/java_threads_learning3/"},{"categories":["Java多线程学习"],"content":"守护（daemon）线程 线程分为用户线程和守护线程 虚拟机必须确保用户线程执行完毕 虚拟机不用等待守护线程执行完毕 如：后台记录操作日志，监控内存，垃圾回收等待 守护线程参数默认为false 表示为用户线程，正常线程都为用户线程 thread.setDaemon(true); // 默认为false 表示为用户线程，正常线程都为用户线程 ","date":"2022-04-06","objectID":"/java_threads_learning3/:4:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习3","uri":"/java_threads_learning3/"},{"categories":["Java多线程学习"],"content":"线程同步机制（并发） 多个线程操作同一个资源 并发，多个线程在同一时刻操作同一个对象 实际上线程同步就是一种等待机制，多个同时需要访问一个对象的线程需要进入对象等待池形成队列，等待前面的线程使用完毕，下一个再使用 一个线程在使用数据对象时需要对对象进行加锁，防止其他线程进入篡改 每个对象都有一把锁，sleep不会释放锁，所以其他的线程依旧无法使用此对象 ","date":"2022-04-06","objectID":"/java_threads_learning3/:5:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习3","uri":"/java_threads_learning3/"},{"categories":["Java多线程学习"],"content":"锁机制 访问时加入锁机制synchronized 当一个线程获得了对象的排他锁，独占资源，其他线程必须等待，使用后释放锁即可 ","date":"2022-04-06","objectID":"/java_threads_learning3/:5:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习3","uri":"/java_threads_learning3/"},{"categories":["Java多线程学习"],"content":"锁机制带来的问题 一个线程持有锁会导致其他所有需要此锁的线程挂起 多线程竞争时，加锁个释放锁会导致比较多的上下文切换和调度延时，引起性能问题 如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题 ","date":"2022-04-06","objectID":"/java_threads_learning3/:5:2","tags":["Java","Thread","多线程"],"title":"Java多线程学习3","uri":"/java_threads_learning3/"},{"categories":["Java多线程学习"],"content":"不安全案例1 package MultiThread_learning.syncron; // 线程不安全，出现负数 // 不安全的买票 public class UnSafeBuyTicket { public static void main(String[] args) { BuyTicket buyTicket = new BuyTicket(); new Thread(buyTicket, \"swagger\").start(); new Thread(buyTicket, \"psyche\").start(); new Thread(buyTicket, \"dad\").start(); } } class BuyTicket implements Runnable{ // 票 private int ticketNums = 10; boolean flag = true; @Override public void run() { // 买票操作 while(flag){ buy(); } } private void buy(){ // 判断是否有票 if (ticketNums \u003c 0){ flag = false; return; } // 模拟延时 try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } // 买票 System.out.println(Thread.currentThread().getName() + \"拿到票\" + ticketNums--); } } 每个线程都有自己的CPU内工作内存，不加锁会造成票数为负数的情况 ","date":"2022-04-06","objectID":"/java_threads_learning3/:5:3","tags":["Java","Thread","多线程"],"title":"Java多线程学习3","uri":"/java_threads_learning3/"},{"categories":["Java多线程学习"],"content":"不安全案例2 package MultiThread_learning.syncron; // 不安全的取钱 // 两个人去银行取钱，账户出问题 public class UnsafeBank { public static void main(String[] args) { Account account = new Account(100, \"基金\"); Withdrawing swagger = new Withdrawing(account, 50, \"swagger\"); Withdrawing psyche = new Withdrawing(account, 100, \"psyche\"); swagger.start(); psyche.start(); } } // 账户 class Account{ int money; String name; Account(int money, String name) { this.money = money; this.name = name; } } // 银行：模拟取款 class Withdrawing extends Thread{ Account account; int withdrawNums; int nowMoney; public Withdrawing(Account account, int WithdrawNums, String name){ super(name); this.account = account; this.withdrawNums = WithdrawNums; this.nowMoney = 0; } @Override public void run() { if (account.money - withdrawNums \u003c 0){ System.out.println(Thread.currentThread().getName() + \"要取钱，\" + \"基金钱不够，取不了了\"); return; } // 延时，放大问题发生性 try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } account.money = account.money - withdrawNums; nowMoney = nowMoney + withdrawNums; System.out.println(account.name + \"账户余额为\" + this.account.money); System.out.println(Thread.currentThread().getName() + \"手里的钱为\" + this.nowMoney); } } ","date":"2022-04-06","objectID":"/java_threads_learning3/:5:4","tags":["Java","Thread","多线程"],"title":"Java多线程学习3","uri":"/java_threads_learning3/"},{"categories":["Java多线程学习"],"content":"线程不安全集合 package MultiThread_learning.syncron; import java.util.ArrayList; import java.util.List; // 线程不安全的集合 public class UnsafeList { public static void main(String[] args) { List\u003cString\u003e strings = new ArrayList\u003cString\u003e(); // 创建10000个线程, 加入到数组当中 for (int i = 0; i \u003c 10000; i++) { new Thread(()-\u003e{ strings.add(Thread.currentThread().getName()); }).start(); } // 最后的数组size和线程数量不一致 System.out.println(strings.size()); } } 数组为线程不安全的 说明有线程在同一瞬间操作了同一个地址，导致最后数组size和线程数量不一致 ","date":"2022-04-06","objectID":"/java_threads_learning3/:5:5","tags":["Java","Thread","多线程"],"title":"Java多线程学习3","uri":"/java_threads_learning3/"},{"categories":["Java多线程学习"],"content":"静态代理模式 真实对象和代理对象都要实现同一个接口 代理对象要代理真实角色 优点，代理对象无法做很多真实对象无法做的事，真实对象可以专注于自己的事情 实际上Thread实现了Runnable接口，对线程实现代理 ","date":"2022-04-05","objectID":"/java_threads_learning2/:1:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习2","uri":"/java_threads_learning2/"},{"categories":["Java多线程学习"],"content":"婚庆公司代理结婚 package MultiThread_learning; public class TestStaticProxy { public static void main(String[] args) { you swagger = new you(); WeddingCompany weddingCompany = new WeddingCompany(swagger); weddingCompany.HappyMarry(); } } interface Marry{ void HappyMarry(); } // 真实角色，实现接口（新郎本人） class you implements Marry{ @Override public void HappyMarry() { System.out.println(\"swagger is going to marry\"); } } // 代理角色，代理实现接口（婚庆公司） class WeddingCompany implements Marry{ private Marry target; WeddingCompany(Marry target) { this.target = target; } @Override public void HappyMarry() { before(); this.target.HappyMarry(); after(); } private void after() { System.out.println(\"pay money\"); } private void before() { System.out.println(\"prepare the wedding procedure\"); } } 婚庆公司代理新郎结婚 新郎可以专注于自己的事情 new Thread(()-\u003e System.out.println(\"I love you\")).start(); new WeddingCompany(new you()).HappyMarry(); 如上述代码，Thread代理输出I love you进行执行start()方法 ","date":"2022-04-05","objectID":"/java_threads_learning2/:1:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习2","uri":"/java_threads_learning2/"},{"categories":["Java多线程学习"],"content":"Lambda表达式 JDK8才出现 lambda 表达式只有实现接口部分代码的核心只有一句话是才能简化成一行，如果有多行，则需要花括号进行代码快包裹 前提是为函数式接口 多个参数也可以去掉参数类型，只能同时都去掉，活着同时都不去掉，必须加上括号 new Thread(()-\u003e System.out.println(\"I love you\")).start(); ","date":"2022-04-05","objectID":"/java_threads_learning2/:2:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习2","uri":"/java_threads_learning2/"},{"categories":["Java多线程学习"],"content":"使用lambda表达式的原因 避免匿名内部类的定义过多 使代码更简介 去掉没有意义的代码，只留下核心逻辑 ","date":"2022-04-05","objectID":"/java_threads_learning2/:2:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习2","uri":"/java_threads_learning2/"},{"categories":["Java多线程学习"],"content":"函数接口定义 任何接口，如果只包含唯一一个抽象方法，那么他就是一个函数式接口 函数式接口，可以通过lambda表达式创建该接口， ","date":"2022-04-05","objectID":"/java_threads_learning2/:2:2","tags":["Java","Thread","多线程"],"title":"Java多线程学习2","uri":"/java_threads_learning2/"},{"categories":["Java多线程学习"],"content":"具体实现1 package MultiThread_learning; // 推导lambda表达式 public class TestLambda { //3 静态内部类 static class Like2 implements ILike{ @Override public void lambda() { System.out.println(\"i like lambda2\"); } } public static void main(String[] args) { // 声明一个接口，使用实现类Like来new ILike like = new Like(); like.lambda(); // 静态内部类 like = new Like2(); like.lambda(); // 4 局部内部类 class Like3 implements ILike{ @Override public void lambda() { System.out.println(\"i like lambda3\"); } } like = new Like3(); like.lambda(); // 5 匿名内部类 like = new ILike() { @Override public void lambda() { System.out.println(\"i like lambda4\"); } }; like.lambda(); // 6 用lambda表达式简化 like = ()-\u003e{ System.out.println(\"i like lambda5\"); }; like.lambda(); } } // 1 定一个函数式接口 interface ILike{ void lambda(); } // 2 定义一个实现类 class Like implements ILike{ @Override public void lambda() { System.out.println(\"i like lambda\"); } } ","date":"2022-04-05","objectID":"/java_threads_learning2/:2:3","tags":["Java","Thread","多线程"],"title":"Java多线程学习2","uri":"/java_threads_learning2/"},{"categories":["Java多线程学习"],"content":"具体实现2 package MultiThread_learning; public class TestLambda2 { public static void main(String[] args) { // 原版lambda 表达式 Ilove love = (int a)-\u003e { System.out.println(\"i love you\" + \" \" + a + 1); }; // 简化1：省略参数类型 love = (a)-\u003e{ System.out.println(\"i love you\" + \" \" + a + 2); }; // 简化2：简化花括号 love = a -\u003e { System.out.println(\"i love you\" + \" \" + a + 3); }; // 简化3：去掉花括号 love = a -\u003e System.out.println(\"i love you\" + \" \" + a + 4); love.love(1); } } interface Ilove { void love(int a); } ","date":"2022-04-05","objectID":"/java_threads_learning2/:2:4","tags":["Java","Thread","多线程"],"title":"Java多线程学习2","uri":"/java_threads_learning2/"},{"categories":["Java多线程学习"],"content":"线程的五大状态 具体内容如下 ","date":"2022-04-05","objectID":"/java_threads_learning2/:3:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习2","uri":"/java_threads_learning2/"},{"categories":["Java多线程学习"],"content":"线程方法 ","date":"2022-04-05","objectID":"/java_threads_learning2/:4:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习2","uri":"/java_threads_learning2/"},{"categories":["Java多线程学习"],"content":"停止线程 不推荐使用JDK提供的stop()，destroy()方法，已经废弃了 推荐线程自己停下来，利用次数，不建议死循环 建议使用一个标志位进行终止变量，比如当flag=false时，终止线程运行 ","date":"2022-04-05","objectID":"/java_threads_learning2/:5:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习2","uri":"/java_threads_learning2/"},{"categories":["Java多线程学习"],"content":"具体实现 package MultiThread_learning; public class TestStop implements Runnable{ // 1 设置一个标志位 private boolean flag = true; @Override public void run() { int i = 0; while (flag){ System.out.println(\"run.....Thread\" + i++); } } // 2 设置一个公开的方法停止线程，转换标志位，方法为自己定义 public void mystop(){ this.flag = false; } public static void main(String[] args) { TestStop testStop = new TestStop(); new Thread(testStop).start(); for (int i = 0; i \u003c 1000; i++) { System.out.println(\"main\" + i); if (i == 900){ testStop.mystop(); System.out.println(\"线程停止了\"); } } } } ","date":"2022-04-05","objectID":"/java_threads_learning2/:5:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习2","uri":"/java_threads_learning2/"},{"categories":["Java多线程学习"],"content":"线程休眠 sleep(时间毫秒) sleep存在异常InterruptedException sleep时间到达后线程进入就绪状态，等待CPU调度 sleep可以模拟网络延迟，倒计时等 每一个对象都有一个锁，sleep不会释放锁 ","date":"2022-04-05","objectID":"/java_threads_learning2/:6:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习2","uri":"/java_threads_learning2/"},{"categories":["Java多线程学习"],"content":"具体实现1 模拟网络延迟：放大线程的发生性 package MultiThread_learning; public class TestSleep implements Runnable{ private int ticketNums = 10; @Override public void run() { while (true){ if(ticketNums \u003c=0){ break; } // 模拟延时 try { Thread.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } // 买票 System.out.println(Thread.currentThread().getName() + \"拿到了第\" + ticketNums-- + \"票\"); } } public static void main(String[] args) { TestSleep testSleep = new TestSleep(); new Thread(testSleep, \"小明\").start(); new Thread(testSleep, \"老师\").start(); new Thread(testSleep, \"黄牛党\").start(); } } ","date":"2022-04-05","objectID":"/java_threads_learning2/:6:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习2","uri":"/java_threads_learning2/"},{"categories":["Java多线程学习"],"content":"具体实现2 模拟倒计时 package MultiThread_learning; // 模拟倒计时 public class TestSleep2 { public static void main(String[] args) { // 主线程 main的倒计时 try { tenDown(); } catch (InterruptedException e) { e.printStackTrace(); } } // 模拟倒计时 public static void tenDown() throws InterruptedException { int num = 10; while (true){ Thread.sleep(1000); System.out.println(num--); if (num \u003c= 0){ break; } } } } ","date":"2022-04-05","objectID":"/java_threads_learning2/:6:2","tags":["Java","Thread","多线程"],"title":"Java多线程学习2","uri":"/java_threads_learning2/"},{"categories":["Java多线程学习"],"content":"具体实现3 隔一段时长打印系统时间 package MultiThread_learning; import java.text.SimpleDateFormat; import java.util.Date; public class TestSleep3 { public static void main(String[] args) { // 打印当前系统时间 Date startTime = new Date(System.currentTimeMillis()); while (true){ try { Thread.sleep(1000); System.out.println(new SimpleDateFormat(\"HH:mm:ss\").format(startTime)); // 更新系统时间 startTime = new Date(System.currentTimeMillis()); } catch (InterruptedException e) { e.printStackTrace(); } } } // 模拟倒计时 public static void tenDown() throws InterruptedException { int num = 10; while (true){ Thread.sleep(1000); System.out.println(num--); if (num \u003c= 0){ break; } } } } ","date":"2022-04-05","objectID":"/java_threads_learning2/:6:3","tags":["Java","Thread","多线程"],"title":"Java多线程学习2","uri":"/java_threads_learning2/"},{"categories":["Java多线程学习"],"content":"线程礼让 让当前只在执行的线程礼让，但不阻塞 让线程从运行状态转为就绪状态 让CPU重新调度，礼让不一定成功，看CPU心情 ","date":"2022-04-05","objectID":"/java_threads_learning2/:7:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习2","uri":"/java_threads_learning2/"},{"categories":["Java多线程学习"],"content":"具体实现 如果礼让成功，则a线程开始执行后b线程应该也开始执行 如果礼让不成功，则a线程执行完之后b线程再执行 package MultiThread_learning; // 测试礼让 public class TestYield { public static void main(String[] args) { MyYield myYield = new MyYield(); new Thread(myYield, \"a Thread\").start(); new Thread(myYield, \"b Thread\").start(); } } class MyYield implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName() + \"线程开始执行\"); Thread.yield(); System.out.println(Thread.currentThread().getName() + \"线程停止执行\"); } } 说明礼让成功 ","date":"2022-04-05","objectID":"/java_threads_learning2/:7:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习2","uri":"/java_threads_learning2/"},{"categories":["Java多线程学习"],"content":"Java 多线程基础知识 程序project：指令和数据的有序集合，静态概念 进程Process：程序的运行过程，是系统资源分配的单位，动态概念 线程Thread：一个进程中可以有多个线程，至少有一个线程，线程是CPU调度和执行的单位。 很多多线程是模拟出来的，真正的多线程是因为有多个cpu核，如果只有单核，实际上cpu一次只能执行一个线程，知识切换很快 程序运行时，即使没有自己创建线程，后台也会有多个线程（主线程和GC线程） 如果一个程序中有多个线程，线程运行的先后人为无法干预，都是由调度器安排调度（调度器与操作系统紧密相关） 对同一份资源操作时，会存在资源抢夺问题，需要加入并发控制 线程会带来额外开销，如CPU调度时间，并发控制开销等 每个线程在自己的工作内存交互，内存控制不当会造成数据不一致（结合JMM理解） ","date":"2022-04-04","objectID":"/java_threads_learning1/:1:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习1","uri":"/java_threads_learning1/"},{"categories":["Java多线程学习"],"content":"线程的创建 Thread class：继承Thread类，重写其中的run方法 Runnable接口：实现Runnable接口 Callable接口：实现Callable接口 推荐使用Runnable接口，避免单继承的局限性，还可以多个对象被一个线程使用，节省资源 ","date":"2022-04-04","objectID":"/java_threads_learning1/:2:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习1","uri":"/java_threads_learning1/"},{"categories":["Java多线程学习"],"content":"Thread创建多线程 package MultiThread_learning; // 创建线程方法1：继承Thread类，重写run()方法，调用start开启线程 public class TestThread1 extends Thread{ @Override public void run() { // run方法线程体 for (int i = 0; i \u003c 20; i++) { System.out.println(\"我在看代码\"+i); } } public static void main(String[] args) { // 创建一个线程对象，调用start，开启线程 TestThread1 testThread1 = new TestThread1(); testThread1.start(); // main线程，主线程 for (int i = 0; i \u003c 20; i++) { System.out.println(\"我在学习多线程\"+i); } } } 自定义线程类继承Thread类 重写run方法 创建一个线程对象，调用start，开启线程 如果在创建线程对象后调用start，则为多线程模式 如果在创建线程对象后调用run，则为单线程模式 线程不一定立即执行，CPU安排调度，所以每一次多线程运行的结果都可能不一样 实例-下载图片 package MultiThread_learning; import org.apache.commons.io.FileUtils; import java.io.File; import java.io.IOException; import java.net.URL; // 练习Threa，实现多线程同步下载图片 public class TestThread2 extends Thread{ private String url; // 网络图片地址 private String name; // 保存的文件名 public TestThread2(String url, String name){ this.url = url; this.name = name; } @Override public void run() { super.run(); WebDownloader webDownloader = new WebDownloader(); webDownloader.downloader(url, name); System.out.println(\"下载了文件名为：\"+name); } public static void main(String[] args) { TestThread2 t1 = new TestThread2(\"https://img-blog.csdnimg.cn/88eba0a511a84000b1e458e9aca123c7.png\", \"1.png\"); TestThread2 t2 = new TestThread2(\"https://img-blog.csdnimg.cn/88eba0a511a84000b1e458e9aca123c7.png\", \"2.png\"); TestThread2 t3 = new TestThread2(\"https://img-blog.csdnimg.cn/88eba0a511a84000b1e458e9aca123c7.png\", \"3.png\"); t1.start(); t2.start(); t3.start(); } } // 下载器 class WebDownloader{ public void downloader(String url, String name){ try{ FileUtils.copyURLToFile(new URL(url), new File(name)); }catch(IOException e){ e.printStackTrace(); System.out.println(\"IO异常，downloader出现问题\"); } } } 多线程下载一张图片，观察执行的先后顺序是否为单线程的顺序执行 可以观察到，执行顺序和单线程顺序执行不一致，实际为多线程同时执行 ","date":"2022-04-04","objectID":"/java_threads_learning1/:2:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习1","uri":"/java_threads_learning1/"},{"categories":["Java多线程学习"],"content":"实现Runnable接口 package MultiThread_learning; import javax.crypto.spec.PSource; public class TestThread3 implements Runnable{ @Override public void run() { for (int i = 0; i \u003c 20; i++) { System.out.println(\"我在看代码--\"+i); } } public static void main(String[] args) { // 创建runnable接口的实现类对象 TestThread3 testThread3 = new TestThread3(); // 创建线程对象，通过线程对象来开启线程，代理 Thread thread = new Thread(testThread3); thread.start(); for (int i = 0; i \u003c 20; i++) { System.out.println(\"我在学习多线程--\"+i); } } } 定义MyRunnable类实现Runnable接口 实现run()方法，编写线程执行体 创建线程对象，调用start()方法启动线程 ","date":"2022-04-04","objectID":"/java_threads_learning1/:2:2","tags":["Java","Thread","多线程"],"title":"Java多线程学习1","uri":"/java_threads_learning1/"},{"categories":["Java多线程学习"],"content":"并发问题–同一个对象被多个线程使用 package MultiThread_learning; public class TestThread4 implements Runnable{ private int ticketNums = 10; @Override public void run() { while (true){ if(ticketNums \u003c=0){ break; } // 模拟延时 try { Thread.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } // 买票 System.out.println(Thread.currentThread().getName() + \"拿到了第\" + ticketNums-- + \"票\"); } } public static void main(String[] args) { TestThread4 testThread4 = new TestThread4(); new Thread(testThread4, \"小明\").start(); new Thread(testThread4, \"老师\").start(); new Thread(testThread4, \"黄牛党\").start(); } } 发现多个线程对同一个资源进行操作的时候，会出现并发问题，线程不安全，数据紊乱 ","date":"2022-04-04","objectID":"/java_threads_learning1/:3:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习1","uri":"/java_threads_learning1/"},{"categories":["Java多线程学习"],"content":"龟兔赛跑案例 package MultiThread_learning; // 模拟归途赛跑 public class Race implements Runnable{ private static String winner; @Override public void run() { for (int i = 0; i \u003c= 100; i++) { // 模拟兔子休息, 10次休息1毫秒 if (Thread.currentThread().getName().equals(\"兔子\") \u0026\u0026 i%10 == 0){ try { Thread.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } } // 判断比赛是否结束 boolean flag = gameOver(i); // 如果比赛结束，停止程序 if(flag){ break; } System.out.println(Thread.currentThread().getName() + \"--\u003e跑了\" + i + \"步\"); } } private boolean gameOver(int steps){ // 判断是否有胜利者 if (winner != null){ // 已经存在胜利者了 return true; }else{ if (steps \u003e= 100){ winner = Thread.currentThread().getName(); System.out.println(\"winner is \" + winner); return true; } } return false; } public static void main(String[] args) { Race race = new Race(); new Thread(race, \"兔子\").start(); new Thread(race, \"乌龟\").start(); } } ","date":"2022-04-04","objectID":"/java_threads_learning1/:4:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习1","uri":"/java_threads_learning1/"},{"categories":["Java多线程学习"],"content":"实现Callable接口 实现Callable接口需要返回值的类型 重写call方法，需要抛出异常 创建目标对象 创建执行服务 提交执行 获取结果 关闭服务 ","date":"2022-04-04","objectID":"/java_threads_learning1/:5:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习1","uri":"/java_threads_learning1/"},{"categories":["Java多线程学习"],"content":"具体实现 package MultiThread_learning; import java.util.concurrent.*; // 多线程的方式三， 实现callable接口 public class TestCallable implements Callable\u003cBoolean\u003e { public String url; public String name; public TestCallable(String url, String name){ this.url = url; this.name = name; } @Override public Boolean call() throws Exception { WebDownloader webDownloader = new WebDownloader(); webDownloader.downloader(url, name); System.out.println(\"下载了文件名为：\"+name); return true; } public static void main(String[] args) throws ExecutionException, InterruptedException { TestCallable testCallable1 = new TestCallable(\"https://img-blog.csdnimg.cn/88eba0a511a84000b1e458e9aca123c7.png\", \"1.png\"); TestCallable testCallable2 = new TestCallable(\"https://img-blog.csdnimg.cn/88eba0a511a84000b1e458e9aca123c7.png\", \"2.png\"); TestCallable testCallable3 = new TestCallable(\"https://img-blog.csdnimg.cn/88eba0a511a84000b1e458e9aca123c7.png\", \"3.png\"); // 创建执行服务, 生成一个线程池 ExecutorService ser = Executors.newFixedThreadPool(3); // 提交执行 Future\u003cBoolean\u003e r1 = ser.submit(testCallable1); Future\u003cBoolean\u003e r2 = ser.submit(testCallable2); Future\u003cBoolean\u003e r3 = ser.submit(testCallable3); // 获取结果 boolean rs1 = r1.get(); boolean rs2 = r2.get(); boolean rs3 = r3.get(); // 关闭服务 ser.shutdown(); } } // 下载器 class WebDownloader{ public void downloader(String url, String name){ try{ FileUtils.copyURLToFile(new URL(url), new File(name)); }catch(IOException e){ e.printStackTrace(); System.out.println(\"IO异常，downloader出现问题\"); } } } ","date":"2022-04-04","objectID":"/java_threads_learning1/:5:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习1","uri":"/java_threads_learning1/"},{"categories":["Java多线程学习"],"content":"Callable特性 可以定义返回值 可以跑出异常 ","date":"2022-04-04","objectID":"/java_threads_learning1/:5:2","tags":["Java","Thread","多线程"],"title":"Java多线程学习1","uri":"/java_threads_learning1/"},{"categories":["JVM学习"],"content":"遇到OOM错误的处理方式 尝试扩大对内存空间大小 能够看到代码第几行出错：内存快照工具（MAT， Jprofiler） ","date":"2022-04-03","objectID":"/jvm_learning6/:1:0","tags":["Java","算法","JVM"],"title":"JVM 学习6","uri":"/jvm_learning6/"},{"categories":["JVM学习"],"content":"MAT(eclipse)/Jprofiler(IDEA)作用 分析Dump内存文件，快速定位内存泄漏问题 获取堆中的数据 获的大的对象 ","date":"2022-04-03","objectID":"/jvm_learning6/:1:1","tags":["Java","算法","JVM"],"title":"JVM 学习6","uri":"/jvm_learning6/"},{"categories":["JVM学习"],"content":"使用Jprofiler 查看内存快照 命令-Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError，得到内存快照.hprof文件，使用Jprofiler打开，存放在模块级别的目录下 Jprofiler 中可以查看的内容如下 查看思路：先看大的对象在Current Object Set 中查看 再进Thread Dump中查看是哪个线程的哪行代码出现问题 ","date":"2022-04-03","objectID":"/jvm_learning6/:1:2","tags":["Java","算法","JVM"],"title":"JVM 学习6","uri":"/jvm_learning6/"},{"categories":["JVM学习"],"content":"GC补充知识点 GC的作用区域为方法区和堆当中 垃圾回收只能JVM自行处理，程序员不能手动回收，只能提醒 JVM进行垃圾回收时，并不是对三个区域（新生区，幸存区from，幸存区to，老年区）统一回收，大部分时候都是回收新生区 ","date":"2022-04-03","objectID":"/jvm_learning6/:2:0","tags":["Java","算法","JVM"],"title":"JVM 学习6","uri":"/jvm_learning6/"},{"categories":["JVM学习"],"content":"GC的分类 轻GC（普通GC）：只针对新生代，偶尔针对幸存区 重GC（全局GC）：所有的内容都把内存释放掉 ","date":"2022-04-03","objectID":"/jvm_learning6/:2:1","tags":["Java","算法","JVM"],"title":"JVM 学习6","uri":"/jvm_learning6/"},{"categories":["JVM学习"],"content":"例题 JVM的内存模型和分区，详细到每个区放什么 堆里面的分区有哪些 GC算法有哪些：标记清除法、标记整理（标记压缩）法、复制算法、引用计数器 轻GC和重GC分别在什么时候发生 ","date":"2022-04-03","objectID":"/jvm_learning6/:2:2","tags":["Java","算法","JVM"],"title":"JVM 学习6","uri":"/jvm_learning6/"},{"categories":["JVM学习"],"content":"GC常用算法 ","date":"2022-04-03","objectID":"/jvm_learning6/:3:0","tags":["Java","算法","JVM"],"title":"JVM 学习6","uri":"/jvm_learning6/"},{"categories":["JVM学习"],"content":"引用计数法 对象引用次数进行计数 计数器本身也有消耗，这种方法并不高效 淘汰使用少的对象（python用的就是这种方法） ","date":"2022-04-03","objectID":"/jvm_learning6/:3:1","tags":["Java","算法","JVM"],"title":"JVM 学习6","uri":"/jvm_learning6/"},{"categories":["JVM学习"],"content":"复制算法 年轻代（伊甸园区，from，to）主要用的复制算法 幸存区的from和to区之间的交换遵循：谁空谁是to 每次GC之后都会将伊甸园区中活对象，都会进入到幸存区，此时伊甸园区变为空的 from 和 to之间会不停地交换 通过from 和 to 之间的复制，和身份交换，始终保证to是空的 当对象经过15（-XX:MaxTenuringThreshold=15, 此参数设置进入老年区所要经历的GC次数，默认是15）次GC没有被清理掉时，则进入养老区 具体执行过程 Eden区中活下来的部分进入to，且将From中的对象复制到to中 from和to进行名称交换，保证to中始终为空，以备下次GC 所以每次轻GC之后，eden区是空的，to也是空的 经过MaxTenuringThreshold=15次轻GC之后对象在from中还没有被清理，则进入养老区 优点：没有内存碎片 坏处：浪费一半的内存区空间（to区始终是空的），假设对象100%存活（极端情况），此种算法的成本很高 最佳使用场景，对象存活度较低的时候，新生区 ","date":"2022-04-03","objectID":"/jvm_learning6/:3:2","tags":["Java","算法","JVM"],"title":"JVM 学习6","uri":"/jvm_learning6/"},{"categories":["JVM学习"],"content":"标记清除法 扫描对象，对活着的对象进行标记 对没有标记的对象进行清除 缺点：两次扫描严重浪费时间，会产生内存碎片 优点：不需要额外的空间 ","date":"2022-04-03","objectID":"/jvm_learning6/:3:3","tags":["Java","算法","JVM"],"title":"JVM 学习6","uri":"/jvm_learning6/"},{"categories":["JVM学习"],"content":"标记压缩算法 在标记清除的基础上进行再优化，将内存碎片进行压缩，防止内存碎片产生 再次扫描，向一端移动存活对象 多了一个移动成本 ","date":"2022-04-03","objectID":"/jvm_learning6/:3:4","tags":["Java","算法","JVM"],"title":"JVM 学习6","uri":"/jvm_learning6/"},{"categories":["JVM学习"],"content":"标记清除压缩算法 标记清除和标记压缩实际可以结合使用 经过几轮的标记清除之后，碎片多了起来，再进行标记压缩，压缩扫描的效率会高很多 ","date":"2022-04-03","objectID":"/jvm_learning6/:3:5","tags":["Java","算法","JVM"],"title":"JVM 学习6","uri":"/jvm_learning6/"},{"categories":["JVM学习"],"content":"几种算法的对比 内存效率：复制算法\u003e标记清除法\u003e标记压缩算法（时间复杂度） 内存整齐度（内存碎片的多少）：复制算法=标记压缩法\u003e标记清除算法 内存利用率：标记压缩法=标记清除算法\u003e复制算法 ","date":"2022-04-03","objectID":"/jvm_learning6/:3:6","tags":["Java","算法","JVM"],"title":"JVM 学习6","uri":"/jvm_learning6/"},{"categories":["JVM学习"],"content":"总结 没有最好的算法 只有最合适的算法 GC：分代收集算法 年轻代：存活率低，使用复制算法 老年代：存活率高，区域大，使用标记清除（内存碎片不是太多）+标记压缩算法（内存碎片已经很多了）混合实现 ","date":"2022-04-03","objectID":"/jvm_learning6/:3:7","tags":["Java","算法","JVM"],"title":"JVM 学习6","uri":"/jvm_learning6/"},{"categories":["JVM学习"],"content":"JMM（Java Memory Model） 一个缓存一致性协议，用于定义数据读写的规则 ","date":"2022-04-03","objectID":"/jvm_learning6/:4:0","tags":["Java","算法","JVM"],"title":"JVM 学习6","uri":"/jvm_learning6/"},{"categories":["JVM学习"],"content":"三种JVM Hotspot：Sun公司，用户数多 BEA JROckit：Oracle 设个财务前段办公、军事指挥与控制和电信网络的需要 j9vm JIT编译器：IBM公司，以Oracle 的java 为基础 ","date":"2022-04-02","objectID":"/jvm_learning5/:1:0","tags":["Java","算法","JVM"],"title":"JVM 学习5","uri":"/jvm_learning5/"},{"categories":["JVM学习"],"content":"堆（堆内存） Heap，一个JVM只有一个堆内存，堆内存的大小是可以调节的。 ","date":"2022-04-02","objectID":"/jvm_learning5/:2:0","tags":["Java","算法","JVM"],"title":"JVM 学习5","uri":"/jvm_learning5/"},{"categories":["JVM学习"],"content":"基本概念 类加载器读取了类文件之后，类、方法、常量、变量、保存所有引用类型的真实对象 堆内存中细分为三个区域：新生区younger new、养老区old、永久区perm（JDK1.8已经没有永久区，改成元空间了） 新生区包括：伊甸园、幸存0区、幸存1区 如果伊甸园区中新生的对象经过垃圾GC回收之后还没有被回收，则进入幸存0区 如果幸存0区满了，就会进入幸存1区，两个幸存区之间可以相互调动 如果在幸存区之中依然撑过了垃圾回收机制，则进入养老区 垃圾回收分为轻量级、重量级。轻量级针对新生区，重量级针对养老区 永久存储区包括java内置的方法和数据 ","date":"2022-04-02","objectID":"/jvm_learning5/:2:1","tags":["Java","算法","JVM"],"title":"JVM 学习5","uri":"/jvm_learning5/"},{"categories":["JVM学习"],"content":"堆内存溢出错误（OOM） GC 垃圾回收主要是在伊甸园区和养老区 假设内存满了，会报错OOM(OutOfMemoryError)，堆内存不够了，如下图代码所示 在JDK8以后，永久存储区改名你为元空间 ","date":"2022-04-02","objectID":"/jvm_learning5/:2:2","tags":["Java","算法","JVM"],"title":"JVM 学习5","uri":"/jvm_learning5/"},{"categories":["JVM学习"],"content":"新生区 一个类诞生产生死亡的地方 分为伊甸园区和幸存者区（幸存者0区和幸存者1区） 所有的对象都出生在伊甸园区（new） 假设伊甸园区只能存放10个实例对象，就会出发一次轻GC，活下来的对象就会进入幸存区 同理幸存区满了就会触发一次重GC，幸存下来的进入养老区 如果新生区和养老区都满了，则出现OOM错误出现 实际上99%的对象都是临时对象，很难进入到养老区 ","date":"2022-04-02","objectID":"/jvm_learning5/:3:0","tags":["Java","算法","JVM"],"title":"JVM 学习5","uri":"/jvm_learning5/"},{"categories":["JVM学习"],"content":"永久区 这个区域常驻内存，用来存放JDK自身携带的Class对象，Interface元数据 存储Java运行时的一些环境或者类信息 这个区域不存在垃圾回收机制 关闭虚拟机的时候就会释放这个区域的内存 一个启动类如果加载了大量的jar包，或者tomcat部署了太多应用，大量动态生成的反射类，如果这些内容不段被加载，可能会出现OOM错误 ","date":"2022-04-02","objectID":"/jvm_learning5/:4:0","tags":["Java","算法","JVM"],"title":"JVM 学习5","uri":"/jvm_learning5/"},{"categories":["JVM学习"],"content":"版本变化 JDK1.6之前：永久代，常量池在方法区中 JDK1.7：永久代，但是慢慢弱化了，去永久代，常量池在堆中 JDK1.8：无永久代，常量池在元空间之中 ","date":"2022-04-02","objectID":"/jvm_learning5/:4:1","tags":["Java","算法","JVM"],"title":"JVM 学习5","uri":"/jvm_learning5/"},{"categories":["JVM学习"],"content":"堆整体结构 方法区（存放类中的常量等信息–常量池）是一种特殊的堆（堆） package swagger_test; import javax.management.relation.RoleUnresolved; public class HeapTestDemo { public static void main(String[] args) { // 返回最大内存 long maxMemory = Runtime.getRuntime().maxMemory(); // 返回初始化内存 long totalMemory = Runtime.getRuntime().totalMemory(); System.out.println(\"maxMemory=\" + maxMemory + \"字节\\t\" + (maxMemory/(double)1024/1024) + \"MB\"); System.out.println(\"totalMemory=\" + totalMemory + \"字节\\t\" + (totalMemory/(double)1024/1024) + \"MB\"); } } ","date":"2022-04-02","objectID":"/jvm_learning5/:4:2","tags":["Java","算法","JVM"],"title":"JVM 学习5","uri":"/jvm_learning5/"},{"categories":["JVM学习"],"content":"查看堆内存 最大内存约等于计算机总内存的4分之一 初始化内存为计算机总内存的64分之一 元空间逻辑上存在，但是物理上不一定存在，实际上在系统的内存中 ","date":"2022-04-02","objectID":"/jvm_learning5/:4:3","tags":["Java","算法","JVM"],"title":"JVM 学习5","uri":"/jvm_learning5/"},{"categories":["JVM学习"],"content":"调整堆内存大小 其中-Xmx为最大内存大小，调整为1024mb 其中-Xms为初始化内存大小，调整为1024mb -XX:PrintGCDetails为打印具体的内存信息 ","date":"2022-04-02","objectID":"/jvm_learning5/:4:4","tags":["Java","算法","JVM"],"title":"JVM 学习5","uri":"/jvm_learning5/"},{"categories":["JVM学习"],"content":"栈基本概念 一种先进后出的数据结构与队列相对 栈内存，主管程序的运行 生命周期与线程同步，线程结束，栈内存也就释放了 对于栈内存来说，不存在垃圾回收机制 ","date":"2022-03-30","objectID":"/jvm_learning4/:1:0","tags":["Java","算法","JVM"],"title":"JVM 学习4","uri":"/jvm_learning4/"},{"categories":["JVM学习"],"content":"执行是栈内存的执行情况 首先main方法压栈 main中调用test方法，test压栈 test执行完后出栈 main执行完后出栈，整个程序执行完成 ","date":"2022-03-30","objectID":"/jvm_learning4/:2:0","tags":["Java","算法","JVM"],"title":"JVM 学习4","uri":"/jvm_learning4/"},{"categories":["JVM学习"],"content":"栈内存溢出错误 test 方法 和 a方法两者之间递归调用 无法停止，说明在不停地向占内存中压栈，耗尽栈内存空间，导致栈内存溢出（StackOverflowError） ","date":"2022-03-30","objectID":"/jvm_learning4/:3:0","tags":["Java","算法","JVM"],"title":"JVM 学习4","uri":"/jvm_learning4/"},{"categories":["JVM学习"],"content":"栈内存放的数据 八大基本类型 对象的引用 实例的方法 ","date":"2022-03-30","objectID":"/jvm_learning4/:4:0","tags":["Java","算法","JVM"],"title":"JVM 学习4","uri":"/jvm_learning4/"},{"categories":["JVM学习"],"content":"栈运行原理 每一个执行的方法都会产生一个栈帧 程序正在执行的方法永远在栈顶 stack1 和 stack2均为一个栈帧 每一个栈帧内部都存放着数据 ","date":"2022-03-30","objectID":"/jvm_learning4/:5:0","tags":["Java","算法","JVM"],"title":"JVM 学习4","uri":"/jvm_learning4/"},{"categories":["JVM学习"],"content":"栈、堆、方法区的交互关系 关键：绿色为栈内存，浅蓝色为堆内存，红色为方法区，蓝色为常量池，白色为通过编译的class文件 new一个对象时，加一个引用到栈的一个栈帧里 栈里还包括其他存放数据 new的对象数据存放在堆内存中，通过栈中的引用找到 堆中对象所包含的常量去方法区中的常量池寻找 ","date":"2022-03-30","objectID":"/jvm_learning4/:6:0","tags":["Java","算法","JVM"],"title":"JVM 学习4","uri":"/jvm_learning4/"},{"categories":["JVM学习"],"content":"沙箱安全机制 限制程序运行的环境，将java代码限定在JVM特定的运行范围内 当前最新的安全机制实现，则引入了域(Domain) 的概念。虚拟机会把所有代码加载到不同的系统域和应用域，系统域部分专门负责与关键资源进行交互 各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。 虚拟机中不同的受保护域(Protected Domain)，对应不一样的权限 (Permission)。 存在于不同域中的类文件 就具有了当前域的全部权限， ","date":"2022-03-30","objectID":"/jvm_learning3/:1:0","tags":["Java","算法","JVM"],"title":"JVM 学习3","uri":"/jvm_learning3/"},{"categories":["JVM学习"],"content":"组成沙箱的基本组件 字节码校验器：确保Java类文件遵循Java语言规范，并不是所有的类文件都会经过字节码校验，比如核心类 类装载器：防止恶意代码进行干涉（双亲委派机制）；守护了被信任类库的边界；将代码归入保护域，确定哪些代码可以进行操作 ","date":"2022-03-30","objectID":"/jvm_learning3/:1:1","tags":["Java","算法","JVM"],"title":"JVM 学习3","uri":"/jvm_learning3/"},{"categories":["JVM学习"],"content":"类装载器的工作模式方法 从最内层的JVM自带类加载器开始加载，防止外层恶意同名类得不到加载从而无法使用 严格通过包来区分访问域，外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码自然就无法生效 存取控制器：存取控制器可以控制核心API对操作系统的存取权限，而这个控制策略的设定可以有用户指定 安全管理器：是核心API和操作系统之间的主要接口，实现权限控制，比存取控制器的优先级高 安全软件包：java.security下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性：安全提供者、消息摘要、数字签名keytools（eg：生成安全证书，可以访问到https）、加密、鉴别 ","date":"2022-03-30","objectID":"/jvm_learning3/:1:2","tags":["Java","算法","JVM"],"title":"JVM 学习3","uri":"/jvm_learning3/"},{"categories":["JVM学习"],"content":"native 凡是带了native 关键字的方法，说明java的作用范围已经达不到了，开始调用底层C++代码 实际上是进入了内存中的本地方法栈 通过本地方法栈调用本地接口JNI（Java Native Interface），使用本地方法库 JNI的作用，扩展Java的使用，融合不同的变成语言，为Java所用 Java 诞生时C、C++ 程序员横行，必须要有调用C或者C++代码的能力 他在内存区域中转么开辟了一块标记区域–本地方法栈，登记native方法 在最终执行的时候通过JNI加载本地方法库中的方法 调用其他接口 eg：robot类操作电脑操作、驱动硬件、管理系统 ","date":"2022-03-30","objectID":"/jvm_learning3/:2:0","tags":["Java","算法","JVM"],"title":"JVM 学习3","uri":"/jvm_learning3/"},{"categories":["JVM学习"],"content":"PC寄存器—程序计数器（program counter register） 每一个线程都有一个程序计数器 线程是私有的，就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址） 然后执行引擎读取下一条命令，是一个非常小的内存空间，可以忽略不计 ","date":"2022-03-30","objectID":"/jvm_learning3/:3:0","tags":["Java","算法","JVM"],"title":"JVM 学习3","uri":"/jvm_learning3/"},{"categories":["JVM学习"],"content":"方法区（method area） 方法区被所有线程所共享，所有定义方法的信息都保存在该区域 共享的内容包括：静态变量static、常量final、类信息（构造方法、接口定义）Class、运行时的常量池 注意实例变量存在对内存中，和方法区无关 ","date":"2022-03-30","objectID":"/jvm_learning3/:4:0","tags":["Java","算法","JVM"],"title":"JVM 学习3","uri":"/jvm_learning3/"},{"categories":["6D pose"],"content":"robot grasping 基础 主要分为三个关键任务，Object Localization，Object Pose Estimation，Grasp Estimation Object Localization主要的几种方法，Object Localization without classification，Object Detection，Object Instance segmentation Object Pose Estimation主要的几种方法，Corresponding-based methods，Template-based methods， Voting-based methods Grasp Estimation的两种方式，2D planer grasp，6DoF grasp tips：这三个关键任务不一定要全部都用上才能抓取识别，实际上很时候只用其中的1个或者2个就可以完成抓取识别 ","date":"2022-03-29","objectID":"/6dpose_survey/:1:0","tags":["6D Pose","Category level","Instance level"],"title":"6DPose 论文总结","uri":"/6dpose_survey/"},{"categories":["6D pose"],"content":"各个关键任务的作用 Object Localization：找到目标对象的区域所在 Object Pose Estimation：估计物体的6D姿态，以方便生成抓取位姿 Grasp Estimation：估计物体的抓取位姿，2D抓取约束为从一个方向抓取，但是6DoF 抓取可以从任意方向进行抓取 ","date":"2022-03-29","objectID":"/6dpose_survey/:1:1","tags":["6D Pose","Category level","Instance level"],"title":"6DPose 论文总结","uri":"/6dpose_survey/"},{"categories":["6D pose"],"content":"一个抓取系统所包含的部分 grasp detection system：进行抓取姿态预测 grasp planning system：有了姿态预测之后进行抓取路径规划 control system：控制各个部件 ","date":"2022-03-29","objectID":"/6dpose_survey/:1:2","tags":["6D Pose","Category level","Instance level"],"title":"6DPose 论文总结","uri":"/6dpose_survey/"},{"categories":["6D pose"],"content":"抓取end effectors 夹爪：平行夹爪，三指夹爪，五指夹爪 吸盘：单吸盘，多吸盘（此种方式抓取方式简单，面对几何复杂的物体难以起效） ","date":"2022-03-29","objectID":"/6dpose_survey/:1:3","tags":["6D Pose","Category level","Instance level"],"title":"6DPose 论文总结","uri":"/6dpose_survey/"},{"categories":["6D pose"],"content":"抓取方式的不同 ","date":"2022-03-29","objectID":"/6dpose_survey/:2:0","tags":["6D Pose","Category level","Instance level"],"title":"6DPose 论文总结","uri":"/6dpose_survey/"},{"categories":["6D pose"],"content":"2D planer grasp 2D 形式的抓取规定机械臂只能朝一个方向去抓取（垂直于工作台平面） 高度是固定的，抓取方式预测被降为2D➕1D的方式，2D为平面上的物体位置，1D为旋转角，有些还会加上夹爪的宽度参数和矩形框描述法中的高度参数 具体有两种方法：接触点评估法（平行夹爪与物体基础的两个点，如double dot图），矩形框评估法（如上图） ","date":"2022-03-29","objectID":"/6dpose_survey/:2:1","tags":["6D Pose","Category level","Instance level"],"title":"6DPose 论文总结","uri":"/6dpose_survey/"},{"categories":["6D pose"],"content":"6DoF grasp 在3D空间中可以以任意角度对物体进行抓取，所以不能像2D planer grasp方法那样对抓取方式进行简化 开始时使用分析法，之后在RGB-D 的辅助下，开始使用深度学习的方法，进行预测 开始时都是对已知物体进行预测，之后开始对陌生物体也进行预测 基于部分局部点云的方法：不需要物体的CAD模型，还可以细分为估计候选抓取方法质量的方法，和从现有抓取转移抓取的方法 基于完整形状的方法：当目标物体的CAD模型已知时，可以直接预测出6D物体位姿，当CAD模型未知时，使用点云重建CAD模型，得到完整形状，从而预测6D物体位姿 ","date":"2022-03-29","objectID":"/6dpose_survey/:2:2","tags":["6D Pose","Category level","Instance level"],"title":"6DPose 论文总结","uri":"/6dpose_survey/"},{"categories":["6D pose"],"content":"9Dof grasp 6DoF的基础上加上了对物体长宽高的预测 可视化结果多为Bounding Box，图中的红绿蓝三条线为空间坐标，bounding box 包含三维旋转位姿和三维scale信息 ","date":"2022-03-29","objectID":"/6dpose_survey/:2:3","tags":["6D Pose","Category level","Instance level"],"title":"6DPose 论文总结","uri":"/6dpose_survey/"},{"categories":["6D pose"],"content":"object localization Object Localization without classification：找到目标物体所在的区域，但是不知道目标物体的类别 Object Detection：找到目标物体的所在的区域，同时知道其类别，多用于目标区域内有多个物体，要找出指定物体的位置 Object Instance segmentation：指的是探测像素级别某一类别物体的实例对象 ","date":"2022-03-29","objectID":"/6dpose_survey/:3:0","tags":["6D Pose","Category level","Instance level"],"title":"6DPose 论文总结","uri":"/6dpose_survey/"},{"categories":["6D pose"],"content":"关注的问题 对遮挡物体的鲁棒性 如何处理对称物体的ambiguous rotation问题 ","date":"2022-03-29","objectID":"/6dpose_survey/:4:0","tags":["6D Pose","Category level","Instance level"],"title":"6DPose 论文总结","uri":"/6dpose_survey/"},{"categories":["6D pose"],"content":"分类 使用方法分类：correspondence-based，template-based，voting-based（keypoint-based） 预测目标级别分类：instance-level，category-level instance-level常用技术路线：实例分割之后与标准CAD模型进行模板匹配回归出位姿信息 category-level常用技术路线：缺少实例目标CAD模型，需要额外对每个Category设计标注范式 By Boyan Wei ","date":"2022-03-29","objectID":"/6dpose_survey/:5:0","tags":["6D Pose","Category level","Instance level"],"title":"6DPose 论文总结","uri":"/6dpose_survey/"},{"categories":["JVM学习"],"content":"JVM常见的问题 基本都是理论知识 谈谈你对JVM的理解 JAVA8 虚拟机和之前的区别 什么是OOM 什么是栈溢出StackOverFlowError，怎么分析 JVM的常用调优参数 内存快照如何抓取 怎么分析Dump文件 谈谈JVM中类加载器你的认识 ","date":"2022-03-29","objectID":"/jvm_learning2/:1:0","tags":["Java","算法","JVM"],"title":"JVM 学习2","uri":"/jvm_learning2/"},{"categories":["JVM学习"],"content":"重点 JVM的位置 JVM的体系结构 类加载器 双亲委派机制 沙箱安全机制 Native PC寄存器 方法区 栈 三种JVM 堆 新生区 老年区 永久区 堆内存调优 GC垃圾回收机制 GC常用算法 JMM ","date":"2022-03-29","objectID":"/jvm_learning2/:2:0","tags":["Java","算法","JVM"],"title":"JVM 学习2","uri":"/jvm_learning2/"},{"categories":["JVM学习"],"content":"学习方法 百度搜索 思维导图 ","date":"2022-03-29","objectID":"/jvm_learning2/:3:0","tags":["Java","算法","JVM"],"title":"JVM 学习2","uri":"/jvm_learning2/"},{"categories":["JVM学习"],"content":"JVM的位置 基础是硬件体系，以上是操作系统，JVM依托于操作系统之上 实际上运行只需要JRE即可（整个JDK太大了），java程序可以直接运行在JRE上 ","date":"2022-03-29","objectID":"/jvm_learning2/:4:0","tags":["Java","算法","JVM"],"title":"JVM 学习2","uri":"/jvm_learning2/"},{"categories":["JVM学习"],"content":"JVM的体系结构 java栈、本地方法栈、程序计数器 不会有垃圾回收机制 方法区是一种特殊的堆 垃圾回收机制存在于方法区和堆中 JVM调优基本都是调堆 native 中的本地方法库指的是java的底层实现，比如多线程中的start 方法，其中底层实现调用了native库中的start0方法，由c++是实现 ","date":"2022-03-29","objectID":"/jvm_learning2/:5:0","tags":["Java","算法","JVM"],"title":"JVM 学习2","uri":"/jvm_learning2/"},{"categories":["JVM学习"],"content":"类加载器 作用：加载class文件 new 一个对象的时候，对象的引用(名字、地址)在栈中，实际的对象数据都在在堆内存中 虚拟机自带的加载器 启动类（根）加载器 扩展类加载器 应用程序加载器 java 的底层是C++实现的，去掉了C++ 当中的指针和内存管理，内存管理全部交给JVM来进行管理了。 ","date":"2022-03-29","objectID":"/jvm_learning2/:6:0","tags":["Java","算法","JVM"],"title":"JVM 学习2","uri":"/jvm_learning2/"},{"categories":["JVM学习"],"content":"简单过程 类加载器收到类加载请求 将这个请求向上委托给父类加载器去完成，一直向上委托，直到委托到boot class loader（启动类加载器） 检查启动类加载器是否能够加载当前这个类，如果能加载就结束，使用当前加载器，否则，跑出异常，通知字加载器进行加载 重复步骤3（最后一层子类就是当前用户自定义的类—-app） ","date":"2022-03-29","objectID":"/jvm_learning2/:6:1","tags":["Java","算法","JVM"],"title":"JVM 学习2","uri":"/jvm_learning2/"},{"categories":["JVM学习"],"content":"双亲委派机制 为了安全而执行，避免程序员改动boot 加载器所涉及的java基础包，造成不必要的错误 先去boot 根加载器中寻找，再去ext 扩展类加载器中寻找，最后去app 应用程序（自定义）加载类中寻找，如果自定义的方法和类与上述路径有重名，则执行上述路径中的 ","date":"2022-03-29","objectID":"/jvm_learning2/:7:0","tags":["Java","算法","JVM"],"title":"JVM 学习2","uri":"/jvm_learning2/"},{"categories":["6D pose"],"content":"背景 真实数据集上训练出来的模型往往难以推广到没有遇到过的场景 实例级别的9D姿态预测在测试时需要对没有见过的物体也有效，因为实例级别预测是没有CAD模型的，这往往也很难 ","date":"2022-03-19","objectID":"/category_level_1_cppf/:1:0","tags":["6D Pose","Category level","9D Pose"],"title":"CPPF","uri":"/category_level_1_cppf/"},{"categories":["6D pose"],"content":"贡献点 基于PPF(pair point features)提出CPPF(Category level pair point features)投票法进行9D姿态预测 提出一种由粗到细的算法消除噪声点对（当实例分割算法不够精准时） 提出一种实例分割算法用于发现目标物体 提出一个binary disambiguating classification task消除旋转姿态投票误报 只在虚拟点云上进行训练，除非物体在几何上的姿态非常模糊 RGB信息被用来消除姿态歧义 ","date":"2022-03-19","objectID":"/category_level_1_cppf/:2:0","tags":["6D Pose","Category level","9D Pose"],"title":"CPPF","uri":"/category_level_1_cppf/"},{"categories":["6D pose"],"content":"数据集 NOCS REAL275 SUN RGB-D ","date":"2022-03-19","objectID":"/category_level_1_cppf/:3:0","tags":["6D Pose","Category level","9D Pose"],"title":"CPPF","uri":"/category_level_1_cppf/"},{"categories":["6D pose"],"content":"实验 NOCS REAL275 对比实验 NOCS REAL275 仅提供bounding box 进行9D预测实验 SUN RGB-D 更加复杂的真实环境实验 ","date":"2022-03-19","objectID":"/category_level_1_cppf/:4:0","tags":["6D Pose","Category level","9D Pose"],"title":"CPPF","uri":"/category_level_1_cppf/"},{"categories":["6D pose"],"content":"pipeline 其中u，v确定中心点 a，B确定rotation 伽马确定scale 训练的输入为仿真数据集模型 ","date":"2022-03-19","objectID":"/category_level_1_cppf/:5:0","tags":["6D Pose","Category level","9D Pose"],"title":"CPPF","uri":"/category_level_1_cppf/"},{"categories":["6D pose"],"content":"voting-based ","date":"2022-03-19","objectID":"/category_level_1_cppf/:6:0","tags":["6D Pose","Category level","9D Pose"],"title":"CPPF","uri":"/category_level_1_cppf/"},{"categories":["6D pose"],"content":"voting for center 通过一组点对p1、p2确定一组U，V向量 计算出center 多组candidates 进行投票 ","date":"2022-03-19","objectID":"/category_level_1_cppf/:6:1","tags":["6D Pose","Category level","9D Pose"],"title":"CPPF","uri":"/category_level_1_cppf/"},{"categories":["6D pose"],"content":"voting for orientation 浅色部分为candidate orientation votes部分 可以看到中间浅色部分同时被两组点对投票 对如下两者的交叉熵进行二分类 如果CrossEntropy(ˆσ , σˆ)比 CrossEntropy(−σˆ , σˆ)，更小，就保留e1，反之，则保留-e1 ","date":"2022-03-19","objectID":"/category_level_1_cppf/:6:2","tags":["6D Pose","Category level","9D Pose"],"title":"CPPF","uri":"/category_level_1_cppf/"},{"categories":["6D pose"],"content":"voting for scales 开始时为采样点的平均值 之后进过vating，找到最终的scale ","date":"2022-03-19","objectID":"/category_level_1_cppf/:6:3","tags":["6D Pose","Category level","9D Pose"],"title":"CPPF","uri":"/category_level_1_cppf/"},{"categories":["MySQL学习"],"content":"基础结构 用户连接 connection–mysql 数据库 database–information_schema 表格 table 视图 view 等等 ","date":"2022-02-22","objectID":"/mysql_learning/:1:0","tags":["SQL","mysql","navicat"],"title":"MySQL学习1-基础命令行操作","uri":"/mysql_learning/"},{"categories":["MySQL学习"],"content":"连接数据库 navicat 双击数据库，创建连接 命令行连接 mysql -uroot -pWby785403310 修改密码 updatemysql.usersetauthentication_string=password('123456')whereuser='root'andHost='localhost'; 刷新权限 flushprivileges; ","date":"2022-02-22","objectID":"/mysql_learning/:2:0","tags":["SQL","mysql","navicat"],"title":"MySQL学习1-基础命令行操作","uri":"/mysql_learning/"},{"categories":["MySQL学习"],"content":"常用基础命令 查看所有数据库 showdatabases; 使用数据库 use + database名称 usemysql; 查看所有table showtables; 查看指定表结构 describeuser; 创建一个数据库 createdatabasewestos; 退出连接和注视 exit;--退出连接 --单行注释 /* sql 多行注释 */ ","date":"2022-02-22","objectID":"/mysql_learning/:3:0","tags":["SQL","mysql","navicat"],"title":"MySQL学习1-基础命令行操作","uri":"/mysql_learning/"},{"categories":["MySQL学习"],"content":"mysql 语言种类 CRUD 增删改查 DDL database define language DML database manipulate language DQL database query language DCL database control language CV 程序员 API 程序员 CRUD 程序员（业务） ","date":"2022-02-22","objectID":"/mysql_learning/:4:0","tags":["SQL","mysql","navicat"],"title":"MySQL学习1-基础命令行操作","uri":"/mysql_learning/"},{"categories":["MySQL学习"],"content":"操作数据库 操作数据库\u003e操作数据库中的表\u003e操作数据库中的表数据 关键字不区分大小写 ","date":"2022-02-22","objectID":"/mysql_learning/:5:0","tags":["SQL","mysql","navicat"],"title":"MySQL学习1-基础命令行操作","uri":"/mysql_learning/"},{"categories":["MySQL学习"],"content":"操作数据库 （了解） 创建数据库 CREATE DATABASE IF NOT EXISTS westos; 删除数据库 DROP DATABASE IF EXISTS hello; 使用数据库 use `school` (如果表明和字段名是一个保留字，应该加上反引号) 查看数据库 show databases ","date":"2022-02-22","objectID":"/mysql_learning/:5:1","tags":["SQL","mysql","navicat"],"title":"MySQL学习1-基础命令行操作","uri":"/mysql_learning/"},{"categories":["MySQL学习"],"content":"数据库的数据（列）类型 1 数值 tinyint 十分小的数据 1个字节 smallint 较小的数据 2个字节 mediumint 中等大小 3个字节 int 标准的整数 4个字节 bigint 较大的数据 8个字节 float 单精度 4个字节 double 双精度 8个字节（精度问题） decimal 字符串形式的浮点数（金融计算，一般是decimal） 2 字符串 char 字符固定大小 0～255 varchar 可变字符串 0～65535 常用变量 tinytext 微型文本 2^8-1 text 文本类型 一般用于大型文章 3 时间日期 date YYYY-MM-DD 日期格式 time HH：mm：ss 时间格式 datetime YYYY-MM-DD HH：mm：ss 最常用的时间格式 timestamp 时间戳 1970.1.1 到现在的毫秒数 year 年份表示 4 null 没有值，未知 不要使用null进行运算 ","date":"2022-02-22","objectID":"/mysql_learning/:5:2","tags":["SQL","mysql","navicat"],"title":"MySQL学习1-基础命令行操作","uri":"/mysql_learning/"},{"categories":["开发工具"],"content":"下载Hugo ","date":"2022-02-16","objectID":"/hugo_learning/:1:0","tags":["hugo"],"title":"Hugo 使用教程","uri":"/hugo_learning/"},{"categories":["开发工具"],"content":"使用 brew 来安装hugo brew install hugo ","date":"2022-02-16","objectID":"/hugo_learning/:1:1","tags":["hugo"],"title":"Hugo 使用教程","uri":"/hugo_learning/"},{"categories":["开发工具"],"content":"新建一个hugo 项目 hugo new site mysite ","date":"2022-02-16","objectID":"/hugo_learning/:1:2","tags":["hugo"],"title":"Hugo 使用教程","uri":"/hugo_learning/"},{"categories":["开发工具"],"content":"hugo 项目文件结构介绍 content 博客内容 static 图片 theme 主题 ","date":"2022-02-16","objectID":"/hugo_learning/:1:3","tags":["hugo"],"title":"Hugo 使用教程","uri":"/hugo_learning/"},{"categories":["开发工具"],"content":"主题的配置 ","date":"2022-02-16","objectID":"/hugo_learning/:2:0","tags":["hugo"],"title":"Hugo 使用教程","uri":"/hugo_learning/"},{"categories":["开发工具"],"content":"主题下载 进入gohugo.io 搜索一个主题下载到项目中的theme 文件夹之中 ","date":"2022-02-16","objectID":"/hugo_learning/:2:1","tags":["hugo"],"title":"Hugo 使用教程","uri":"/hugo_learning/"},{"categories":["开发工具"],"content":"主题的配置 进入下载主题的说明文档 https://hugoloveit.com/zh-cn/theme-documentation-basics/ 复制基本配置，并覆盖项目根目录的config.toml 文件 ","date":"2022-02-16","objectID":"/hugo_learning/:2:2","tags":["hugo"],"title":"Hugo 使用教程","uri":"/hugo_learning/"},{"categories":["开发工具"],"content":"创建第一篇博客 hugo new posts/first_post.md ","date":"2022-02-16","objectID":"/hugo_learning/:2:3","tags":["hugo"],"title":"Hugo 使用教程","uri":"/hugo_learning/"},{"categories":["开发工具"],"content":"在本地启动网站 hugo serve --buildDrafts 这里是 –buildDrafts 指文档的草稿属性为真，就需要此参数，或者直接将对应markdown文件中的draft属性设置为false ","date":"2022-02-16","objectID":"/hugo_learning/:2:4","tags":["hugo"],"title":"Hugo 使用教程","uri":"/hugo_learning/"},{"categories":["开发工具"],"content":"网站高阶参数配置 复制 https://hugoloveit.com/zh-cn/theme-documentation-basics/#site-configuration 中的config.toml 文件补充到本地的对应文件当中去，注意有几个参数是重复的， ","date":"2022-02-16","objectID":"/hugo_learning/:2:5","tags":["hugo"],"title":"Hugo 使用教程","uri":"/hugo_learning/"},{"categories":["开发工具"],"content":"部署到github.io 服务器 ","date":"2022-02-16","objectID":"/hugo_learning/:3:0","tags":["hugo"],"title":"Hugo 使用教程","uri":"/hugo_learning/"},{"categories":["开发工具"],"content":"github仓库新建 新建一个项目，名字为： github账号名.github.io ","date":"2022-02-16","objectID":"/hugo_learning/:3:1","tags":["hugo"],"title":"Hugo 使用教程","uri":"/hugo_learning/"},{"categories":["开发工具"],"content":"本地对接远程服务器地址 命令 hugo --theme=LoveIt --baseUrl=\"https://swaggerwei.github.io/\" -D 可以发现本地生成了一个public文件夹 命令 cd public git init git add . git commit -m \"first commit\" git remote add origin git@github.com:SwaggerWei/SwaggerWei.github.io.git git push -u origin master tips: init 和 remote add 操作后续更改博客不需要，只有第一次建仓库的时候需要 ","date":"2022-02-16","objectID":"/hugo_learning/:3:2","tags":["hugo"],"title":"Hugo 使用教程","uri":"/hugo_learning/"},{"categories":["开发工具"],"content":"网页进入个人主页 swaggerwei.github.io tips：一般过五分钟才行 ","date":"2022-02-16","objectID":"/hugo_learning/:3:3","tags":["hugo"],"title":"Hugo 使用教程","uri":"/hugo_learning/"},{"categories":["开发工具"],"content":"团队协作分支开发模式 一个好的 github 项目一般都有多个分支：master，dev，release分支 新建分支 branch git branch branch1 切换到目标分支 git checkout branch1 在本地的branch1 中添加一个helloworld.java 文件 public class HelloWorld { public static void main(String[] args) { System.out.println(\"hello world\"); System.out.println(\"1\"); System.out.println(\"hello world\"); System.out.println(\"2\"); } } 推送到远端 git push --set-upstream origin branch1 然后远端就有了master 和 branch1 两个分支了， 其中branch1 中才有 java文件 同理，在另一个人的主机上， 创建branch2， 并写自己的HelloWorld.java文件 public class HelloWorld { public static void main(String[] args) { System.out.println(\"1\"); System.out.println(\"hello world\"); System.out.println(\"2\"); System.out.println(\"hello world\"); } } 分支的合并发布 首先切换到master分支 git checkout master 拉一下最新的远端分支情况 git pull 将branch1 分支的内容合并到master 分支上 git merge brunch1 推到远端 git push 发现master 分支 也有branch1 中的java文件了 同理合并 branch2 到 master上， 但是发现合并有冲突， 因为有两个同名的Java 文件， 但是文件内容却不一样 ","date":"2022-01-30","objectID":"/git_learning3/:1:0","tags":["git","github","gitee"],"title":"git 代码管理工具3","uri":"/git_learning3/"},{"categories":["开发工具"],"content":"使用IDEA 快速解决 git merge 当中的冲突 右键， 选择git-》resolve conflict 双击出现的 conflict 进行代码比对 手动比对之后出现 all changes have been processed 就可以了， 点击右下角apply 然后上传到远端没有出现错误则说明成功 ","date":"2022-01-30","objectID":"/git_learning3/:2:0","tags":["git","github","gitee"],"title":"git 代码管理工具3","uri":"/git_learning3/"},{"categories":["开发工具"],"content":"如何解决冲突 模拟两个人同时修改一个文件并提交到远端 克隆到两个文件夹 me 和 other git clone git@gitee.com:swagger_wei/test_gitee_git.git me git clone git@gitee.com:swagger_wei/test_gitee_git.git other other 对first.txt 内容作出修改 推送到远端 此时另一个 me 的本地仓库是不知道远程的仓库已经发生了修改的 me 对first.txt 内容作出修改 推送到远端 发现出错，因为本地 me 仓库 不知道远端仓库已经发生了变换， 所以向远端提交失败 拉取远端变化 git pull 发现有pull之后有冲突需要解决 商量之后删掉无用部分， 合并冲突 提交到远端 发现远端已经提交成功 ","date":"2022-01-27","objectID":"/git_learning2/:1:0","tags":["git","github","gitee"],"title":"git 代码管理工具2","uri":"/git_learning2/"},{"categories":["开发工具"],"content":"应用场景 团队协作开发， 避免频繁来回拷贝代码 ","date":"2022-01-17","objectID":"/git_learning/:1:0","tags":["git","github","gitee"],"title":"git 代码管理工具1","uri":"/git_learning/"},{"categories":["开发工具"],"content":"git 工作流程 克隆 Git 资源作为工作目录 在本地的工作副本上做修改操作 如果别人更改了资源可以更新资源 检查修改之后就可以向资源库推送更新 如果发现有错误则可以撤销推送，修改错误，然后重新推送 ","date":"2022-01-17","objectID":"/git_learning/:2:0","tags":["git","github","gitee"],"title":"git 代码管理工具1","uri":"/git_learning/"},{"categories":["开发工具"],"content":"工作区和、暂存区和版本库 工作区，就是本地电脑上可以看到的文件(按下Command+Shift+. 可以显示隐藏文件、文件夹，再按一次，恢复隐藏；) 暂存区，英文stage或者index，一般存放在 .git 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index） 版本库：工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。 ","date":"2022-01-17","objectID":"/git_learning/:3:0","tags":["git","github","gitee"],"title":"git 代码管理工具1","uri":"/git_learning/"},{"categories":["开发工具"],"content":"基本操作命令 当前基本状态 git status 显示当前的最新的branch； 显示没有被commit的 文件（发现.DS_Store和first文件没有被commit） 添加到暂存区 git add 文件名 .为所有文件，再次运行git status，发现所有的文件都已经被添加 添加到版本库 git commit -m \"版本提交的附带信息\" 查看当前的提交和回滚情况 git log 注：为倒叙排序， Initial commit 为默认初始化github 官网创建得到 回滚最新的一次commit git reset commit后跟的ID 回滚之前发现有一个message 为 second commit 的 commit 回滚的ID 填入倒数第二个ID， 说明回滚到倒数第二新的状态 设置邮箱号 git config --global user.email 785403310@qq.com 设置名字 git config --global user.name swagger 然后发现log 信息中的commit 信息变成了自己 推送到github服务器 git push 推送之后发现本地创建的文件已经同步到了gitee上 ","date":"2022-01-17","objectID":"/git_learning/:4:0","tags":["git","github","gitee"],"title":"git 代码管理工具1","uri":"/git_learning/"},{"categories":["JVM学习"],"content":"9 JVM 类加载机制 Java 虚拟机将 Java 源码编译为字节码之后，虚拟机便可以将字节码读取进内存，从而进行解析、运行等整个过程，这个过程我们叫：Java 虚拟机的类加载机制 JVM 虚拟机执行 class 字节码的过程可以分为七个阶段：加载、验证、准备、解析、初始化、使用、卸载。 ","date":"2022-01-07","objectID":"/jvm_learning1/:1:0","tags":["Java","算法","JVM"],"title":"JVM 学习1","uri":"/jvm_learning1/"},{"categories":["JVM学习"],"content":"9.1 加载 JVM 的主要目的是将字节码从各个位置（网络、磁盘等）转化为二进制字节流加载到内存中，接着会为这个类在 JVM 的方法区创建一个对应的 Class 对象，这个 Class 对象就是这个类各种数据的访问入口 ","date":"2022-01-07","objectID":"/jvm_learning1/:1:1","tags":["Java","算法","JVM"],"title":"JVM 学习1","uri":"/jvm_learning1/"},{"categories":["JVM学习"],"content":"9.2 验证 当 JVM 加载完 Class 字节码文件并在方法区创建对应的 Class 对象之后，JVM 便会启动对该字节码流的校验，只有符合 JVM 字节码规范的文件才能被 JVM 正确执行。这个校验过程大致可以分为下面几个类型： JVM规范校验：JVM 会对字节流进行文件格式校验，判断其是否符合 JVM 规范，是否能被当前版本的虚拟机处理。例如：文件是否是以 0x cafe bene开头，主次版本号是否在当前虚拟机处理范围之内等 代码逻辑校验：JVM 会对代码组成的数据流和控制流进行校验，确保 JVM 运行该字节码文件后不会出现致命错误。例如一个方法要求传入 int 类型的参数，但是使用它的时候却传入了一个 String 类型的参数。一个方法要求返回 String 类型的结果，但是最后却没有返回结果。代码中引用了一个名为 Apple 的类，但是你实际上却没有定义 Apple 类 ","date":"2022-01-07","objectID":"/jvm_learning1/:1:2","tags":["Java","算法","JVM"],"title":"JVM 学习1","uri":"/jvm_learning1/"},{"categories":["JVM学习"],"content":"9.3 准备 当完成字节码文件的校验之后，JVM 便会开始为类变量分配内存并初始化。这里需要注意两个关键点，即内存分配的对象以及初始化的类型 内存分配的对象。 Java 中的变量有「类变量」和「类成员变量」两种类型，「类变量」指的是被 static 修饰的变量，而其他所有类型的变量都属于「类成员变量」。在准备阶段，JVM 只会为「类变量」分配内存，而不会为「类成员变量」分配内存。「类成员变量」的内存分配需要等到初始化阶段才开始。 初始化的类型。 在准备阶段，JVM 会为类变量分配内存，并为其初始化。但是这里的初始化指的是为变量赋予 Java 语言中该数据类型的零值，而不是用户代码里初始化的值。但如果一个变量是常量（被 static final 修饰）的话，那么在准备阶段，属性便会被赋予用户希望的值 ","date":"2022-01-07","objectID":"/jvm_learning1/:1:3","tags":["Java","算法","JVM"],"title":"JVM 学习1","uri":"/jvm_learning1/"},{"categories":["JVM学习"],"content":"9.4 解析 当通过准备阶段之后，JVM 针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类引用进行解析。这个阶段的主要任务是将其在常量池中的符号引用替换成直接其在内存中的直接引用。 其实这个阶段对于我们来说也是几乎透明的，了解一下就好 ","date":"2022-01-07","objectID":"/jvm_learning1/:1:4","tags":["Java","算法","JVM"],"title":"JVM 学习1","uri":"/jvm_learning1/"},{"categories":["JVM学习"],"content":"9.5 初始化（重点） 到了初始化阶段，用户定义的 Java 程序代码才真正开始执行。在这个阶段，JVM 会根据语句执行顺序对类对象进行初始化，一般来说当 JVM 遇到下面 5 种情况的时候会触发初始化： 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类 当使用 JDK1.7 动态语言支持时，如果一个 java.lang.invoke.MethodHandle实例最后的解析结果 REF_getstatic,REF_putstatic,REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化 ","date":"2022-01-07","objectID":"/jvm_learning1/:1:5","tags":["Java","算法","JVM"],"title":"JVM 学习1","uri":"/jvm_learning1/"},{"categories":["JVM学习"],"content":"9.6 使用 当 JVM 完成初始化阶段之后，JVM 便开始从入口方法开始执行用户的程序代码。这个阶段也只是了解一下就可以 ","date":"2022-01-07","objectID":"/jvm_learning1/:1:6","tags":["Java","算法","JVM"],"title":"JVM 学习1","uri":"/jvm_learning1/"},{"categories":["JVM学习"],"content":"9.7 卸载 当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存。这个阶段也只是了解一下就可以 ","date":"2022-01-07","objectID":"/jvm_learning1/:1:7","tags":["Java","算法","JVM"],"title":"JVM 学习1","uri":"/jvm_learning1/"},{"categories":["Java学习"],"content":"6 反射 反向获取class中各种对象的信息、例如成员变量、方法、构造方法、包等等信息 ","date":"2022-01-06","objectID":"/java_learning6/:1:0","tags":["Java","算法"],"title":"Java 学习6-反射","uri":"/java_learning6/"},{"categories":["Java学习"],"content":"6.1 创建一个对象的过程 new来实例一个对象时jvm会在加载对应的class文件 jvm在本地磁盘中查找class文件 将class文件读入到内存当中，以便使用 一个class 文件只占用个同一个空间，对此用一个class再new，不会重复在内存空间中初始化 ","date":"2022-01-06","objectID":"/java_learning6/:1:1","tags":["Java","算法"],"title":"Java 学习6-反射","uri":"/java_learning6/"},{"categories":["Java学习"],"content":"6.2 获取类的字节码 //获取类的字节码 // 方法一 Student stu1 = new Student(); Class stuClass = stu1.getClass(); System.out.println(stuClass.toString()); System.out.println(stuClass.getName()); // 方法二 Class stuClass2 = Student.class; System.out.println(stuClass2.toString()); System.out.println(stuClass2 == stuClass); // 方法三 Class stuClass3 = Class.forName(\"reflectionDemo.Student\"); System.out.println(stuClass3.toString()); ","date":"2022-01-06","objectID":"/java_learning6/:1:2","tags":["Java","算法"],"title":"Java 学习6-反射","uri":"/java_learning6/"},{"categories":["Java学习"],"content":"6.3 反射得到有参数的构造函数 // 反射得到有参数构造函数 Constructor c = stuClass3.getConstructor(String.class); c.newInstance(\"wby\"); ","date":"2022-01-06","objectID":"/java_learning6/:1:3","tags":["Java","算法"],"title":"Java 学习6-反射","uri":"/java_learning6/"},{"categories":["Java学习"],"content":"6.4 反射得到私有构造函数 // 反射得到私有构造函数 Constructor c4Private = stuClass3.getDeclaredConstructor(int.class); c4Private.setAccessible(true); c4Private.newInstance(20); ","date":"2022-01-06","objectID":"/java_learning6/:1:4","tags":["Java","算法"],"title":"Java 学习6-反射","uri":"/java_learning6/"},{"categories":["Java学习"],"content":"6.5 反射得到所有的构造方法 Constructor[] c4All = stuClass3.getDeclaredConstructors(); for (Constructor c1 : c4All){ System.out.println(c1); } ","date":"2022-01-06","objectID":"/java_learning6/:1:5","tags":["Java","算法"],"title":"Java 学习6-反射","uri":"/java_learning6/"},{"categories":["Java学习"],"content":"6.6 反射得到类中的普通方法 Student p = (Student) stuClass3.newInstance(); Method m = stuClass3.getMethod(\"Student1\", String.class, int.class); m.invoke(p, \"wby\", 20); ","date":"2022-01-06","objectID":"/java_learning6/:1:6","tags":["Java","算法"],"title":"Java 学习6-反射","uri":"/java_learning6/"},{"categories":["Java学习"],"content":"6.7 反射类中的属性字段 Field f = stuClass3.getField(\"name\"); String s = (String) f.get(p); System.out.println(s); ","date":"2022-01-06","objectID":"/java_learning6/:1:7","tags":["Java","算法"],"title":"Java 学习6-反射","uri":"/java_learning6/"},{"categories":["Java学习"],"content":"6.8 应用场合、缺点 在编译时根本无法知道该对象或类可能属于哪些类，程序只依靠运行时信息来发现该对象和类的真实信息 使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码 使用反射会模糊程序内部逻辑 ","date":"2022-01-06","objectID":"/java_learning6/:1:8","tags":["Java","算法"],"title":"Java 学习6-反射","uri":"/java_learning6/"},{"categories":["Java学习"],"content":"5 泛型 泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数 ","date":"2022-01-06","objectID":"/java_learning5/:1:0","tags":["Java","算法"],"title":"Java 学习5-泛型","uri":"/java_learning5/"},{"categories":["Java学习"],"content":"5.1 泛型方法 在调用时可以接收不同类型的参数 每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开 类型参数能被用来声明返回值类型 泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（像 int、double、char 等） ","date":"2022-01-06","objectID":"/java_learning5/:1:1","tags":["Java","算法"],"title":"Java 学习5-泛型","uri":"/java_learning5/"},{"categories":["Java学习"],"content":"5.2 java 中范型标记符 E - Element (在集合中使用，因为集合中存放的是元素) T - Type（Java 类） K - Key（键） V - Value（值） N - Number（数值类型） ？ - 表示不确定的 java 类型 ","date":"2022-01-06","objectID":"/java_learning5/:1:2","tags":["Java","算法"],"title":"Java 学习5-泛型","uri":"/java_learning5/"},{"categories":["Java学习"],"content":"5.3 类型通配符 类型通配符一般是使用 ‘\u003c \u003e’ 代替具体的类型参数。例如 List 在逻辑上是 List,List 等所有 List\u003c具体类型实参\u003e 的父类 ","date":"2022-01-06","objectID":"/java_learning5/:1:3","tags":["Java","算法"],"title":"Java 学习5-泛型","uri":"/java_learning5/"},{"categories":["Java学习"],"content":"5.4 实例1 — 泛型方法 package GenericsDemo; public class genericDemo { public static \u003c E \u003e void printArray(E[] array){ for(E element : array){ System.out.println(element); } } public static void main(String[] args) { Integer[] intArray = {1 ,2, 3, 4, 5}; Double[] doubleArray = {1.1, 2.1, 3.1, 4.1}; Character[] charArray = {'a', 'b', 'c', 'd'}; System.out.println(\"整型数组元素为：\"); printArray(intArray); System.out.println(\"双精度型数组元素为：\"); printArray(doubleArray); System.out.println(\"字符型数组元素为：\"); printArray(charArray); } } ","date":"2022-01-06","objectID":"/java_learning5/:1:4","tags":["Java","算法"],"title":"Java 学习5-泛型","uri":"/java_learning5/"},{"categories":["Java学习"],"content":"5.5 泛型类 package GenericsDemo; public class genericClassDemo \u003cT\u003e{ public T val; public void add (T val){ this.val = val; } public void display(){ System.out.println(this.val); } public static void main(String[] args) { genericClassDemo\u003cInteger\u003e intTest = new genericClassDemo\u003c\u003e(); genericClassDemo\u003cString\u003e stringTest = new genericClassDemo\u003c\u003e(); intTest.add(1); stringTest.add(\"fdsafdas\"); intTest.display(); stringTest.display(); } } ","date":"2022-01-06","objectID":"/java_learning5/:1:5","tags":["Java","算法"],"title":"Java 学习5-泛型","uri":"/java_learning5/"},{"categories":["Java学习"],"content":"4 异常 异常机制是指当程序出现错误后，程序如何处理。具体来说，异常机制提供了程序退出的安全通道。当出现错误后，程序执行的流程发生改变，程序的控制权转移到异常处理器。 ","date":"2022-01-06","objectID":"/java_learning4/:1:0","tags":["Java","算法"],"title":"Java 学习4-异常","uri":"/java_learning4/"},{"categories":["Java学习"],"content":"4.1 程序错误的分类 编译错误：编译错误是因为程序没有遵循语法规则，编译程序能够自己发现并且提示我们错误的原因和位置 运行时错误：程序在执行时，运行环境发现了不能执行的操作 逻辑错误：程序没有按照预期的逻辑顺序执行。异常也就是指程序运行时发生错误，而异常处理就是对这些错误进行处理和控制 Throwable： 有两个重要的子类：Exception（异常）和 Error（错误），二者都是 Java 异常处理的重要子类，各自都包含大量子类。 异常和错误的区别是：异常能被程序本身处理，错误是无法处理 ","date":"2022-01-06","objectID":"/java_learning4/:1:1","tags":["Java","算法"],"title":"Java 学习4-异常","uri":"/java_learning4/"},{"categories":["Java学习"],"content":"4.2 运行时异常和非运行时异常 运行时异常RuntimeException（不受检异常unchecked）： RuntimeException类极其子类表示JVM在运行期间可能出现的错误。编译器不会检查此类异常，并且不要求处理异常，比如用空值对象的引用（NullPointerException）、数组下标越界（ArrayIndexOutBoundException）。此类异常属于不可查异常，一般是由程序逻辑错误引起的，在程序中可以选择捕获处理，也可以不处理 非运行时异常，（受检异常checked）： Exception中除RuntimeException极其子类之外的异常。编译器会检查此类异常，如果程序中出现此类异常，比如说IOException，必须对该异常进行处理，要么使用try-catch捕获，要么使用throws语句抛出，否则编译不通过。 ","date":"2022-01-06","objectID":"/java_learning4/:1:2","tags":["Java","算法"],"title":"Java 学习4-异常","uri":"/java_learning4/"},{"categories":["Java学习"],"content":"4.3 异常的处理 抛出异常：throw，throws throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。 throws运用于方法声明之上，用于表示当前方法不处理异常，而是提醒该方法的调用者来处理异常 捕获异常：try，catch，finally ","date":"2022-01-06","objectID":"/java_learning4/:1:3","tags":["Java","算法"],"title":"Java 学习4-异常","uri":"/java_learning4/"},{"categories":["Java学习"],"content":"4.4 实例 throw 的使用 package ExceptionDemo; public class TrowDemo { public static void main(String[] args) { int a = devide(4, 0); System.out.println(a); } public static int devide(int a, int b){ if(b==0){ throw new ArithmeticException(\"异常信息：除数不能为0\"); } return a/b; } } throws 的使用 package ExceptionDemo; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.InputStream; public class ThrowsDemo { public static void main(String[] args) throws FileNotFoundException{ try { //可能出现异常的代码段 readFile(); }catch (FileNotFoundException e){ // 异常处理 System.out.println(\"异常信息： 找不到指定路径\"); } System.out.println(\"后续处理\"); } public static void readFile() throws FileNotFoundException{ // InputStream is = new FileInputStream(\"/Users/swaggerwei/Desktop/look4Job/Java_language/notes/docks\"); InputStream is = new FileInputStream(\"/Users/swaggerwei/Desktop/notes/docks\"); } } 自定义异常类 package ExceptionDemo; /* * 自定义异常类 * 用户不存在异常 * */ public class UserNotExistException extends RuntimeException{ public UserNotExistException(){ super(); } } ","date":"2022-01-06","objectID":"/java_learning4/:1:4","tags":["Java","算法"],"title":"Java 学习4-异常","uri":"/java_learning4/"},{"categories":["Java学习"],"content":"3 容器 数据容器主要分为了两类：Collection 和 Map Collection: 存放独立元素的序列 Map：存放key-value型的元素对 ","date":"2022-01-06","objectID":"/java_learning3/:1:0","tags":["Java","算法"],"title":"Java 学习3-容器","uri":"/java_learning3/"},{"categories":["Java学习"],"content":"3.1 Collection 存放独立元素的序列 List： ArrayList LinkedList Vector Stack Set：HashSet LinkedHashSet TreeSet ","date":"2022-01-06","objectID":"/java_learning3/:1:1","tags":["Java","算法"],"title":"Java 学习3-容器","uri":"/java_learning3/"},{"categories":["Java学习"],"content":"3.2 Map：存放key-value型的元素对 HashMap： LinkedHashMap TreeMap： ConcurrentHashMap HashTable ","date":"2022-01-06","objectID":"/java_learning3/:1:2","tags":["Java","算法"],"title":"Java 学习3-容器","uri":"/java_learning3/"},{"categories":["Java学习"],"content":"3.3 Collection 和 Collections 的区别 Collection 是一个接口， Set和List等容器的父接口 Collections 是一个工具类，提供了一系列ff的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等 ","date":"2022-01-06","objectID":"/java_learning3/:1:3","tags":["Java","算法"],"title":"Java 学习3-容器","uri":"/java_learning3/"},{"categories":["Java学习"],"content":"3.4 List、Set、Map 的区别 ","date":"2022-01-06","objectID":"/java_learning3/:1:4","tags":["Java","算法"],"title":"Java 学习3-容器","uri":"/java_learning3/"},{"categories":["Java学习"],"content":"3.5 HashMap 和 HashTable的区别 存储：HashMap 允许 key 和 value 为 null，而 Hashtable 不允许。 线程安全：HashTable 是线程安全的(同一时间只允许一个线程作出改变)，而 HashMap 是非线程安全的（同一时间可能有多个线程对其进行操作）。 推荐使用：在 HashTable 的类注释可以看到，HashTable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。 ","date":"2022-01-06","objectID":"/java_learning3/:1:5","tags":["Java","算法"],"title":"Java 学习3-容器","uri":"/java_learning3/"},{"categories":["Java学习"],"content":"3.6 实例 package Java_ContainerDemo; import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set; import java.util.Collections; public class collectionDemo { public static void main(String[] args) { List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); list.add(1); list.add(2); list.add(5); list.add(3); list.add(4); list.add(6); System.out.println(list.toString()); Set\u003cInteger\u003e set = new HashSet\u003c\u003e(); set.add(1); set.add(2); System.out.println(set.toString()); // 测试Collections 工具箱 Collections.sort(list); System.out.println(list.toString()); List\u003cInteger\u003e list1 = Collections.emptyList(); System.out.println(list1.toString()); } } ","date":"2022-01-06","objectID":"/java_learning3/:1:6","tags":["Java","算法"],"title":"Java 学习3-容器","uri":"/java_learning3/"},{"categories":["Java学习"],"content":"1 继承（关键字extends） 父类中私有成员可以被继承，只是外界无法访问 父类中公共属性、方法可以被子类继承 支持单继承，多重继承（单链式继承），不支持多继承（一个类继承多个父类） 子类中的方法重写必须是父类中已有的方法 重写后再次调用父类的方法使用关键字super 例如 super.需要调用父类中的方法; super必须在子类构造器中第一句 重写与重载的区别 重写：方法名、参数跟父类方法一致，只是方法体内容不一样（运行时多态） 重载：方法名一致，形参返回值不一致（编译时多态） Java中，在创建类时，都会默认继承Object类 只要父类构造方法不发生重载（保留无参的） 子类无需改动 需要遵循先构造父类，在构造子类的顺序 ","date":"2022-01-05","objectID":"/java_learning2/:1:0","tags":["Java","算法"],"title":"Java 学习2-继承和接口","uri":"/java_learning2/"},{"categories":["Java学习"],"content":"2 接口 接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合 接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法 接口无法被实例化，但是可以被实现 ","date":"2022-01-05","objectID":"/java_learning2/:2:0","tags":["Java","算法"],"title":"Java 学习2-继承和接口","uri":"/java_learning2/"},{"categories":["Java学习"],"content":"2.1 接口与类的异同点 接口不能用于实例化对象 接口没有构造方法 接口中所有的方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法 接口不能包含成员变量，除了 static 和 final 变量 接口不是被类继承了，而是要被类实现 接口支持多继承 接口和类都可以有多个方法 文件名类似 ","date":"2022-01-05","objectID":"/java_learning2/:2:1","tags":["Java","算法"],"title":"Java 学习2-继承和接口","uri":"/java_learning2/"},{"categories":["Java学习"],"content":"2.2 实例 package objectOriented; //接口demo public interface Animal { static int height = 0; public void eat(); public void travel(); } package objectOriented; public class testAnimal_interface implements Animal{ public void eat(){ System.out.println(\"tiger eat\"); } public void travel(){ System.out.println(\"tiger travel\"); } public int numOfLegs(){ return 0; } public static void main(String[] args) { testAnimal_interface tiger = new testAnimal_interface(); tiger.eat(); tiger.travel(); System.out.println(tiger.numOfLegs()); } } ","date":"2022-01-05","objectID":"/java_learning2/:2:2","tags":["Java","算法"],"title":"Java 学习2-继承和接口","uri":"/java_learning2/"},{"categories":["Java学习"],"content":"四种内部类 成员内部类：定义在一个外部类内部，作为一个成员，称之为成员内部类，可以访问内部私有属性 静态内部类：定义在一个外部类内部，作为一个静态成员，访问外部类的静态属性，因为在进入JVM的时候静态成员变量先初始化，这个时候不同的成员变量还没有初始化 局部内部类：定义在程序执行的任何部分，和局部变量一样 匿名内部类：对象new出来之后不用赋值给一个变量，直接使用，多线程new Thread使用较多 ","date":"2022-01-05","objectID":"/java_learning2/:3:0","tags":["Java","算法"],"title":"Java 学习2-继承和接口","uri":"/java_learning2/"},{"categories":["刷题学习"],"content":"树 和 图 辨析 树的父节点和子节点之间是一条路单向可达 图的的节点之间存在多条路可达 ","date":"2021-11-24","objectID":"/lc_learning9/:1:0","tags":["算法"],"title":"刷题学习9-java 图 知识点graph","uri":"/lc_learning9/"},{"categories":["刷题学习"],"content":"基本概念 顶点 边 邻居节点：只有一条边连接的顶点 度（degree）：一个顶点有几条边，就有几度 ","date":"2021-11-24","objectID":"/lc_learning9/:2:0","tags":["算法"],"title":"刷题学习9-java 图 知识点graph","uri":"/lc_learning9/"},{"categories":["刷题学习"],"content":"图的区分 无向图：边没有方向 有向图 权重图 ","date":"2021-11-24","objectID":"/lc_learning9/:3:0","tags":["算法"],"title":"刷题学习9-java 图 知识点graph","uri":"/lc_learning9/"},{"categories":["刷题学习"],"content":"有向图的基本概念 入度：多少条边指向该顶点 出度：多少条边从这个顶点出发指向其他顶点 ","date":"2021-11-24","objectID":"/lc_learning9/:4:0","tags":["算法"],"title":"刷题学习9-java 图 知识点graph","uri":"/lc_learning9/"},{"categories":["刷题学习"],"content":"EG： 韩：入度为0；出度为2 李：入度为1；出度为1 bishi：入度为2；出度为0 饲：入度为1；出度为1 ","date":"2021-11-24","objectID":"/lc_learning9/:4:1","tags":["算法"],"title":"刷题学习9-java 图 知识点graph","uri":"/lc_learning9/"},{"categories":["刷题学习"],"content":"权重图的基本概念 边上有权重 EG：顶点为城市，边为城市之间的距离，最短路径问题 ","date":"2021-11-24","objectID":"/lc_learning9/:5:0","tags":["算法"],"title":"刷题学习9-java 图 知识点graph","uri":"/lc_learning9/"},{"categories":["刷题学习"],"content":"最短路径常用算法 贝尔曼-福特算法（Bellman Ford） 狄杰斯特拉算法（Dijkstra） DFS BFS ","date":"2021-11-24","objectID":"/lc_learning9/:6:0","tags":["算法"],"title":"刷题学习9-java 图 知识点graph","uri":"/lc_learning9/"},{"categories":["ROS 学习"],"content":"使用github安装 网址：http://www.uco.es/investiga/grupos/ava/node/26 git clone到本地之后，catkin make即可开始使用 ","date":"2021-11-20","objectID":"/aruco_learning/:1:0","tags":["ROS","抓取"],"title":"Aruco配合realsense 使用","uri":"/aruco_learning/"},{"categories":["ROS 学习"],"content":"使用apt安装 sudo apt-get install ros-kinetic-aruco-ros sudo apt-get install ros-kinetic-aruco-msgs sudo apt-get install ros-kinetic-aruco-detect sudo apt-get install ros-kinetic-aruco ","date":"2021-11-20","objectID":"/aruco_learning/:2:0","tags":["ROS","抓取"],"title":"Aruco配合realsense 使用","uri":"/aruco_learning/"},{"categories":["ROS 学习"],"content":"测试使用 roslaunch aruco_ros single.launch 如果没有报错，说明成功 ","date":"2021-11-20","objectID":"/aruco_learning/:3:0","tags":["ROS","抓取"],"title":"Aruco配合realsense 使用","uri":"/aruco_learning/"},{"categories":["ROS 学习"],"content":"网址生成二维码，及其相关信息 http://chev.me/arucogen/ 图片的风格类型 marker ID —–582 尺寸大小（注意这里的单位为mm）—-34mm ","date":"2021-11-20","objectID":"/aruco_learning/:4:0","tags":["ROS","抓取"],"title":"Aruco配合realsense 使用","uri":"/aruco_learning/"},{"categories":["ROS 学习"],"content":"修改launch文件夹中的single.launch文件 更改camera_info为realsense发布的相机内参话题 \u003cremap from=\"/camera_info\" to=\"/camera/color/camera_info\" /\u003e 更改image \u003cremap from=\"/image\" to=\"/camera/color/image_raw\" /\u003e 更改camera_frame \u003cparam name=\"camera_frame\" value=\"/camera_link\"/\u003e 更改Marker ID; marker size \u003carg name=\"markerId\" default=\"582\"/\u003e \u003carg name=\"markerSize\" default=\"0.034\"/\u003e \u003c!-- in m --\u003e ","date":"2021-11-20","objectID":"/aruco_learning/:5:0","tags":["ROS","抓取"],"title":"Aruco配合realsense 使用","uri":"/aruco_learning/"},{"categories":["ROS 学习"],"content":"开始测试 启动realsense节点 roslaunch realsense2_camera rs_camera.launch 启动single.launch 文件 roslaunch aruco_ros single.launch 使用image_view观察识别效果 rosrun image_view image_view image:=/aruco_single/result 查看位姿 rostopic echo /aruco_single/pose 参考：https://blog.csdn.net/qq_34935373/article/details/105098244 ","date":"2021-11-20","objectID":"/aruco_learning/:6:0","tags":["ROS","抓取"],"title":"Aruco配合realsense 使用","uri":"/aruco_learning/"},{"categories":["pointNetGPD"],"content":"资源相关 项目地址 源码地址 论文地址 ","date":"2021-11-18","objectID":"/pointnetgpd_reading/:1:0","tags":["抓取","pointNet"],"title":"1-PointNetGPD论文阅读","uri":"/pointnetgpd_reading/"},{"categories":["pointNetGPD"],"content":"输入输出 input： 点云数据 output： 抓取位姿（6D）(parallel-jaw)方式 ","date":"2021-11-18","objectID":"/pointnetgpd_reading/:2:0","tags":["抓取","pointNet"],"title":"1-PointNetGPD论文阅读","uri":"/pointnetgpd_reading/"},{"categories":["pointNetGPD"],"content":"contribution 网络轻量化 预测夹爪的6D位姿 贡献一个真实的点云抓取数据集 网络模型可以准确的分析出夹爪和抓取物体的几何信息，在点云数据很粗糙的情况下准确度也有保证 ","date":"2021-11-18","objectID":"/pointnetgpd_reading/:3:0","tags":["抓取","pointNet"],"title":"1-PointNetGPD论文阅读","uri":"/pointnetgpd_reading/"},{"categories":["pointNetGPD"],"content":"motivation 现如今的抓取预测方式都是依据RGB和Depth 结合的方式，很少考虑几何信息 PointNet 直接在点云做分割和分类的效果非常好 ","date":"2021-11-18","objectID":"/pointnetgpd_reading/:4:0","tags":["抓取","pointNet"],"title":"1-PointNetGPD论文阅读","uri":"/pointnetgpd_reading/"},{"categories":["pointNetGPD"],"content":"pipeline ","date":"2021-11-18","objectID":"/pointnetgpd_reading/:5:0","tags":["抓取","pointNet"],"title":"1-PointNetGPD论文阅读","uri":"/pointnetgpd_reading/"},{"categories":["pointNetGPD"],"content":"抓取实验评价指标 Meticulous grasp quality scores 包括如下两部分 force-closure GWS analysis ","date":"2021-11-18","objectID":"/pointnetgpd_reading/:6:0","tags":["抓取","pointNet"],"title":"1-PointNetGPD论文阅读","uri":"/pointnetgpd_reading/"},{"categories":["ROS 学习"],"content":"基本概念 urdf 文件， 定义机器人的结构 用于机器人的仿真、 可视化、 tf ROS 的中包含一个urdf包，用来解析urdf文件 ","date":"2021-11-01","objectID":"/ros_learning6/:1:0","tags":["ROS"],"title":"6-URDF","uri":"/ros_learning6/"},{"categories":["ROS 学习"],"content":"描述机器人零部件和零部件之间的关系 link 每个零部件都有自己的link（xyz三个轴） joint 描述两个零部件连接的关节 urdf文件中定义两个link 之间必有一个joint ","date":"2021-11-01","objectID":"/ros_learning6/:2:0","tags":["ROS"],"title":"6-URDF","uri":"/ros_learning6/"},{"categories":["ROS 学习"],"content":"urdf 文件的具体撰写 ","date":"2021-11-01","objectID":"/ros_learning6/:3:0","tags":["ROS"],"title":"6-URDF","uri":"/ros_learning6/"},{"categories":["ROS 学习"],"content":"tf in python 的相关数据类型 tuple list numpy array 四种方式通用 EG： ","date":"2021-11-01","objectID":"/ros_learning5/:1:0","tags":["ROS"],"title":"5-tf in python ","uri":"/ros_learning5/"},{"categories":["ROS 学习"],"content":"四元数、矩阵、欧拉角之间的转换 ","date":"2021-11-01","objectID":"/ros_learning5/:2:0","tags":["ROS"],"title":"5-tf in python ","uri":"/ros_learning5/"},{"categories":["ROS 学习"],"content":"tf.TransformListener 类 构造函数为无参数 tips：查看相对的tf，方法中注意时间要填写为time(0), 不能使用time(now)获取当前时间，因为获取当前的tf消息是空的，需要等待一下才有消息 ","date":"2021-11-01","objectID":"/ros_learning5/:3:0","tags":["ROS"],"title":"5-tf in python ","uri":"/ros_learning5/"},{"categories":["ROS 学习"],"content":"tf.transformBroadcaster 类 构造函数为无参数 ","date":"2021-11-01","objectID":"/ros_learning5/:4:0","tags":["ROS"],"title":"5-tf in python ","uri":"/ros_learning5/"},{"categories":["ROS 学习"],"content":"tf相关指令 根据当前的tf tree 绘制一个PDF图: 接收/tf 消息五秒，然后生成一个树图 rosrun tf view_frames 查看当前的tf tree： 动态显示 rosrun rqt_tf_tree rqt_tf_tree 查看两个frame 之间的变化关系 rosrun tf tf_echo [reference_frame] [target_frame] ","date":"2021-11-01","objectID":"/ros_learning5/:5:0","tags":["ROS"],"title":"5-tf in python ","uri":"/ros_learning5/"},{"categories":["ROS 学习"],"content":"TransFrom 坐标变换（位置+姿态） 坐标系数据的维护工具 ","date":"2021-11-01","objectID":"/ros_learning4/:1:0","tags":["ROS"],"title":"4-tf介绍","uri":"/ros_learning4/"},{"categories":["ROS 学习"],"content":"抓取场景下的坐标转换 涉及的坐标系：基坐标系、摄像头坐标系、机械臂末端坐标系 物体坐标相对于摄像头坐标系-》物体坐标相对于基坐标系 物体坐标相对于夹爪末端坐标系 ","date":"2021-11-01","objectID":"/ros_learning4/:2:0","tags":["ROS"],"title":"4-tf介绍","uri":"/ros_learning4/"},{"categories":["ROS 学习"],"content":"ROS中的tf 一个部件是一个link， 会发布自己的tf消息 与之相连的link， 会接收其tf消息完成连接转化工作（joint工作） ROS中tf表示的意思：标准 话题 工具 接口 ","date":"2021-11-01","objectID":"/ros_learning4/:3:0","tags":["ROS"],"title":"4-tf介绍","uri":"/ros_learning4/"},{"categories":["ROS 学习"],"content":"tf消息格式 ","date":"2021-11-01","objectID":"/ros_learning4/:4:0","tags":["ROS"],"title":"4-tf介绍","uri":"/ros_learning4/"},{"categories":["ROS 学习"],"content":"两个frame之间的tf变化 TransformedStamped.msg seq-序号 stamp-时间戳 frame_id-本frame的id child_frame_id-子frame的id 位置 旋转位姿 很多个节点向/tf 话题发送消息， 形成tf树 ","date":"2021-11-01","objectID":"/ros_learning4/:4:1","tags":["ROS"],"title":"4-tf介绍","uri":"/ros_learning4/"},{"categories":["ROS 学习"],"content":"Client Library 提供ROS编程的库 例如建立node，发布消息，调用服务 提供了如下几种client library ：roscpp、rospy、roslisp ","date":"2021-11-01","objectID":"/ros_learning3/:1:0","tags":["ROS"],"title":"3-roscpp介绍","uri":"/ros_learning3/"},{"categories":["ROS 学习"],"content":"rospy的组成 Node Topic Service Param Time ","date":"2021-11-01","objectID":"/ros_learning3/:2:0","tags":["ROS"],"title":"3-roscpp介绍","uri":"/ros_learning3/"},{"categories":["ROS 学习"],"content":"rospy-Node 相关 ","date":"2021-11-01","objectID":"/ros_learning3/:3:0","tags":["ROS"],"title":"3-roscpp介绍","uri":"/ros_learning3/"},{"categories":["ROS 学习"],"content":"rospy-topic 相关 wait_for_message: 只接收一次消息，不是一直处理消息 publisher-》init: 当中的queue_size, 设置为1， 为异步通信方式， None为同步通信方式 ","date":"2021-11-01","objectID":"/ros_learning3/:4:0","tags":["ROS"],"title":"3-roscpp介绍","uri":"/ros_learning3/"},{"categories":["ROS 学习"],"content":"topic_demo ","date":"2021-11-01","objectID":"/ros_learning3/:5:0","tags":["ROS"],"title":"3-roscpp介绍","uri":"/ros_learning3/"},{"categories":["ROS 学习"],"content":"功能描述： 两个node，一个发布模拟的GPS消息（格式为自定义，包括坐标和工作状态） 另一个node接收并处理该信息（计算到原点的距离） ","date":"2021-11-01","objectID":"/ros_learning3/:5:1","tags":["ROS"],"title":"3-roscpp介绍","uri":"/ros_learning3/"},{"categories":["ROS 学习"],"content":"步骤 建立一个package cd ~/catkin_ws/src catkin_create_pkg topic_demo roscpp rospy std_msg 定义自己的msg文件 cd topic_demo/ mkdir msg cd msg gedit gps.msg 文件内容如下 编写talker.py 编写listener.py 修改CmakeList.txt; package.xml文件 最后执行catkin_make，编译完成之后会在如下路径下生成gps的头文件 使用rosrun运行talker.py和listener.py文件 ","date":"2021-11-01","objectID":"/ros_learning3/:5:2","tags":["ROS"],"title":"3-roscpp介绍","uri":"/ros_learning3/"},{"categories":["ROS 学习"],"content":"ROS常用工具 仿真：Gazebo 调试、可视化：Rviz、rqt 命令行工具：rostopic、roslaunch、rosbag 专用工具：Moveit ","date":"2021-10-28","objectID":"/ros_learning2/:1:0","tags":["ROS"],"title":"2-ROS常用工具","uri":"/ros_learning2/"},{"categories":["ROS 学习"],"content":"Gazebo 机器人仿真工具 ODE、Bullet 等物理引擎 动力学、导航、感知等任务的模拟 ","date":"2021-10-28","objectID":"/ros_learning2/:2:0","tags":["ROS"],"title":"2-ROS常用工具","uri":"/ros_learning2/"},{"categories":["ROS 学习"],"content":"Gazebo 操作 鼠标左键平移， 中键旋转 左侧world：各类物理模型及其属性 左侧insert：可以插入各种模型 ","date":"2021-10-28","objectID":"/ros_learning2/:3:0","tags":["ROS"],"title":"2-ROS常用工具","uri":"/ros_learning2/"},{"categories":["ROS 学习"],"content":"RViz 方便调试和监控的工具 ADD 添加监视器（RbotModel、Laserscan、PointCloud、Camera等） 选中监视器中的topic，进行消息的接收，才能进行可视化 ","date":"2021-10-28","objectID":"/ros_learning2/:4:0","tags":["ROS"],"title":"2-ROS常用工具","uri":"/ros_learning2/"},{"categories":["ROS 学习"],"content":"rqt可视化命令行工具 rqt_graph：显示通信架构（节点和话题的发布状态） rqt_plot：绘制曲线 rqt_console：查看日志 ","date":"2021-10-28","objectID":"/ros_learning2/:5:0","tags":["ROS"],"title":"2-ROS常用工具","uri":"/ros_learning2/"},{"categories":["ROS 学习"],"content":"rosbag ROS命令行工具 记录和回放数据流 回放会将记录的消息重新发布，单独使用回放之前需要roscoe启动master节点 ","date":"2021-10-28","objectID":"/ros_learning2/:6:0","tags":["ROS"],"title":"2-ROS常用工具","uri":"/ros_learning2/"},{"categories":["ROS 学习"],"content":"通信方式 topic service parameter server actionlib ","date":"2021-10-28","objectID":"/ros_learning1/:1:0","tags":["ROS"],"title":"1-ROS通信方式","uri":"/ros_learning1/"},{"categories":["ROS 学习"],"content":"topic 通信方式 异步通信方式 Node间通过publish-subscribe的方式进行通信 topic 发布节点只管发布， 接收节点只管接收 特点 异步通信方式 对于同一个topic可以有多个发送者（例如tf，和rosout），也可以有多个接收者 ","date":"2021-10-28","objectID":"/ros_learning1/:2:0","tags":["ROS"],"title":"1-ROS通信方式","uri":"/ros_learning1/"},{"categories":["ROS 学习"],"content":"Message topic 内容的数据类型—》类 定义在.msg文件当中 包括的类型 ","date":"2021-10-28","objectID":"/ros_learning1/:3:0","tags":["ROS"],"title":"1-ROS通信方式","uri":"/ros_learning1/"},{"categories":["ROS 学习"],"content":"topic 相关命令 列出所有的topic rostopic list 显示某个topic的属性信息 rostopic info /topic_name topic内容 rostopic echo /topic_name 向某个topic发布内容 rostopic pub /topic_name ... 列出所有msg rosmsg list 显示某个msg 的内容 rosmsg show /msg_name ","date":"2021-10-28","objectID":"/ros_learning1/:4:0","tags":["ROS"],"title":"1-ROS通信方式","uri":"/ros_learning1/"},{"categories":["刷题学习"],"content":"基本定义 堆就是一种二叉树结构—完全二叉树 完全二叉树： 1 每个父节点，最多只有两个孩子 2 从上到下，从左到右依次填满 ","date":"2021-10-18","objectID":"/lc_learning8/:1:0","tags":["算法"],"title":"刷题学习8-java 堆 知识点Heap","uri":"/lc_learning8/"},{"categories":["刷题学习"],"content":"堆需要满足的条件： 是一个完全二叉树 每个节点都大于等于孩子节点（最大堆）或者每个每个节点都小于等于孩子节点（最小堆） ","date":"2021-10-18","objectID":"/lc_learning8/:2:0","tags":["算法"],"title":"刷题学习8-java 堆 知识点Heap","uri":"/lc_learning8/"},{"categories":["刷题学习"],"content":"最大堆和最小堆的辨析 根节点：堆顶元素 ","date":"2021-10-18","objectID":"/lc_learning8/:3:0","tags":["算法"],"title":"刷题学习8-java 堆 知识点Heap","uri":"/lc_learning8/"},{"categories":["刷题学习"],"content":"堆常见操作的时间复杂度 访问 Access X 搜索 Search O(1) 堆顶元素 添加 Insert O(logN) 为了满足最大堆或者最小堆的定义，需要进行父节点互换 删除 Delete O(logN) 删除堆顶元素 ","date":"2021-10-18","objectID":"/lc_learning8/:4:0","tags":["算法"],"title":"刷题学习8-java 堆 知识点Heap","uri":"/lc_learning8/"},{"categories":["刷题学习"],"content":"堆化操作的时间复杂度 堆化操作的时间复杂度是O(N)的原理 堆化：将一组无序的数加入到堆里去 堆化：将一组无序的数转化为完全二叉树，然后将完全二叉树转化为最大堆或者最小堆的操作 ","date":"2021-10-18","objectID":"/lc_learning8/:5:0","tags":["算法"],"title":"刷题学习8-java 堆 知识点Heap","uri":"/lc_learning8/"},{"categories":["刷题学习"],"content":"Eg： 有一组数：[10, 9, 7, 12, 16, 8, 5] 构建完全二叉树，结构是唯一的，只需要将数组从头到尾遍历一遍 O(N) 转化为 最小堆｜最大堆 O(N) 整体的时间复杂度为 O(N) ","date":"2021-10-18","objectID":"/lc_learning8/:5:1","tags":["算法"],"title":"刷题学习8-java 堆 知识点Heap","uri":"/lc_learning8/"},{"categories":["刷题学习"],"content":"堆的常见操作 创建堆（最大堆｜最小堆） PriorityQueue\u003cInteger\u003e minHeap = new PriorityQueue\u003c\u003e(); PriorityQueue\u003cInteger\u003e maxHeap = new PriorityQueue\u003c\u003e(Collections.reverseOrder()); 添加元素 minHeap.add(10); minHeap.add(8); minHeap.add(9); minHeap.add(11); minHeap.add(2); maxHeap.add(10); maxHeap.add(8); maxHeap.add(9); maxHeap.add(11); maxHeap.add(2); 获取堆顶元素 System.out.println(minHeap.peek()); System.out.println(maxHeap.peek()); 读取堆顶元素并出堆 minHeap.poll(); System.out.println(minHeap.toString()); maxHeap.poll(); System.out.println(maxHeap.toString()); 堆的长度 System.out.println(minHeap.size()); System.out.println(maxHeap.size()); 堆的遍历 while (!minHeap.isEmpty()){ minHeap.poll(); System.out.println(minHeap.toString()); } while (!maxHeap.isEmpty()){ maxHeap.poll(); System.out.println(maxHeap.toString()); } ","date":"2021-10-18","objectID":"/lc_learning8/:6:0","tags":["算法"],"title":"刷题学习8-java 堆 知识点Heap","uri":"/lc_learning8/"},{"categories":["刷题学习"],"content":"leetcode练习题 215 数组中第k个最大元素 kth largest element in a array 692 前k个高频单词 top k frequent words ","date":"2021-10-18","objectID":"/lc_learning8/:7:0","tags":["算法"],"title":"刷题学习8-java 堆 知识点Heap","uri":"/lc_learning8/"},{"categories":["刷题学习"],"content":"树的基本概念 描述的是节点之间的父子关系 tips： 成环的结构不可能成为树， 因为无法确定父子关系 ","date":"2021-10-16","objectID":"/lc_learning7/:1:0","tags":["算法"],"title":"刷题学习7-java 树知识点Tree","uri":"/lc_learning7/"},{"categories":["刷题学习"],"content":"重要的名词 节点 根节点（开始的节点，没有父节点，具有唯一性） 叶子节点（没有孩子的节点） ","date":"2021-10-16","objectID":"/lc_learning7/:2:0","tags":["算法"],"title":"刷题学习7-java 树知识点Tree","uri":"/lc_learning7/"},{"categories":["刷题学习"],"content":"高度、深度、层 概念辨析 高度：从叶子向根看，从0开始计数 深度：从根向叶子看，从0开始计数 层： 从根向叶子看，从1开始计数 ","date":"2021-10-16","objectID":"/lc_learning7/:3:0","tags":["算法"],"title":"刷题学习7-java 树知识点Tree","uri":"/lc_learning7/"},{"categories":["刷题学习"],"content":"二叉树 普通二叉树：每个节点最多两个孩子 满二叉树：除了叶子节点，每个节点都有左右两个孩子，且所有的叶子节点都在同一层 完全二叉树：从树的根节点，从上到下，从左到右，依次填满节点形成二叉树 tips：如果一个二叉树是满二叉树，那么一定是完全二叉树，反过来不一定 ","date":"2021-10-16","objectID":"/lc_learning7/:4:0","tags":["算法"],"title":"刷题学习7-java 树知识点Tree","uri":"/lc_learning7/"},{"categories":["刷题学习"],"content":"遍历 前序遍历： 根节点、左子树、右子树 中序遍历： 左子树、根节点、右子树 后序遍历： 左子树、右子树，根节点 EG: 前序遍历：A B D E C F G 中序遍历：D B E A F C G 后序遍历：D E B F G C A ","date":"2021-10-16","objectID":"/lc_learning7/:5:0","tags":["算法"],"title":"刷题学习7-java 树知识点Tree","uri":"/lc_learning7/"},{"categories":["刷题学习"],"content":"leetcode 练习题 144 Binary Tree Preorder Traversal 前序遍历 94 Binary Tree Inorder Traversal 中序遍历 145 Binary Tree Postorder Traversal 后序遍历 ","date":"2021-10-16","objectID":"/lc_learning7/:6:0","tags":["算法"],"title":"刷题学习7-java 树知识点Tree","uri":"/lc_learning7/"},{"categories":["kinova"],"content":"我的环境 ubuntu 16.04 64bits ROS Kinetic ","date":"2021-10-14","objectID":"/kinova_ros/:1:0","tags":["ROS","kinova"],"title":"4-Kinova_ros 配置文档","uri":"/kinova_ros/"},{"categories":["kinova"],"content":"Kinova SDK 下载 进入kinova官网 kinovarobotics.com 找到右上角resource， 根据自己kinova机械臂的名称找到对应的资源库，我的是Gen2 选择对应自由度的机械臂，然后找到SDK下载 ","date":"2021-10-14","objectID":"/kinova_ros/:2:0","tags":["ROS","kinova"],"title":"4-Kinova_ros 配置文档","uri":"/kinova_ros/"},{"categories":["kinova"],"content":"Kinova SDK 安装 解压SDK, 切换到目录中 打开终端 cd Ubuntu/16_04/64\\ bits/ 使用.sh文件安装 sudo bash installSDK64.sh 一直下一步即可，　一般是默认安装在opt目录下 ","date":"2021-10-14","objectID":"/kinova_ros/:3:0","tags":["ROS","kinova"],"title":"4-Kinova_ros 配置文档","uri":"/kinova_ros/"},{"categories":["kinova"],"content":"SDK DevelopmentCenter GUI 简单使用 切换到安装目录下 cd /opt/JACO-SDK/GUI/ 运行GUI文件 sudo ./DevelopmentCenter.sh 右上角检测到序列号，　且使用Virtual joystick可以使用说明成功 ","date":"2021-10-14","objectID":"/kinova_ros/:4:0","tags":["ROS","kinova"],"title":"4-Kinova_ros 配置文档","uri":"/kinova_ros/"},{"categories":["kinova"],"content":"Kinova-ros 安装 创建工作空间 mkdir \"~/catkin_ws/src/\" 切换到工作空间 cd ~/catkin_ws/src/ 下载 git clone https://github.com/Kinovarobotics/kinova-ros.git kinova-ros 可以导入到gitee 再下载 编译 cd ~/catkin_ws/ catkin_make 更改bashrc文件 source ~/catkin_ws/devel/setup.bash 此句话加入到bashrc中 ","date":"2021-10-14","objectID":"/kinova_ros/:5:0","tags":["ROS","kinova"],"title":"4-Kinova_ros 配置文档","uri":"/kinova_ros/"},{"categories":["kinova"],"content":"机器人唤醒 TIPS： 注意ROS节点和Development Center不能一起打开 source source devel/setup.bash bringup机械臂 roslaunch kinova_bringup kinova_robot.launch kinova_robotType:=j2n7s300 ","date":"2021-10-14","objectID":"/kinova_jaco2_7dof/:1:0","tags":["ROS","kinova"],"title":"3-kinova jaco2 7dof 机械臂基础控制","uri":"/kinova_jaco2_7dof/"},{"categories":["kinova"],"content":"cartesian 控制模式 重新起一个终端 cd ~/catkin_ws source devel/setup.bash 运行pose_action_client.py 文件 tips： pose参数解释，机器人方向看手 a.非相对（指定6D位置）移动， 不带-r参数 （小）左（大）右 （小）高（大）低 （大）前（小）后 rosrun kinova_demo pose_action_client.py -v j2n7s300 mdeg -- -0.193846275806 -0.265829235315 0.505497992039 94.2 -43.2 -167.1 rosrun kinova_demo pose_action_client.py -v j2n7s300 mdeg -- -0.193846275806 -0.265829235315 0.705497992039 94.2 -43.2 -167.1 rosrun kinova_demo pose_action_client.py -v j2n7s300 mdeg -- -0.193846275806 -0.465829235315 0.505497992039 94.2 -43.2 -167.1 rosrun kinova_demo pose_action_client.py -v j2n7s300 mdeg -- -0.393846275806 -0.265829235315 0.505497992039 94.2 -43.2 -167.1 rosrun kinova_demo pose_action_client.py -v j2n7s300 mdeg -- -0.193846275806 -0.265829235315 0.705497992039 94.2 -43.2 -167.1 b.相对（在当前6D位置基础上）移动，带-r参数 rosrun kinova_demo pose_action_client.py -v -r j2n7s300 mdeg -- 0.01 0 0 0 10 10 ","date":"2021-10-14","objectID":"/kinova_jaco2_7dof/:2:0","tags":["ROS","kinova"],"title":"3-kinova jaco2 7dof 机械臂基础控制","uri":"/kinova_jaco2_7dof/"},{"categories":["kinova"],"content":"手指控制 参数 robotType： j2n7s300 手指移动模式： percent 手指打开程度： 100 100 100（完全闭合） ； 0 0 0（完全打开） 控制命令 rosrun kinova_demo fingers_action_client.py j2n7s300 percent -- 100 100 100 rosrun kinova_demo fingers_action_client.py j2n7s300 percent -- 0 0 0 ","date":"2021-10-14","objectID":"/kinova_jaco2_7dof/:3:0","tags":["ROS","kinova"],"title":"3-kinova jaco2 7dof 机械臂基础控制","uri":"/kinova_jaco2_7dof/"},{"categories":["刷题学习"],"content":"特点 无序 不重复 注重自己独一无二的特性 ","date":"2021-10-13","objectID":"/lc_learning6/:1:0","tags":["算法"],"title":"刷题学习6-java集合Set学习","uri":"/lc_learning6/"},{"categories":["刷题学习"],"content":"主要作用 检查某一个元素是否存在 有无重复元素 ","date":"2021-10-13","objectID":"/lc_learning6/:2:0","tags":["算法"],"title":"刷题学习6-java集合Set学习","uri":"/lc_learning6/"},{"categories":["刷题学习"],"content":"Set的种类 HashSet 主要使用 LinkListSet TreeSet ","date":"2021-10-13","objectID":"/lc_learning6/:3:0","tags":["算法"],"title":"刷题学习6-java集合Set学习","uri":"/lc_learning6/"},{"categories":["刷题学习"],"content":"将一个元素加入到HashSet过程原理 取得元素 通过哈希函数得到哈希值 通过哈希值在哈希表中寻找，如果表中没有此元素，就直接存入到哈希表中 如果有元素，然后进行对比 如果已有元素和当前元素相等，则不做操作 如果不相等，则发生哈希冲突（使用链表方法解决） ","date":"2021-10-13","objectID":"/lc_learning6/:4:0","tags":["算法"],"title":"刷题学习6-java集合Set学习","uri":"/lc_learning6/"},{"categories":["刷题学习"],"content":"哈希集合的操作的时间复杂度 访问：不存在 搜索：无哈希冲突O(1) ，有哈希冲突O(k) —k为冲突元素的个数 插入：无哈希冲突O(1) ，有哈希冲突O(k) —k为冲突元素的个数 删除：无哈希冲突O(1) ，有哈希冲突O(k) —k为冲突元素的个数 ","date":"2021-10-13","objectID":"/lc_learning6/:5:0","tags":["算法"],"title":"刷题学习6-java集合Set学习","uri":"/lc_learning6/"},{"categories":["刷题学习"],"content":"哈希集合的常用操作 创建集合 HashSet\u003cInteger\u003e set = new HashSet\u003c\u003e(); 添加元素 set.add(10); System.out.println(set.add(10)); // 检测到元素重复，添加不成功 add 会返回一个boolean值 set.add(3); set.add(5); set.add(2); set.add(2); System.out.println(set.toString()); 查询元素 System.out.println(set.contains(2)); 删除元素 set.remove(2); System.out.println(set.toString()); 长度 System.out.println(set.size()); ","date":"2021-10-13","objectID":"/lc_learning6/:6:0","tags":["算法"],"title":"刷题学习6-java集合Set学习","uri":"/lc_learning6/"},{"categories":["刷题学习"],"content":"leetcode 练习题 217 Contains Duplicate 存在重复元素 705 Design Hashset 设计哈希集合 ","date":"2021-10-13","objectID":"/lc_learning6/:7:0","tags":["算法"],"title":"刷题学习6-java集合Set学习","uri":"/lc_learning6/"},{"categories":["yoloV5"],"content":"标注方法 自己获取的数据集，人工进行标注（全人工） 自己获取的数据集，首先使用训练好的网络标注一遍，然后手动进行微调（半人工） 仿真数据集（GAN网络来生成自己的数据集– synthetic data） ","date":"2021-10-10","objectID":"/yolov5_owndatasettrain/:1:0","tags":["yoloV5","python","pytorch"],"title":"3-如何制作和训练自己的数据集（YoloV5）","uri":"/yolov5_owndatasettrain/"},{"categories":["yoloV5"],"content":"标注工具 CVAT（需要安装） makesense.ai（在线标注工具） ","date":"2021-10-10","objectID":"/yolov5_owndatasettrain/:2:0","tags":["yoloV5","python","pytorch"],"title":"3-如何制作和训练自己的数据集（YoloV5）","uri":"/yolov5_owndatasettrain/"},{"categories":["yoloV5"],"content":"makesense.ai 标注过程 输入图片 选择Object Detection 创建自己的分类 根据自己的分类开始进行标注（标注的时候也可以使用action中的load models进行半人工标注） 导出文件（action-》export annotation-》yolo format） ","date":"2021-10-10","objectID":"/yolov5_owndatasettrain/:3:0","tags":["yoloV5","python","pytorch"],"title":"3-如何制作和训练自己的数据集（YoloV5）","uri":"/yolov5_owndatasettrain/"},{"categories":["yoloV5"],"content":"文件组织过程 将images和labels分别放入对应的文件夹中 参照coco.yaml， 写自己数据集的配置 # train and val data as 1) directory: path/images/, 2) file: path/images.txt, or 3) list: [path1/images/, path2/images/]train:mydata/images/trainval:mydata/images/train# number of classesnc:3# class namesnames:['person','car','bike'] 修改train.py中的--data参数 parser.add_argument('--data', type=str, default='mydata/mydata.yaml', help='data.yaml path') 运行train.py开始训练 使用detect测试自己训练的模型 修改detect 中的权重文件为自己训练的模型（一般问train当中最新的那个exp） ","date":"2021-10-10","objectID":"/yolov5_owndatasettrain/:4:0","tags":["yoloV5","python","pytorch"],"title":"3-如何制作和训练自己的数据集（YoloV5）","uri":"/yolov5_owndatasettrain/"},{"categories":["yoloV5"],"content":"tips pycharm左侧工程目录文件个数太多了会占用大量的资源（需要检索） 可以右键文件夹，在此处选择exclude， 则可以节省资源 需要有路径的地方，只要路径正确， exclude的文件依然可以找到，知识在目录视图中找不到 ","date":"2021-10-10","objectID":"/yolov5_owndatasettrain/:5:0","tags":["yoloV5","python","pytorch"],"title":"3-如何制作和训练自己的数据集（YoloV5）","uri":"/yolov5_owndatasettrain/"},{"categories":["刷题学习"],"content":"基础定义 键值对：key：value 例如学号姓名： 1：张三 2：李四 3：王五 查找元素的方式不需要从头遍历到尾，直接通过键（key）来进行查找，时间复杂度低 ","date":"2021-10-08","objectID":"/lc_learning5/:1:0","tags":["算法"],"title":"刷题学习5-java 哈希表学习-散列表","uri":"/lc_learning5/"},{"categories":["刷题学习"],"content":"语言的使用 Java—HashMap python—-字典 ","date":"2021-10-08","objectID":"/lc_learning5/:2:0","tags":["算法"],"title":"刷题学习5-java 哈希表学习-散列表","uri":"/lc_learning5/"},{"categories":["刷题学习"],"content":"哈希查找对应元素的机制 ","date":"2021-10-08","objectID":"/lc_learning5/:3:0","tags":["算法"],"title":"刷题学习5-java 哈希表学习-散列表","uri":"/lc_learning5/"},{"categories":["刷题学习"],"content":"哈希碰撞 两个不同的key通过同一个哈希函数，得到相同的内存地址 ","date":"2021-10-08","objectID":"/lc_learning5/:4:0","tags":["算法"],"title":"刷题学习5-java 哈希表学习-散列表","uri":"/lc_learning5/"},{"categories":["刷题学习"],"content":"哈希碰撞解决方法 ","date":"2021-10-08","objectID":"/lc_learning5/:5:0","tags":["算法"],"title":"刷题学习5-java 哈希表学习-散列表","uri":"/lc_learning5/"},{"categories":["刷题学习"],"content":"拉链法 当数组上的某个节点发生Hash冲突时,就把这个节点作为头节点,将新插入的节点挂到这个节点上,形成一个连表,新来的节点通过尾插的形式逐个插入节点 jdk1.8 之后采用链表或者红黑树的方法进行解决 优点：处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短 优点：拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况 优点：在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可 ","date":"2021-10-08","objectID":"/lc_learning5/:5:1","tags":["算法"],"title":"刷题学习5-java 哈希表学习-散列表","uri":"/lc_learning5/"},{"categories":["刷题学习"],"content":"开放地址法 如果当前位置发生了Hash冲突,就在数据里找寻其他没有冲突的位置存放这个数据 ","date":"2021-10-08","objectID":"/lc_learning5/:5:2","tags":["算法"],"title":"刷题学习5-java 哈希表学习-散列表","uri":"/lc_learning5/"},{"categories":["刷题学习"],"content":"再散列法 我们可以再弄另外一个Hash函数，对落在同一个位置的关键字进行再次的Hash ","date":"2021-10-08","objectID":"/lc_learning5/:5:3","tags":["算法"],"title":"刷题学习5-java 哈希表学习-散列表","uri":"/lc_learning5/"},{"categories":["刷题学习"],"content":"各种操作的时间复杂度 访问 X 搜索（无哈希碰撞） O(1) 搜索（有哈希碰撞） O(K) 链表遍历时经过了k个元素 插入 O(1) 删除 O(1) ","date":"2021-10-08","objectID":"/lc_learning5/:6:0","tags":["算法"],"title":"刷题学习5-java 哈希表学习-散列表","uri":"/lc_learning5/"},{"categories":["刷题学习"],"content":"Java 哈希表的常用操作 创建哈希表 // 通过字符串数组创建哈希表 String[] hashTable = new String[4]; // 通过HashMap 库创建哈希表 HashMap\u003cInteger, String\u003e hashMap = new HashMap\u003c\u003e(); 添加 // 添加 hashTable[1] = \"张三\"; hashTable[2] = \"李四\"; hashTable[3] = \"王五\"; // 使用数组的方式将其输出 for(int i = 0; i\u003chashTable.length-1; i++){ System.out.println((i+1)+\"-\"+hashTable[i+1]); } hashMap.put(1, \"张三\"); hashMap.put(2, \"李四\"); hashMap.put(3, \"王五\"); System.out.println(hashMap.toString()); 删除 hashTable[1] = \"\"; for(int i = 0; i\u003chashTable.length-1; i++){ System.out.println((i+1)+\"-\"+hashTable[i+1]); } hashMap.remove(1); System.out.println(hashMap.toString()); 更新元素 hashTable[1] = \"赵四\"; for(int i = 0; i\u003chashTable.length-1; i++){ System.out.println((i+1)+\"-\"+hashTable[i+1]); } hashMap.put(1 , \"赵四\"); 获取元素 System.out.println(hashTable[2]); System.out.println(hashMap.get(2)); 检查key的值是否存在 System.out.println(hashMap.containsKey(3)); 哈希表的长度 System.out.println(hashTable.length);// 有一个内存位置为空，4 System.out.println(hashMap.size()); 哈希表是否还有元素 System.out.println(hashMap.isEmpty()); ","date":"2021-10-08","objectID":"/lc_learning5/:7:0","tags":["算法"],"title":"刷题学习5-java 哈希表学习-散列表","uri":"/lc_learning5/"},{"categories":["刷题学习"],"content":"leetcode 练习题 217 存在重复元素 Contains Duplicate 389 找不同 Find Difference 496 下一个最大元素 Next Great Element ","date":"2021-10-08","objectID":"/lc_learning5/:8:0","tags":["算法"],"title":"刷题学习5-java 哈希表学习-散列表","uri":"/lc_learning5/"},{"categories":["yoloV5"],"content":"parser 参数详解 --weights 初始化模型： 有yolov5m，yolov5s，yolov5x，yolov5l，如果为设置为空就是没有任何与训练模型 --config 训练配置文件：.yaml 文件，与预训练模型相对应。 --data 所使用的数据集的配置文件：.yaml 文件，训练自己的数据集是也需要编辑相应的yaml文件 --hyp 超参数配置文件： 学习率等 --epoch 训练轮数 --batch-size batchsize 大小 --img-size 图片大小 --rect padding之后会有灰色区域的冗余信息，此参数设置为真，可以去除冗余信息 --resume 从之前训练的节点开始训练（已经训练的网络在runs/train/exp文件夹下的pt文件） 发现从此pt权重文件开始继续训练 --nosave 是否只保留最后一个epoch的权重文件 --notest 是否只测试最后一个epoch --noautoanchor （目标检测算法中是否使用锚点、锚框）关闭autoanchor --evolve 进化超参数（寻找最优参数的一种方式） --bucket 没有必要 --cache-images 缓存图片以备更快的训练 --image-weights 上一轮中训练情况不好的图片，在下一轮中加一些相关的权重 --device 训练设备选择 选择cpu或者gpu --multi-scale 对图片的尺寸进行变化 --single-cls 训练的数据集是但类别还是多类别 --adam 优化方法使用adam 优化法 --sync-bn DDP参数 --local_rank DDP参数 --workers 最好设置成0，不然很容易出错 --poject 项目存储位置 --entity W\u0026B 训练可视化的库是否启用 --name 训练结果保存名字 --quad 开启之后在尺寸大于640的图像上识别效果更好，但是有可能会使在640尺寸的图片上效果更差 --Linear-lr 学习速率的变化，如果开启就使用线性的方式进行变化，不开启就使用余弦退火的方式变化 --label-smoothing 防止在分了算法中出现过拟合的情况发生 --save_log 每隔多少个epoch，在tensorboard 中打一个标签 ","date":"2021-10-02","objectID":"/yolov5_train/:1:0","tags":["yoloV5","python","pytorch"],"title":"2-YoloV5 train.py 如何使用","uri":"/yolov5_train/"},{"categories":["kinova"],"content":"安全使用 不要进行剪裁操作，尖锐物体可能会上伤到手臂 关闭的时候会泄力，注意提前用手拖着 关节移动的时候不要限位 ","date":"2021-09-28","objectID":"/kinova_gen2learning2/:1:0","tags":["ROS","kinova"],"title":"2-kinova-gen2 使用学习","uri":"/kinova_gen2learning2/"},{"categories":["kinova"],"content":"部件 手臂主体部件 背面接口部件 USB、网线接口：公kinova SDK 控制使用 switch：开关 8pin口：摇杆控制 4pin口：电源线 ","date":"2021-09-28","objectID":"/kinova_gen2learning2/:2:0","tags":["ROS","kinova"],"title":"2-kinova-gen2 使用学习","uri":"/kinova_gen2learning2/"},{"categories":["kinova"],"content":"控制机械臂 ","date":"2021-09-28","objectID":"/kinova_gen2learning2/:3:0","tags":["ROS","kinova"],"title":"2-kinova-gen2 使用学习","uri":"/kinova_gen2learning2/"},{"categories":["kinova"],"content":"手柄控制 两种控制模式：Cartesian velocity（默认）、Angular velocity 手柄结构： 手柄按键指示表： ","date":"2021-09-28","objectID":"/kinova_gen2learning2/:3:1","tags":["ROS","kinova"],"title":"2-kinova-gen2 使用学习","uri":"/kinova_gen2learning2/"},{"categories":["kinova"],"content":"ROS 控制 具体访问https://github.com/Kinovarobotics/kinova-ros 选择对应ros版本的branch，然后进行安装 ","date":"2021-09-28","objectID":"/kinova_gen2learning2/:3:2","tags":["ROS","kinova"],"title":"2-kinova-gen2 使用学习","uri":"/kinova_gen2learning2/"},{"categories":["kinova"],"content":"3 SDK 控制 C++ library ","date":"2021-09-28","objectID":"/kinova_gen2learning2/:3:3","tags":["ROS","kinova"],"title":"2-kinova-gen2 使用学习","uri":"/kinova_gen2learning2/"},{"categories":["yoloV5"],"content":"pycharm 文件目录展开折叠管理 打开已打开文件的目录 展开所有目录 折叠所有目录 ","date":"2021-09-25","objectID":"/yolov5_macair/:1:0","tags":["m1 mac","yoloV5","python","pytorch"],"title":"1-yoloV5 本地训练 - m1 Mac Air（仅仅是为了调通代码）","uri":"/yolov5_macair/"},{"categories":["yoloV5"],"content":"number of workers 设置 此项为dataloader的载入数据的线程数量 初始运行的时候最好设置成0，由于不同机器的性能不同，数目大了很容易出问题 ","date":"2021-09-25","objectID":"/yolov5_macair/:2:0","tags":["m1 mac","yoloV5","python","pytorch"],"title":"1-yoloV5 本地训练 - m1 Mac Air（仅仅是为了调通代码）","uri":"/yolov5_macair/"},{"categories":["yoloV5"],"content":"导入nnpack 错误，m1 Mac 硬件不支持 在运行detect.py文件时同样报错，应该没有影响 ","date":"2021-09-25","objectID":"/yolov5_macair/:3:0","tags":["m1 mac","yoloV5","python","pytorch"],"title":"1-yoloV5 本地训练 - m1 Mac Air（仅仅是为了调通代码）","uri":"/yolov5_macair/"},{"categories":["yoloV5"],"content":"缺失coco 数据集错误 本地缺失coco128数据集 但是联网之后无法在该网址下载coco128 所有复制链接手动下载 最后复制到指定文件夹 完成后问题解决 开始训练 ","date":"2021-09-25","objectID":"/yolov5_macair/:4:0","tags":["m1 mac","yoloV5","python","pytorch"],"title":"1-yoloV5 本地训练 - m1 Mac Air（仅仅是为了调通代码）","uri":"/yolov5_macair/"},{"categories":["刷题学习"],"content":"问号 ？冒号 ：条件语句 int i = 0; int x = i\u003e1 ? 0:1; 问号冒号将其分为代码分为三个部分A、B、C A？B：C 如果A为真则执行B，如果为假则执行C ","date":"2021-09-23","objectID":"/lc_learning4/:1:0","tags":["算法"],"title":"刷题学习4-java 零碎基础知识","uri":"/lc_learning4/"},{"categories":["刷题学习"],"content":"字符串charAt 函数 String 类型的变量使用 指定index，返回该位置上的字符，返回类型为char类型 ","date":"2021-09-23","objectID":"/lc_learning4/:2:0","tags":["算法"],"title":"刷题学习4-java 零碎基础知识","uri":"/lc_learning4/"},{"categories":["刷题学习"],"content":"String 和 StringBuilder 的使用 ","date":"2021-09-23","objectID":"/lc_learning4/:3:0","tags":["算法"],"title":"刷题学习4-java 零碎基础知识","uri":"/lc_learning4/"},{"categories":["刷题学习"],"content":"初始化 StringBuilder str = new StringBuilder(); ","date":"2021-09-23","objectID":"/lc_learning4/:3:1","tags":["算法"],"title":"刷题学习4-java 零碎基础知识","uri":"/lc_learning4/"},{"categories":["刷题学习"],"content":"增加元素 str.append(1); str.append('a'); str.append(1.2); System.out.println(str.toString()); ","date":"2021-09-23","objectID":"/lc_learning4/:3:2","tags":["算法"],"title":"刷题学习4-java 零碎基础知识","uri":"/lc_learning4/"},{"categories":["刷题学习"],"content":"指定位置增加 str.insert(2, 's'); System.out.println(str.toString()); ","date":"2021-09-23","objectID":"/lc_learning4/:3:3","tags":["算法"],"title":"刷题学习4-java 零碎基础知识","uri":"/lc_learning4/"},{"categories":["刷题学习"],"content":"返回指定位置子序列 System.out.println(str.subSequence(0, 3)); ","date":"2021-09-23","objectID":"/lc_learning4/:3:4","tags":["算法"],"title":"刷题学习4-java 零碎基础知识","uri":"/lc_learning4/"},{"categories":["刷题学习"],"content":"搜索元素 System.out.println(str.indexOf(\"as\")); ","date":"2021-09-23","objectID":"/lc_learning4/:3:5","tags":["算法"],"title":"刷题学习4-java 零碎基础知识","uri":"/lc_learning4/"},{"categories":["刷题学习"],"content":"是否为空 System.out.println(str.isEmpty()); ","date":"2021-09-23","objectID":"/lc_learning4/:3:6","tags":["算法"],"title":"刷题学习4-java 零碎基础知识","uri":"/lc_learning4/"},{"categories":["刷题学习"],"content":"leetcode 题目强化 剑指offer 2 字符串二进制加法 ","date":"2021-09-23","objectID":"/lc_learning4/:4:0","tags":["算法"],"title":"刷题学习4-java 零碎基础知识","uri":"/lc_learning4/"},{"categories":["Java学习"],"content":"class 文件结构 ListNode.java 链表节点类 linkListString.java 链表类 test_ll_string.java 测试文件 ","date":"2021-09-20","objectID":"/java_learning/:1:0","tags":["Java","算法"],"title":"Java 学习1-快速实现自定义字符链表","uri":"/java_learning/"},{"categories":["Java学习"],"content":"ListNode.java val 存放字符串 next 指向下一个节点 构造函数 package linkList_string; public class ListNode { char val; ListNode next; public ListNode(char val) { this.val = val; } } ","date":"2021-09-20","objectID":"/java_learning/:2:0","tags":["Java","算法"],"title":"Java 学习1-快速实现自定义字符链表","uri":"/java_learning/"},{"categories":["Java学习"],"content":"linkListString.java 链表类 头节点head 尾节点tail size 存放链表节点数目 构造函数 成员方法：尾部添加元素 package linkList_string; public class linkListString { ListNode head; ListNode tail; int size; public linkListString() { head = null; tail = null; size = 0; } public void add(char val) { ListNode node = new ListNode(val); if (head == null) { head = node; tail = node; } else { tail.next = node; tail = node; } size++; } } ","date":"2021-09-20","objectID":"/java_learning/:3:0","tags":["Java","算法"],"title":"Java 学习1-快速实现自定义字符链表","uri":"/java_learning/"},{"categories":["Java学习"],"content":"test_ll_string.java 测试文件 实例化linkListString对象 添加节点 package linkList_string; public class test_ll_string { public static void main(String[] args) { linkListString list = new linkListString(); list.add('a'); list.add('b'); list.add('c'); list.add('d'); list.add('e'); list.add('f'); list.add('g'); } } Debug 运行成功 ","date":"2021-09-20","objectID":"/java_learning/:4:0","tags":["Java","算法"],"title":"Java 学习1-快速实现自定义字符链表","uri":"/java_learning/"},{"categories":["Java学习"],"content":"平台区分 这里指不同的操作系统：macos windows linux ","date":"2021-09-19","objectID":"/java_learning1/:1:0","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"跨平台运行原理 java 语言要想在不同的平台运行， 只需要该平台上有翻译java语言的虚拟机即可 称为 JVM （Java Virtual Machine） ","date":"2021-09-19","objectID":"/java_learning1/:2:0","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"JRE 和 JDK ","date":"2021-09-19","objectID":"/java_learning1/:3:0","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"JRE（Java Runtime Environment） 是Java运行时的环境，包含JVM和运行时所需要的核心类库 运行一个已有的java程序只需要安装JRE即可 ","date":"2021-09-19","objectID":"/java_learning1/:3:1","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"JDK（Java Development Kit） Java程序开发的工具包， 包含JRE和开发人员使用的工具 其中的开发工具：编译工具（javac.exe), 运行工具（java.exe） ","date":"2021-09-19","objectID":"/java_learning1/:3:2","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"总结：JDK、JRE、JVM之间的关系 实际上运行java 只需要一个JDK就可以了 ","date":"2021-09-19","objectID":"/java_learning1/:4:0","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"本机JDK安装 ","date":"2021-09-19","objectID":"/java_learning1/:5:0","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"Java JDK 安装目录 ","date":"2021-09-19","objectID":"/java_learning1/:6:0","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"IDEA HelloWorld 案例操作步骤 ","date":"2021-09-19","objectID":"/java_learning1/:7:0","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"IDEA 的项目结构 项目(Project) \u003e 模块(Module) \u003e 包(Package) \u003e java文件 对应到这个项目当中 项目(Project)—-java_learning 模块(Module)—–idea_test 包(Package)——swagger_test java文件———HelloWorld.java ","date":"2021-09-19","objectID":"/java_learning1/:8:0","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"内容辅助键 ","date":"2021-09-19","objectID":"/java_learning1/:9:0","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"快速生成语句 快速生成main方法：psvm，回车 快速生成输出语句：sout，回车 ","date":"2021-09-19","objectID":"/java_learning1/:9:1","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"内容辅助键 Ctrl+alt+space—-内容提示，代码补全 ","date":"2021-09-19","objectID":"/java_learning1/:9:2","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"快捷键 ","date":"2021-09-19","objectID":"/java_learning1/:10:0","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"注释 command+/ ","date":"2021-09-19","objectID":"/java_learning1/:10:1","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"格式化 command+options+L ","date":"2021-09-19","objectID":"/java_learning1/:10:2","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"IDEA模块操作 新建模块 删除模块 导入模块 ","date":"2021-09-19","objectID":"/java_learning1/:11:0","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["刷题学习"],"content":"队列的基本特征 先进先出 单端队列–只有一个口可以进，一个口可以出 双端队列–两个口都可以进， 两个口都可以出 ","date":"2021-09-17","objectID":"/lc_learning2/:1:0","tags":["算法"],"title":"刷题学习2-java 队列学习","uri":"/lc_learning2/"},{"categories":["刷题学习"],"content":"队列数据结构的特点 访问O(N) 需要从头到尾遍历一遍 搜索O(N) 需要从头到尾遍历一遍 插入O(1) 插入只能在队尾插入，不需要遍历，所以时间复杂度为O(1) 删除O(1) 删除只能在队头删除，不需要遍历，所以时间复杂度为O(1) tips 队列的底层实现是链表 ","date":"2021-09-17","objectID":"/lc_learning2/:2:0","tags":["算法"],"title":"刷题学习2-java 队列学习","uri":"/lc_learning2/"},{"categories":["刷题学习"],"content":"队列的常见操作 创建队列 Queue\u003cInteger\u003e queue = new LinkedList\u003c\u003e(); 添加元素 for (int i = 0; i\u003c 3 ; i++){ queue.add(i+1); } System.out.println(queue.toString()); 获取即将出队的元素 peek() int temp1 = queue.peek(); System.out.println(temp1); 删除即将出队的元素 remove()、pop()、poll() int temp2 = queue.poll(); System.out.println(temp2); System.out.println(queue.toString()); 判断队列是不是为空 System.out.println(queue.isEmpty());//O(1) 队列长度 System.out.println(queue.size());//O(1) 遍历队列（边删除边遍历队列的操作） while (!queue.isEmpty()){ int temp = queue.poll(); System.out.println(temp); }//O(N) ","date":"2021-09-17","objectID":"/lc_learning2/:3:0","tags":["算法"],"title":"刷题学习2-java 队列学习","uri":"/lc_learning2/"},{"categories":["刷题学习"],"content":"leetcode 队列基础练习题 ","date":"2021-09-17","objectID":"/lc_learning2/:4:0","tags":["算法"],"title":"刷题学习2-java 队列学习","uri":"/lc_learning2/"},{"categories":["刷题学习"],"content":"933 最近的请求次数 number of Recent calls 参数使用： 类的成员变量-队列queue、ping函数中变量-temp保存即将出队的元素 构造函数中初始化queue为一个队列 调用ping时首先最新的t入队 while开始条件：队列不为空 查找即将出列元素到存入temp，如果t-temp大于3000，则出列 如果小于，不出列，停止循环，返回队列长度为最终结果 ","date":"2021-09-17","objectID":"/lc_learning2/:4:1","tags":["算法"],"title":"刷题学习2-java 队列学习","uri":"/lc_learning2/"},{"categories":["刷题学习"],"content":"239 滑动窗口最大值 ","date":"2021-09-17","objectID":"/lc_learning2/:4:2","tags":["算法"],"title":"刷题学习2-java 队列学习","uri":"/lc_learning2/"},{"categories":["刷题学习"],"content":"链表与数组的区别 数组的存放为连续的内存空间， 链表不需要，任意碎片式的内存空间都可以形成链表。 ","date":"2021-09-16","objectID":"/lc_learninglistnode/:1:0","tags":["算法"],"title":"刷题学习1.5-java 链表 知识点ListNode","uri":"/lc_learninglistnode/"},{"categories":["刷题学习"],"content":"链表的分类 双端链表：既有next指向下一个数据也有previous指向前一个数据，可以双向遍历。 单端链表：只有next指向下一个数据，只能单向遍历。 ","date":"2021-09-16","objectID":"/lc_learninglistnode/:2:0","tags":["算法"],"title":"刷题学习1.5-java 链表 知识点ListNode","uri":"/lc_learninglistnode/"},{"categories":["刷题学习"],"content":"链表的基本操作 访问—-O(N) 需要遍历，从头找到尾 搜索—-O(N) 需要遍历，从头找到尾 插入—-O(1) 直接需要插入的位置断开指针，使上一个的指针指向新的元素的位置，新元素的下一个指向原本的下一个元素 删除—-O(1) 断开删除元素前一个元素的next指向删除元素的next即可 ","date":"2021-09-16","objectID":"/lc_learninglistnode/:3:0","tags":["算法"],"title":"刷题学习1.5-java 链表 知识点ListNode","uri":"/lc_learninglistnode/"},{"categories":["刷题学习"],"content":"tips 这里的插入删除操作的时间复杂度实际上说的插入或删除这一个操作的时间复杂度。 实际上整个操作的时间复杂度是O(N)，因为需要先查找到元素，遍历到指定位置，再进行插入。 ","date":"2021-09-16","objectID":"/lc_learninglistnode/:3:1","tags":["算法"],"title":"刷题学习1.5-java 链表 知识点ListNode","uri":"/lc_learninglistnode/"},{"categories":["刷题学习"],"content":"应用场景 写多读少的场景 ","date":"2021-09-16","objectID":"/lc_learninglistnode/:4:0","tags":["算法"],"title":"刷题学习1.5-java 链表 知识点ListNode","uri":"/lc_learninglistnode/"},{"categories":["刷题学习"],"content":"java 链表的常见操作 创建链表 LinkedList\u003cInteger\u003e list_1 = new LinkedList\u003c\u003e(); 添加元素 for (int i = 0; i\u003c3 ;i++){ list_1.add(i+1); } System.out.println(list_1.toString()); list_1.add(2,99); System.out.println(list_1.toString()); 访问元素 System.out.println(list_1.get(2)); 查找元素 System.out.println(list_1.indexOf(99)); System.out.println(list_1.indexOf(88)); 删除元素 list_1.remove(2); System.out.println(list_1.toString()); 链表长度 System.out.println(list_1.size()); 更新元素 list_1.set(2, 88); System.out.println(list_1.toString()); ","date":"2021-09-16","objectID":"/lc_learninglistnode/:5:0","tags":["算法"],"title":"刷题学习1.5-java 链表 知识点ListNode","uri":"/lc_learninglistnode/"},{"categories":["刷题学习"],"content":"链表基础leetcode题目 ","date":"2021-09-16","objectID":"/lc_learninglistnode/:6:0","tags":["算法"],"title":"刷题学习1.5-java 链表 知识点ListNode","uri":"/lc_learninglistnode/"},{"categories":["刷题学习"],"content":"1 leetcode 203 删除指定元素 参数设置：head（移动节点）， prev（head的前一个），dummy（保存头节点，最后返回结果） 1 遍历整个链表，入口的条件是链表的头节点不为空（这样最后一个节点也可以遍历到） 2 如果碰到指定值，prev 指向head的下一个节点head移动一步 3 如果没有碰到指定值，prev指向head，head后移一步 4 最后返回头节点（需要有dummy存储头节点）， 最后返回 ","date":"2021-09-16","objectID":"/lc_learninglistnode/:6:1","tags":["算法"],"title":"刷题学习1.5-java 链表 知识点ListNode","uri":"/lc_learninglistnode/"},{"categories":["刷题学习"],"content":"2 leetcode 206 反转链表 参数设置：head（移动节点）， hNext（head的后一个），dummy（保存头节点，最后返回结果），dNext（dummy的后一个节点） dNext = dummy.next; hNext = head.next; dummy.next = hNext; head.next = hNext.next; hNext.next = dNext; ","date":"2021-09-16","objectID":"/lc_learninglistnode/:6:2","tags":["算法"],"title":"刷题学习1.5-java 链表 知识点ListNode","uri":"/lc_learninglistnode/"},{"categories":["kinova"],"content":"注：此方法适用于系统不能通过自检，并自动启动的情况 ","date":"2021-09-14","objectID":"/kinova_launch1/:0:1","tags":["ROS","kinova"],"title":"1-Kinova MOVO 手动启动操作","uri":"/kinova_launch1/"},{"categories":["kinova"],"content":"手动启动bash roslaunch movo_bringup movo_system.launch ","date":"2021-09-14","objectID":"/kinova_launch1/:1:0","tags":["ROS","kinova"],"title":"1-Kinova MOVO 手动启动操作","uri":"/kinova_launch1/"},{"categories":["kinova"],"content":"运行tractor_node脚本，解决MOVO底盘问题 ./tractor_node ","date":"2021-09-14","objectID":"/kinova_launch1/:2:0","tags":["ROS","kinova"],"title":"1-Kinova MOVO 手动启动操作","uri":"/kinova_launch1/"},{"categories":["kinova"],"content":"直连MOVO进行joystick手柄操作 cd /home/movo/movo_ws roslaunch movo_remote_teleop movo_remote_teleop.launch ","date":"2021-09-14","objectID":"/kinova_launch1/:3:0","tags":["ROS","kinova"],"title":"1-Kinova MOVO 手动启动操作","uri":"/kinova_launch1/"},{"categories":["kinova"],"content":"手柄操作方式 操作方式图解，所有的操作除了手指操作，其他的都需要DeadMan按键激活操作 ","date":"2021-09-14","objectID":"/kinova_launch1/:4:0","tags":["ROS","kinova"],"title":"1-Kinova MOVO 手动启动操作","uri":"/kinova_launch1/"},{"categories":["kinova"],"content":"rviz 操作 进入rviz rviz 点击motion planning 中planning Query栏中状态更新，选中状态之后点击update Commands栏中先点击plan，再update ","date":"2021-09-14","objectID":"/kinova_launch1/:5:0","tags":["ROS","kinova"],"title":"1-Kinova MOVO 手动启动操作","uri":"/kinova_launch1/"},{"categories":["刷题学习"],"content":"时间复杂度 时间复杂度即为代码的执行次数量级 算法的执行时间与输入之间的关系 ","date":"2021-09-08","objectID":"/lc_learning/:1:0","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"O(1) 常量数量级的时间复杂度, 没有for循环和while循环 ","date":"2021-09-08","objectID":"/lc_learning/:1:1","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"O(N) 常量不看，其中total=0，return total为常量执行次数 只有一层循环，循环的执行次数为N ","date":"2021-09-08","objectID":"/lc_learning/:1:2","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"O(logN) 常量不看，其中i=1，return i 为常量执行次数 i=i*2的执行次数为log2(N)，舍去2，则最后结果为O(logN) ","date":"2021-09-08","objectID":"/lc_learning/:1:3","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"O(M+N) 同理常量次数不看 两个O(N)，一个执行M次，一个执行N次 组合之后变成O(M+N)， 实际上等同于O(N) ","date":"2021-09-08","objectID":"/lc_learning/:1:4","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"O(NlogN) 同理常量次数不看 N次执行次数的循环内嵌套了一个logN次执行次数的循环 总次数为二者相乘即为O(NlogN) ","date":"2021-09-08","objectID":"/lc_learning/:1:5","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"O(N2) N次执行次数的循环内嵌套了一个N次执行次数的循环 总次数为二者相乘即为O(N2) ","date":"2021-09-08","objectID":"/lc_learning/:1:6","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"时间复杂度的判断方式 首先看有没有循环，没有则为常量次数O(1) 如果有，首先判断每一次循环的执行次数 循环之间的嵌套使用相乘的方式，得出最终的时间复杂度 ","date":"2021-09-08","objectID":"/lc_learning/:1:7","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"各个时间复杂度之间的比较 O(1) \u003c O(logN) \u003c O(N) \u003c O(NlogN) \u003c O(N2) \u003c O(2N) \u003c O(N!) 二分查找：O(logN) 堆排序：O(NlogN) 冒泡排序：O(N2) 快速排序：O(N2) 选择排序：O(N2) 二叉树排序：O(N2) 插入排序：O(N2) ","date":"2021-09-08","objectID":"/lc_learning/:1:8","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"空间复杂度 算法的存储空间和算法的关系 占空间的都是声明出来的变量 ","date":"2021-09-08","objectID":"/lc_learning/:2:0","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"O(1) 存储的变量为常数数量级 total在初始化之后虽然在循环当中被重复赋值，但是始终只占用total的空间 所以存储的变量为常数数量级 ","date":"2021-09-08","objectID":"/lc_learning/:2:1","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"O(N) 存储的数量级为N，循环的次数 数组的内的数字在不断增多，不断开辟新的内存空间 ","date":"2021-09-08","objectID":"/lc_learning/:2:2","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"tip1 arrary = [] for num in nums: array.append(num) return arrary 空间占用分为堆空间和栈空间 在for循环中条件部分申明的变量 num 开辟的空间为栈空间 使用完毕就会释放 而其他变量使用的是堆空间，程序完成之后才会释放 ","date":"2021-09-08","objectID":"/lc_learning/:3:0","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"tip2 递归的函数内本身的空间复杂度如果为O(1)， 则调用递归的空间复杂度为O(N) 递归的函数内本身的空间复杂度如果为O(N)， 则调用递归的空间复杂度为O(N2) ","date":"2021-09-08","objectID":"/lc_learning/:4:0","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["Latex"],"content":"算法加入 在tex 文件开头引用以下包： algorithm、algorithmics、algpseudocode、amsmath \\usepackage{algorithm} \\usepackage{algorithmicx} \\usepackage{algpseudocode} \\usepackage{amsmath} f 如果算法中包含输入输出模块，还应加入如下代码： \\renewcommand{\\algorithmicrequire}{\\textbf{Input:}} % Use Input in the format of Algorithm \\renewcommand{\\algorithmicensure}{\\textbf{Output:}} % Use Output in the format of Algorithm 算法主体 \\begin{algorithm}[thpb] \\caption{algorithm name} \\label{algorithmlabel} \\begin{algorithmic}[1] \\Require algorithm input \\Ensure algorithm output \\State algorithm content1; \\While{while loop} \\State algorithm content2;\\EndWhile \\\\ \\Return algorithm output. \\end{algorithmic} \\end{algorithm} 完成之后呈现为这种状态 注意： 在while之后不要忘记endwhile while内部的代码会自动缩近 ","date":"2021-09-08","objectID":"/latex_learning2/:1:0","tags":["Latex"],"title":"Latex 语法学习笔记2","uri":"/latex_learning2/"},{"categories":["Latex"],"content":"各种文件 .bib 存放参考文献 .tex 文献源码 .bst 参考文献风格，与.bib组合使用 .sty 风格文件 ","date":"2021-09-08","objectID":"/latex_learning2/:2:0","tags":["Latex"],"title":"Latex 语法学习笔记2","uri":"/latex_learning2/"},{"categories":["Latex"],"content":"overleaf 使用 overleaf 左下角为文章结构 方便快速定位到tex代码文件的位置 ","date":"2021-09-08","objectID":"/latex_learning1/:1:0","tags":["Latex"],"title":"Latex 语法学习笔记1","uri":"/latex_learning1/"},{"categories":["Latex"],"content":"图片的插入与引用 插入 \\begin{figure}[t] \\centering \\includegraphics[scale=0.25]{intro.png} \\caption{描述} \\label{pic-label} \\vspace{-0.4cm} \\end{figure} \\centering 放置位置剧中 \\includegraphics[scale=0.25]{intro.png} 图片名称（同一目录下）及大小 \\caption{描述}图片下方的描述 \\label{pic-label}图片的引用 引用 Fig. \\ref{pic-label} 此处的pic-label 即为图片插入时的图片引用 ","date":"2021-09-08","objectID":"/latex_learning1/:2:0","tags":["Latex"],"title":"Latex 语法学习笔记1","uri":"/latex_learning1/"},{"categories":["Latex"],"content":"文献的插入与引用 首先bib文件中加入此格式的代码 @article{cosio2004autonomous, title={Autonomous robot navigation using adaptive potential fields}, author={Cos{\\'\\i}o, F Arambula and Casta{\\~n}eda, MA Padilla}, journal={Mathematical and Computer Modelling}, volume={40}, number={9-10}, pages={1141--1156}, year={2004} } 在tex文件中加入对bib文件和bst文献的支持 \\bibliographystyle{IEEEtranS} \\bibliography{IEEEexample} 最后在tex文件中引用该文献， 此处引用label为 cosio2004autonomous ~\\cite{cosio2004autonomous} ","date":"2021-09-08","objectID":"/latex_learning1/:3:0","tags":["Latex"],"title":"Latex 语法学习笔记1","uri":"/latex_learning1/"}]