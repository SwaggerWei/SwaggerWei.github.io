[{"categories":["Category level 6D pose"],"content":"背景 真实数据集上训练出来的模型往往难以推广到没有遇到过的场景 实例级别的9D姿态预测在测试时需要对没有见过的物体也有效，因为实例级别预测是没有CAD模型的，这往往也很难 ","date":"2022-03-19","objectID":"/category_level_1_cppf/:1:0","tags":["6D Pose","Category level"],"title":"CPPF","uri":"/category_level_1_cppf/"},{"categories":["Category level 6D pose"],"content":"贡献点 基于PPF(pair point features)提出CPPF(Category level pair point features)投票法进行9D姿态预测 提出一种由粗到细的算法消除噪声点对（当实例分割算法不够精准时） 提出一种实例分割算法用于发现目标物体 提出一个binary disambiguating classification task消除旋转姿态投票误报 只在虚拟点云上进行训练，除非物体在几何上有姿态非常模糊 RGB信息被用来消除姿态歧义 ","date":"2022-03-19","objectID":"/category_level_1_cppf/:2:0","tags":["6D Pose","Category level"],"title":"CPPF","uri":"/category_level_1_cppf/"},{"categories":["Category level 6D pose"],"content":"数据集 NOCS REAL275 SUN RGB-D ","date":"2022-03-19","objectID":"/category_level_1_cppf/:3:0","tags":["6D Pose","Category level"],"title":"CPPF","uri":"/category_level_1_cppf/"},{"categories":["Category level 6D pose"],"content":"实验 NOCS REAL275 对比实验 NOCS REAL275 仅提供bounding box 进行9D预测实验 SUN RGB-D 更加复杂的真实环境实验 ","date":"2022-03-19","objectID":"/category_level_1_cppf/:4:0","tags":["6D Pose","Category level"],"title":"CPPF","uri":"/category_level_1_cppf/"},{"categories":["开发工具"],"content":"基础结构 用户连接 connection 数据库 database 表格 table 视图 view 等等 ","date":"2022-02-22","objectID":"/mysql_learning/:1:0","tags":["SQL","mysql","navicat"],"title":"Mysql学习1-基础命令行操作","uri":"/mysql_learning/"},{"categories":["开发工具"],"content":"连接数据库 navicat 双击数据库，创建连接 命令行连接 mysql -uroot -pWby785403310 修改密码 updatemysql.usersetauthentication_string=password('123456')whereuser='root'andHost='localhost'; 刷新权限 flushprivileges; ","date":"2022-02-22","objectID":"/mysql_learning/:2:0","tags":["SQL","mysql","navicat"],"title":"Mysql学习1-基础命令行操作","uri":"/mysql_learning/"},{"categories":["开发工具"],"content":"常用基础命令 查看所有数据库 showdatabases; 使用数据库 use + database名称 usemysql; 查看所有table showtables; 查看指定表结构 describeuser; 创建一个数据库 createdatabasewestos; 退出连接和注视 exit;--退出连接 --单行注释 /* sql 多行注释 */ ","date":"2022-02-22","objectID":"/mysql_learning/:3:0","tags":["SQL","mysql","navicat"],"title":"Mysql学习1-基础命令行操作","uri":"/mysql_learning/"},{"categories":["开发工具"],"content":"mysql 语言种类 CRUD 增删改查 DDL database define language DML database manipulate language DQL database query language DCL database control language CV 程序员 API 程序员 CRUD 程序员（业务） ","date":"2022-02-22","objectID":"/mysql_learning/:4:0","tags":["SQL","mysql","navicat"],"title":"Mysql学习1-基础命令行操作","uri":"/mysql_learning/"},{"categories":["开发工具"],"content":"操作数据库 操作数据库\u003e操作数据库中的表\u003e操作数据库中的表数据 关键字不区分大小写 ","date":"2022-02-22","objectID":"/mysql_learning/:5:0","tags":["SQL","mysql","navicat"],"title":"Mysql学习1-基础命令行操作","uri":"/mysql_learning/"},{"categories":["开发工具"],"content":"操作数据库 （了解） 创建数据库 CREATE DATABASE IF NOT EXISTS westos; 删除数据库 DROP DATABASE IF EXISTS hello; 使用数据库 use `school` (如果表明和字段名是一个保留字，应该加上反引号) 查看数据库 show databases ","date":"2022-02-22","objectID":"/mysql_learning/:5:1","tags":["SQL","mysql","navicat"],"title":"Mysql学习1-基础命令行操作","uri":"/mysql_learning/"},{"categories":["开发工具"],"content":"数据库的数据（列）类型 1 数值 tinyint 十分小的数据 1个字节 smallint 较小的数据 2个字节 mediumint 中等大小 3个字节 int 标准的整数 4个字节 bigint 较大的数据 8个字节 float 单精度 4个字节 double 双精度 8个字节（精度问题） decimal 字符串形式的浮点数（金融计算，一般是decimal） 2 字符串 char 字符固定大小 0～255 varchar 可变字符串 0～65535 常用变量 tinytext 微型文本 2^8-1 text 文本类型 一般用于大型文章 3 时间日期 date YYYY-MM-DD 日期格式 time HH：mm：ss 时间格式 datetime YYYY-MM-DD HH：mm：ss 最常用的时间格式 timestamp 时间戳 1970.1.1 到现在的毫秒数 year 年份表示 4 null 没有值，未知 不要使用null进行运算 ","date":"2022-02-22","objectID":"/mysql_learning/:5:2","tags":["SQL","mysql","navicat"],"title":"Mysql学习1-基础命令行操作","uri":"/mysql_learning/"},{"categories":["开发工具"],"content":"下载Hugo ","date":"2022-02-16","objectID":"/first_post/:1:0","tags":["hugo"],"title":"Hugo 使用教程","uri":"/first_post/"},{"categories":["开发工具"],"content":"使用 brew 来安装hugo brew install hugo ","date":"2022-02-16","objectID":"/first_post/:1:1","tags":["hugo"],"title":"Hugo 使用教程","uri":"/first_post/"},{"categories":["开发工具"],"content":"新建一个hugo 项目 hugo new site mysite ","date":"2022-02-16","objectID":"/first_post/:1:2","tags":["hugo"],"title":"Hugo 使用教程","uri":"/first_post/"},{"categories":["开发工具"],"content":"hugo 项目文件结构介绍 content 博客内容 static 图片 theme 主题 ","date":"2022-02-16","objectID":"/first_post/:1:3","tags":["hugo"],"title":"Hugo 使用教程","uri":"/first_post/"},{"categories":["开发工具"],"content":"主题的配置 ","date":"2022-02-16","objectID":"/first_post/:2:0","tags":["hugo"],"title":"Hugo 使用教程","uri":"/first_post/"},{"categories":["开发工具"],"content":"主题下载 进入gohugo.io 搜索一个主题下载到项目中的theme 文件夹之中 ","date":"2022-02-16","objectID":"/first_post/:2:1","tags":["hugo"],"title":"Hugo 使用教程","uri":"/first_post/"},{"categories":["开发工具"],"content":"主题的配置 进入下载主题的说明文档 https://hugoloveit.com/zh-cn/theme-documentation-basics/ 复制基本配置，并覆盖项目根目录的config.toml 文件 ","date":"2022-02-16","objectID":"/first_post/:2:2","tags":["hugo"],"title":"Hugo 使用教程","uri":"/first_post/"},{"categories":["开发工具"],"content":"创建第一篇博客 hugo new posts/first_post.md ","date":"2022-02-16","objectID":"/first_post/:2:3","tags":["hugo"],"title":"Hugo 使用教程","uri":"/first_post/"},{"categories":["开发工具"],"content":"在本地启动网站 hugo serve --buildDrafts 这里是 –buildDrafts 指文档的草稿属性为真，就需要此参数，或者直接将对应markdown文件中的draft属性设置为false ","date":"2022-02-16","objectID":"/first_post/:2:4","tags":["hugo"],"title":"Hugo 使用教程","uri":"/first_post/"},{"categories":["开发工具"],"content":"网站高阶参数配置 复制 https://hugoloveit.com/zh-cn/theme-documentation-basics/#site-configuration 中的config.toml 文件补充到本地的对应文件当中去，注意有几个参数是重复的， ","date":"2022-02-16","objectID":"/first_post/:2:5","tags":["hugo"],"title":"Hugo 使用教程","uri":"/first_post/"},{"categories":["开发工具"],"content":"部署到github.io 服务器 ","date":"2022-02-16","objectID":"/first_post/:3:0","tags":["hugo"],"title":"Hugo 使用教程","uri":"/first_post/"},{"categories":["开发工具"],"content":"github仓库新建 新建一个项目，名字为： github账号名.github.io ","date":"2022-02-16","objectID":"/first_post/:3:1","tags":["hugo"],"title":"Hugo 使用教程","uri":"/first_post/"},{"categories":["开发工具"],"content":"本地对接远程服务器地址 命令 hugo --theme=LoveIt --baseUrl=\"https://swaggerwei.github.io/\" -D 可以发现本地生成了一个public文件夹 命令 cd public git init git add . git commit -m \"first commit\" git remote add origin git@github.com:SwaggerWei/SwaggerWei.github.io.git git push -u origin master tips: init 和 remote add 操作后续更改博客不需要，只有第一次建仓库的时候需要 ","date":"2022-02-16","objectID":"/first_post/:3:2","tags":["hugo"],"title":"Hugo 使用教程","uri":"/first_post/"},{"categories":["开发工具"],"content":"网页进入个人主页 swaggerwei.github.io tips：一般过五分钟才行 ","date":"2022-02-16","objectID":"/first_post/:3:3","tags":["hugo"],"title":"Hugo 使用教程","uri":"/first_post/"},{"categories":["开发工具"],"content":"团队协作分支开发模式 一个好的 github 项目一般都有多个分支：master，dev，release分支 新建分支 branch git branch branch1 切换到目标分支 git checkout branch1 在本地的branch1 中添加一个helloworld.java 文件 public class HelloWorld { public static void main(String[] args) { System.out.println(\"hello world\"); System.out.println(\"1\"); System.out.println(\"hello world\"); System.out.println(\"2\"); } } 推送到远端 git push --set-upstream origin branch1 然后远端就有了master 和 branch1 两个分支了， 其中branch1 中才有 java文件 同理，在另一个人的主机上， 创建branch2， 并写自己的HelloWorld.java文件 public class HelloWorld { public static void main(String[] args) { System.out.println(\"1\"); System.out.println(\"hello world\"); System.out.println(\"2\"); System.out.println(\"hello world\"); } } 分支的合并发布 首先切换到master分支 git checkout master 拉一下最新的远端分支情况 git pull 将branch1 分支的内容合并到master 分支上 git merge brunch1 推到远端 git push 发现master 分支 也有branch1 中的java文件了 同理合并 branch2 到 master上， 但是发现合并有冲突， 因为有两个同名的Java 文件， 但是文件内容却不一样 ","date":"2022-01-30","objectID":"/git_learning3/:1:0","tags":["git","github","gitee"],"title":"git 代码管理工具3","uri":"/git_learning3/"},{"categories":["开发工具"],"content":"使用IDEA 快速解决 git merge 当中的冲突 右键， 选择git-》resolve conflict 双击出现的 conflict 进行代码比对 手动比对之后出现 all changes have been processed 就可以了， 点击右下角apply 然后上传到远端没有出现错误则说明成功 ","date":"2022-01-30","objectID":"/git_learning3/:2:0","tags":["git","github","gitee"],"title":"git 代码管理工具3","uri":"/git_learning3/"},{"categories":["开发工具"],"content":"如何解决冲突 模拟两个人同时修改一个文件并提交到远端 克隆到两个文件夹 me 和 other git clone git@gitee.com:swagger_wei/test_gitee_git.git me git clone git@gitee.com:swagger_wei/test_gitee_git.git other other 对first.txt 内容作出修改 推送到远端 此时另一个 me 的本地仓库是不知道远程的仓库已经发生了修改的 me 对first.txt 内容作出修改 推送到远端 发现出错，因为本地 me 仓库 不知道远端仓库已经发生了变换， 所以向远端提交失败 拉取远端变化 git pull 发现有pull之后有冲突需要解决 商量之后删掉无用部分， 合并冲突 提交到远端 发现远端已经提交成功 ","date":"2022-01-27","objectID":"/git_learning2/:1:0","tags":["git","github","gitee"],"title":"git 代码管理工具2","uri":"/git_learning2/"},{"categories":["开发工具"],"content":"应用场景 团队协作开发， 避免频繁来回拷贝代码 ","date":"2022-01-17","objectID":"/git_learning/:1:0","tags":["git","github","gitee"],"title":"git 代码管理工具1","uri":"/git_learning/"},{"categories":["开发工具"],"content":"git 工作流程 克隆 Git 资源作为工作目录 在本地的工作副本上做修改操作 如果别人更改了资源可以更新资源 检查修改之后就可以向资源库推送更新 如果发现有错误则可以撤销推送，修改错误，然后重新推送 ","date":"2022-01-17","objectID":"/git_learning/:2:0","tags":["git","github","gitee"],"title":"git 代码管理工具1","uri":"/git_learning/"},{"categories":["开发工具"],"content":"工作区和、暂存区和版本库 工作区，就是本地电脑上可以看到的文件(按下Command+Shift+. 可以显示隐藏文件、文件夹，再按一次，恢复隐藏；) 暂存区，英文stage或者index，一般存放在 .git 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index） 版本库：工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。 ","date":"2022-01-17","objectID":"/git_learning/:3:0","tags":["git","github","gitee"],"title":"git 代码管理工具1","uri":"/git_learning/"},{"categories":["开发工具"],"content":"基本操作命令 当前基本状态 git status 显示当前的最新的branch； 显示没有被commit的 文件（发现.DS_Store和first文件没有被commit） 添加到暂存区 git add 文件名 .为所有文件，再次运行git status，发现所有的文件都已经被添加 添加到版本库 git commit -m \"版本提交的附带信息\" 查看当前的提交和回滚情况 git log 注：为倒叙排序， Initial commit 为默认初始化github 官网创建得到 回滚最新的一次commit git reset commit后跟的ID 回滚之前发现有一个message 为 second commit 的 commit 回滚的ID 填入倒数第二个ID， 说明回滚到倒数第二新的状态 设置邮箱号 git config --global user.email 785403310@qq.com 设置名字 git config --global user.name swagger 然后发现log 信息中的commit 信息变成了自己 推送到github服务器 git push 推送之后发现本地创建的文件已经同步到了gitee上 ","date":"2022-01-17","objectID":"/git_learning/:4:0","tags":["git","github","gitee"],"title":"git 代码管理工具1","uri":"/git_learning/"},{"categories":["JVM学习"],"content":"9 JVM 类加载机制 Java 虚拟机将 Java 源码编译为字节码之后，虚拟机便可以将字节码读取进内存，从而进行解析、运行等整个过程，这个过程我们叫：Java 虚拟机的类加载机制 JVM 虚拟机执行 class 字节码的过程可以分为七个阶段：加载、验证、准备、解析、初始化、使用、卸载。 ","date":"2022-01-07","objectID":"/jvm_learning1/:1:0","tags":["Java","算法","JVM"],"title":"JVM 学习1-类加载机制","uri":"/jvm_learning1/"},{"categories":["JVM学习"],"content":"9.1 加载 JVM 的主要目的是将字节码从各个位置（网络、磁盘等）转化为二进制字节流加载到内存中，接着会为这个类在 JVM 的方法区创建一个对应的 Class 对象，这个 Class 对象就是这个类各种数据的访问入口 ","date":"2022-01-07","objectID":"/jvm_learning1/:1:1","tags":["Java","算法","JVM"],"title":"JVM 学习1-类加载机制","uri":"/jvm_learning1/"},{"categories":["JVM学习"],"content":"9.2 验证 当 JVM 加载完 Class 字节码文件并在方法区创建对应的 Class 对象之后，JVM 便会启动对该字节码流的校验，只有符合 JVM 字节码规范的文件才能被 JVM 正确执行。这个校验过程大致可以分为下面几个类型： JVM规范校验：VM 会对字节流进行文件格式校验，判断其是否符合 JVM 规范，是否能被当前版本的虚拟机处理。例如：文件是否是以 0x cafe bene开头，主次版本号是否在当前虚拟机处理范围之内等 代码逻辑校验：JVM 会对代码组成的数据流和控制流进行校验，确保 JVM 运行该字节码文件后不会出现致命错误。例如一个方法要求传入 int 类型的参数，但是使用它的时候却传入了一个 String 类型的参数。一个方法要求返回 String 类型的结果，但是最后却没有返回结果。代码中引用了一个名为 Apple 的类，但是你实际上却没有定义 Apple 类 ","date":"2022-01-07","objectID":"/jvm_learning1/:1:2","tags":["Java","算法","JVM"],"title":"JVM 学习1-类加载机制","uri":"/jvm_learning1/"},{"categories":["JVM学习"],"content":"9.3 准备 当完成字节码文件的校验之后，JVM 便会开始为类变量分配内存并初始化。这里需要注意两个关键点，即内存分配的对象以及初始化的类型 内存分配的对象。 Java 中的变量有「类变量」和「类成员变量」两种类型，「类变量」指的是被 static 修饰的变量，而其他所有类型的变量都属于「类成员变量」。在准备阶段，JVM 只会为「类变量」分配内存，而不会为「类成员变量」分配内存。「类成员变量」的内存分配需要等到初始化阶段才开始。 初始化的类型。 在准备阶段，JVM 会为类变量分配内存，并为其初始化。但是这里的初始化指的是为变量赋予 Java 语言中该数据类型的零值，而不是用户代码里初始化的值。但如果一个变量是常量（被 static final 修饰）的话，那么在准备阶段，属性便会被赋予用户希望的值 ","date":"2022-01-07","objectID":"/jvm_learning1/:1:3","tags":["Java","算法","JVM"],"title":"JVM 学习1-类加载机制","uri":"/jvm_learning1/"},{"categories":["JVM学习"],"content":"9.4 解析 当通过准备阶段之后，JVM 针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类引用进行解析。这个阶段的主要任务是将其在常量池中的符号引用替换成直接其在内存中的直接引用。 其实这个阶段对于我们来说也是几乎透明的，了解一下就好 ","date":"2022-01-07","objectID":"/jvm_learning1/:1:4","tags":["Java","算法","JVM"],"title":"JVM 学习1-类加载机制","uri":"/jvm_learning1/"},{"categories":["JVM学习"],"content":"9.5 初始化（重点） 到了初始化阶段，用户定义的 Java 程序代码才真正开始执行。在这个阶段，JVM 会根据语句执行顺序对类对象进行初始化，一般来说当 JVM 遇到下面 5 种情况的时候会触发初始化： 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类 当使用 JDK1.7 动态语言支持时，如果一个 java.lang.invoke.MethodHandle实例最后的解析结果 REF_getstatic,REF_putstatic,REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化 ","date":"2022-01-07","objectID":"/jvm_learning1/:1:5","tags":["Java","算法","JVM"],"title":"JVM 学习1-类加载机制","uri":"/jvm_learning1/"},{"categories":["JVM学习"],"content":"9.6 使用 当 JVM 完成初始化阶段之后，JVM 便开始从入口方法开始执行用户的程序代码。这个阶段也只是了解一下就可以 ","date":"2022-01-07","objectID":"/jvm_learning1/:1:6","tags":["Java","算法","JVM"],"title":"JVM 学习1-类加载机制","uri":"/jvm_learning1/"},{"categories":["JVM学习"],"content":"9.7 卸载 当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存。这个阶段也只是了解一下就可以 ","date":"2022-01-07","objectID":"/jvm_learning1/:1:7","tags":["Java","算法","JVM"],"title":"JVM 学习1-类加载机制","uri":"/jvm_learning1/"},{"categories":["Java学习"],"content":"6 反射 反向获取class中各种对象的信息、例如成员变量、方法、构造方法、包等等信息 ","date":"2022-01-06","objectID":"/java_learning6/:1:0","tags":["Java","算法"],"title":"Java 学习6-反射","uri":"/java_learning6/"},{"categories":["Java学习"],"content":"6.1 创建一个对象的过程 new来实例一个对象时jvm会在家在对应的class文件 jvm在本地磁盘中查找class文件 将class文件读入到内存当中，以便使用 一个class 文件只占用个同一个空间，对此用一个class在new，不会重复在内存空间中初始化 ","date":"2022-01-06","objectID":"/java_learning6/:1:1","tags":["Java","算法"],"title":"Java 学习6-反射","uri":"/java_learning6/"},{"categories":["Java学习"],"content":"6.2 获取类的字节码 //获取类的字节码 // 方法一 Student stu1 = new Student(); Class stuClass = stu1.getClass(); System.out.println(stuClass.toString()); System.out.println(stuClass.getName()); // 方法二 Class stuClass2 = Student.class; System.out.println(stuClass2.toString()); System.out.println(stuClass2 == stuClass); // 方法三 Class stuClass3 = Class.forName(\"reflectionDemo.Student\"); System.out.println(stuClass3.toString()); ","date":"2022-01-06","objectID":"/java_learning6/:1:2","tags":["Java","算法"],"title":"Java 学习6-反射","uri":"/java_learning6/"},{"categories":["Java学习"],"content":"6.3 反射得到有参数的构造函数 // 反射得到有参数构造函数 Constructor c = stuClass3.getConstructor(String.class); c.newInstance(\"wby\"); ","date":"2022-01-06","objectID":"/java_learning6/:1:3","tags":["Java","算法"],"title":"Java 学习6-反射","uri":"/java_learning6/"},{"categories":["Java学习"],"content":"6.4 反射得到私有构造函数 // 反射得到私有构造函数 Constructor c4Private = stuClass3.getDeclaredConstructor(int.class); c4Private.setAccessible(true); c4Private.newInstance(20); ","date":"2022-01-06","objectID":"/java_learning6/:1:4","tags":["Java","算法"],"title":"Java 学习6-反射","uri":"/java_learning6/"},{"categories":["Java学习"],"content":"6.5 反射得到所有的构造方法 Constructor[] c4All = stuClass3.getDeclaredConstructors(); for (Constructor c1 : c4All){ System.out.println(c1); } ","date":"2022-01-06","objectID":"/java_learning6/:1:5","tags":["Java","算法"],"title":"Java 学习6-反射","uri":"/java_learning6/"},{"categories":["Java学习"],"content":"6.6 反射得到类中的普通方法 Student p = (Student) stuClass3.newInstance(); Method m = stuClass3.getMethod(\"Student1\", String.class, int.class); m.invoke(p, \"wby\", 20); ","date":"2022-01-06","objectID":"/java_learning6/:1:6","tags":["Java","算法"],"title":"Java 学习6-反射","uri":"/java_learning6/"},{"categories":["Java学习"],"content":"6.7 反射类中的属性字段 Field f = stuClass3.getField(\"name\"); String s = (String) f.get(p); System.out.println(s); ","date":"2022-01-06","objectID":"/java_learning6/:1:7","tags":["Java","算法"],"title":"Java 学习6-反射","uri":"/java_learning6/"},{"categories":["Java学习"],"content":"6.8 应用场合、缺点 在编译时根本无法知道该对象或类可能属于哪些类，程序只依靠运行时信息来发现该对象和类的真实信息 使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码 使用反射会模糊程序内部逻辑 ","date":"2022-01-06","objectID":"/java_learning6/:1:8","tags":["Java","算法"],"title":"Java 学习6-反射","uri":"/java_learning6/"},{"categories":["Java学习"],"content":"5 泛型 泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数 ","date":"2022-01-06","objectID":"/java_learning5/:1:0","tags":["Java","算法"],"title":"Java 学习5-泛型","uri":"/java_learning5/"},{"categories":["Java学习"],"content":"5.1 泛型方法 在调用时可以接收不同类型的参数 每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开 类型参数能被用来声明返回值类型 泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（像 int、double、char 等） ","date":"2022-01-06","objectID":"/java_learning5/:1:1","tags":["Java","算法"],"title":"Java 学习5-泛型","uri":"/java_learning5/"},{"categories":["Java学习"],"content":"5.2 java 中范型标记符 E - Element (在集合中使用，因为集合中存放的是元素) T - Type（Java 类） K - Key（键） V - Value（值） N - Number（数值类型） ？ - 表示不确定的 java 类型 ","date":"2022-01-06","objectID":"/java_learning5/:1:2","tags":["Java","算法"],"title":"Java 学习5-泛型","uri":"/java_learning5/"},{"categories":["Java学习"],"content":"5.3 类型通配符 类型通配符一般是使用 ? 代替具体的类型参数。例如 List\u003c?\u003e 在逻辑上是 List,List 等所有 List\u003c具体类型实参\u003e 的父类 ","date":"2022-01-06","objectID":"/java_learning5/:1:3","tags":["Java","算法"],"title":"Java 学习5-泛型","uri":"/java_learning5/"},{"categories":["Java学习"],"content":"5.4 实例1 — 泛型方法 package GenericsDemo; public class genericDemo { public static \u003c E \u003e void printArray(E[] array){ for(E element : array){ System.out.println(element); } } public static void main(String[] args) { Integer[] intArray = {1 ,2, 3, 4, 5}; Double[] doubleArray = {1.1, 2.1, 3.1, 4.1}; Character[] charArray = {'a', 'b', 'c', 'd'}; System.out.println(\"整型数组元素为：\"); printArray(intArray); System.out.println(\"双精度型数组元素为：\"); printArray(doubleArray); System.out.println(\"字符型数组元素为：\"); printArray(charArray); } } ","date":"2022-01-06","objectID":"/java_learning5/:1:4","tags":["Java","算法"],"title":"Java 学习5-泛型","uri":"/java_learning5/"},{"categories":["Java学习"],"content":"5.5 泛型类 package GenericsDemo; public class genericClassDemo \u003cT\u003e{ public T val; public void add (T val){ this.val = val; } public void display(){ System.out.println(this.val); } public static void main(String[] args) { genericClassDemo\u003cInteger\u003e intTest = new genericClassDemo\u003c\u003e(); genericClassDemo\u003cString\u003e stringTest = new genericClassDemo\u003c\u003e(); intTest.add(1); stringTest.add(\"fdsafdas\"); intTest.display(); stringTest.display(); } } ","date":"2022-01-06","objectID":"/java_learning5/:1:5","tags":["Java","算法"],"title":"Java 学习5-泛型","uri":"/java_learning5/"},{"categories":["Java学习"],"content":"4 异常 异常机制是指当程序出现错误后，程序如何处理。具体来说，异常机制提供了程序退出的安全通道。当出现错误后，程序执行的流程发生改变，程序的控制权转移到异常处理器。 ","date":"2022-01-06","objectID":"/java_learning4/:1:0","tags":["Java","算法"],"title":"Java 学习4-异常","uri":"/java_learning4/"},{"categories":["Java学习"],"content":"4.1 程序错误的分类 编译错误：编译错误是因为程序没有遵循语法规则，编译程序能够自己发现并且提示我们错误的原因和位置 运行时错误：程序在执行时，运行环境发现了不能执行的操作 逻辑错误：程序没有按照预期的逻辑顺序执行。异常也就是指程序运行时发生错误，而异常处理就是对这些错误进行处理和控制 Throwable： 有两个重要的子类：Exception（异常）和 Error（错误），二者都是 Java 异常处理的重要子类，各自都包含大量子类。 异常和错误的区别是：异常能被程序本身处理，错误是无法处理 ","date":"2022-01-06","objectID":"/java_learning4/:1:1","tags":["Java","算法"],"title":"Java 学习4-异常","uri":"/java_learning4/"},{"categories":["Java学习"],"content":"4.2 运行时异常和非运行时异常 运行时异常RuntimeException（不受检异常unchecked）： RuntimeException类极其子类表示JVM在运行期间可能出现的错误。编译器不会检查此类异常，并且不要求处理异常，比如用空值对象的引用（NullPointerException）、数组下标越界（ArrayIndexOutBoundException）。此类异常属于不可查异常，一般是由程序逻辑错误引起的，在程序中可以选择捕获处理，也可以不处理 非运行时异常，（受检异常checked）： Exception中除RuntimeException极其子类之外的异常。编译器会检查此类异常，如果程序中出现此类异常，比如说IOException，必须对该异常进行处理，要么使用try-catch捕获，要么使用throws语句抛出，否则编译不通过。 ","date":"2022-01-06","objectID":"/java_learning4/:1:2","tags":["Java","算法"],"title":"Java 学习4-异常","uri":"/java_learning4/"},{"categories":["Java学习"],"content":"4.3 异常的处理 抛出异常：throw，throws throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。 throws运用于方法声明之上，用于表示当前方法不处理异常，而是提醒该方法的调用者来处理异常 捕获异常：try，catch，finally ","date":"2022-01-06","objectID":"/java_learning4/:1:3","tags":["Java","算法"],"title":"Java 学习4-异常","uri":"/java_learning4/"},{"categories":["Java学习"],"content":"4.4 实例 throw 的使用 package ExceptionDemo; public class TrowDemo { public static void main(String[] args) { int a = devide(4, 0); System.out.println(a); } public static int devide(int a, int b){ if(b==0){ throw new ArithmeticException(\"异常信息：除数不能为0\"); } return a/b; } } throws 的使用 package ExceptionDemo; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.InputStream; public class ThrowsDemo { public static void main(String[] args) throws FileNotFoundException{ try { //可能出现异常的代码段 readFile(); }catch (FileNotFoundException e){ // 异常处理 System.out.println(\"异常信息： 找不到指定路径\"); } System.out.println(\"后续处理\"); } public static void readFile() throws FileNotFoundException{ // InputStream is = new FileInputStream(\"/Users/swaggerwei/Desktop/look4Job/Java_language/notes/docks\"); InputStream is = new FileInputStream(\"/Users/swaggerwei/Desktop/notes/docks\"); } } 自定义异常类 package ExceptionDemo; /* * 自定义异常类 * 用户不存在异常 * */ public class UserNotExistException extends RuntimeException{ public UserNotExistException(){ super(); } } ","date":"2022-01-06","objectID":"/java_learning4/:1:4","tags":["Java","算法"],"title":"Java 学习4-异常","uri":"/java_learning4/"},{"categories":["Java学习"],"content":"3 容器 数据容器主要分为了两类：Collection 和 Map Collection: 存放独立元素的序列 Map：存放key-value型的元素对 ","date":"2022-01-06","objectID":"/java_learning3/:1:0","tags":["Java","算法"],"title":"Java 学习3-容器","uri":"/java_learning3/"},{"categories":["Java学习"],"content":"3.1 Collection 存放独立元素的序列 List： ArrayList LinkedList Vector Stack Set：HashSet LinkedHashSet TreeSet ","date":"2022-01-06","objectID":"/java_learning3/:1:1","tags":["Java","算法"],"title":"Java 学习3-容器","uri":"/java_learning3/"},{"categories":["Java学习"],"content":"3.2 Map：存放key-value型的元素对 HashMap： LinkedHashMap TreeMap： ConcurrentHashMap HashTable ","date":"2022-01-06","objectID":"/java_learning3/:1:2","tags":["Java","算法"],"title":"Java 学习3-容器","uri":"/java_learning3/"},{"categories":["Java学习"],"content":"3.3 Collection 和 Collections 的区别 Collection 是一个接口， Set和List等容器的父接口 Collections 是一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等 ","date":"2022-01-06","objectID":"/java_learning3/:1:3","tags":["Java","算法"],"title":"Java 学习3-容器","uri":"/java_learning3/"},{"categories":["Java学习"],"content":"3.4 List、Set、Map 的区别 ","date":"2022-01-06","objectID":"/java_learning3/:1:4","tags":["Java","算法"],"title":"Java 学习3-容器","uri":"/java_learning3/"},{"categories":["Java学习"],"content":"3.5 HashMap 和 HashTable的区别 存储：HashMap 运行 key 和 value 为 null，而 Hashtable 不允许。 线程安全：Hashtable 是线程安全的(同一时间只允许一个线程作出改变)，而 HashMap 是非线程安全的（同一时间可能有多个线程对其进行操作）。 推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。 ","date":"2022-01-06","objectID":"/java_learning3/:1:5","tags":["Java","算法"],"title":"Java 学习3-容器","uri":"/java_learning3/"},{"categories":["Java学习"],"content":"3.6 实例 package Java_ContainerDemo; import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set; import java.util.Collections; public class collectionDemo { public static void main(String[] args) { List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); list.add(1); list.add(2); list.add(5); list.add(3); list.add(4); list.add(6); System.out.println(list.toString()); Set\u003cInteger\u003e set = new HashSet\u003c\u003e(); set.add(1); set.add(2); System.out.println(set.toString()); // 测试Collections 工具箱 Collections.sort(list); System.out.println(list.toString()); List\u003cInteger\u003e list1 = Collections.emptyList(); System.out.println(list1.toString()); } } ","date":"2022-01-06","objectID":"/java_learning3/:1:6","tags":["Java","算法"],"title":"Java 学习3-容器","uri":"/java_learning3/"},{"categories":["Java学习"],"content":"1 继承（关键字extends） 父类中私有成员可以被继承，只是外界无法访问 父类中公共属性、方法可以被子类继承 支持单继承，多重继承（单链式继承），不支持多继承（一个类继承多个父类） 子类中的方法重写必须是父类中已有的方法 重写后再次调用父类的方法使用关键字super 例如 super.需要调用父类中的方法; super必须在子类构造器中第一句 重写与重载的区别 重写：方法名、参数跟父类方法一致，只是方法体内容不一样（运行时多态） 重载：方法名一致，形参返回值不一致（编译时多态） Java中，在创建类时，都会默认继承Object类 只要父类构造方法不发生重载（保留无参的） 子类无需改动 需要遵循先构造父类，在构造子类的顺序 ","date":"2022-01-05","objectID":"/java_learning2/:1:0","tags":["Java","算法"],"title":"Java 学习2-继承和接口","uri":"/java_learning2/"},{"categories":["Java学习"],"content":"2 接口 接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合 接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法 接口无法被实例化，但是可以被实现 ","date":"2022-01-05","objectID":"/java_learning2/:2:0","tags":["Java","算法"],"title":"Java 学习2-继承和接口","uri":"/java_learning2/"},{"categories":["Java学习"],"content":"2.1 接口与类的异同点 接口不能用于实例化对象 接口没有构造方法 接口中所有的方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法 接口不能包含成员变量，除了 static 和 final 变量 接口不是被类继承了，而是要被类实现 接口支持多继承 接口和类都可以有多个方法 文件名类似 ","date":"2022-01-05","objectID":"/java_learning2/:2:1","tags":["Java","算法"],"title":"Java 学习2-继承和接口","uri":"/java_learning2/"},{"categories":["Java学习"],"content":"2.2 实例 package objectOriented; //接口demo public interface Animal { static int height = 0; public void eat(); public void travel(); } package objectOriented; public class testAnimal_interface implements Animal{ public void eat(){ System.out.println(\"tiger eat\"); } public void travel(){ System.out.println(\"tiger travel\"); } public int numOfLegs(){ return 0; } public static void main(String[] args) { testAnimal_interface tiger = new testAnimal_interface(); tiger.eat(); tiger.travel(); System.out.println(tiger.numOfLegs()); } } ","date":"2022-01-05","objectID":"/java_learning2/:2:2","tags":["Java","算法"],"title":"Java 学习2-继承和接口","uri":"/java_learning2/"},{"categories":["刷题学习"],"content":"树 和 图 辨析 树的父节点和子节点之间是一条路单向可达 图的的节点之间存在多条路可达 ","date":"2021-11-24","objectID":"/lc_learning9/:1:0","tags":["算法"],"title":"刷题学习9-java 图 知识点graph","uri":"/lc_learning9/"},{"categories":["刷题学习"],"content":"基本概念 顶点 边 邻居节点：只有一条边连接的顶点 度（degree）：一个顶点有几条边，就有几度 ","date":"2021-11-24","objectID":"/lc_learning9/:2:0","tags":["算法"],"title":"刷题学习9-java 图 知识点graph","uri":"/lc_learning9/"},{"categories":["刷题学习"],"content":"图的区分 无向图：边没有方向 有向图 权重图 ","date":"2021-11-24","objectID":"/lc_learning9/:3:0","tags":["算法"],"title":"刷题学习9-java 图 知识点graph","uri":"/lc_learning9/"},{"categories":["刷题学习"],"content":"有向图的基本概念 入度：多少条边指向该顶点 出度：多少条边从这个顶点出发指向其他顶点 ","date":"2021-11-24","objectID":"/lc_learning9/:4:0","tags":["算法"],"title":"刷题学习9-java 图 知识点graph","uri":"/lc_learning9/"},{"categories":["刷题学习"],"content":"EG： 韩：入度为0；出度为2 李：入度为1；出度为1 bishi：入度为2；出度为0 饲：入度为1；出度为1 ","date":"2021-11-24","objectID":"/lc_learning9/:4:1","tags":["算法"],"title":"刷题学习9-java 图 知识点graph","uri":"/lc_learning9/"},{"categories":["刷题学习"],"content":"权重图的基本概念 边上有权重 EG：顶点为城市，边为城市之间的距离，最短路径问题 ","date":"2021-11-24","objectID":"/lc_learning9/:5:0","tags":["算法"],"title":"刷题学习9-java 图 知识点graph","uri":"/lc_learning9/"},{"categories":["刷题学习"],"content":"最短路径常用算法 贝尔曼-福特算法（Bellman Ford） 狄杰斯特拉算法（Dijkstra） DFS BFS ","date":"2021-11-24","objectID":"/lc_learning9/:6:0","tags":["算法"],"title":"刷题学习9-java 图 知识点graph","uri":"/lc_learning9/"},{"categories":["ROS 学习"],"content":"使用github安装 网址：http://www.uco.es/investiga/grupos/ava/node/26 git clone到本地之后，catkin make即可开始使用 ","date":"2021-11-20","objectID":"/aruco_learning/:1:0","tags":["ROS","抓取"],"title":"Aruco配合realsense 使用","uri":"/aruco_learning/"},{"categories":["ROS 学习"],"content":"使用apt安装 sudo apt-get install ros-kinetic-aruco-ros sudo apt-get install ros-kinetic-aruco-msgs sudo apt-get install ros-kinetic-aruco-detect sudo apt-get install ros-kinetic-aruco ","date":"2021-11-20","objectID":"/aruco_learning/:2:0","tags":["ROS","抓取"],"title":"Aruco配合realsense 使用","uri":"/aruco_learning/"},{"categories":["ROS 学习"],"content":"测试使用 roslaunch aruco_ros single.launch 如果没有报错，说明成功 ","date":"2021-11-20","objectID":"/aruco_learning/:3:0","tags":["ROS","抓取"],"title":"Aruco配合realsense 使用","uri":"/aruco_learning/"},{"categories":["ROS 学习"],"content":"网址生成二维码，及其相关信息 http://chev.me/arucogen/ 图片的风格类型 marker ID —–582 尺寸大小（注意这里的单位为mm）—-34mm ","date":"2021-11-20","objectID":"/aruco_learning/:4:0","tags":["ROS","抓取"],"title":"Aruco配合realsense 使用","uri":"/aruco_learning/"},{"categories":["ROS 学习"],"content":"修改launch文件夹中的single.launch文件 更改camera_info为realsense发布的相机内参话题 \u003cremap from=\"/camera_info\" to=\"/camera/color/camera_info\" /\u003e 更改image \u003cremap from=\"/image\" to=\"/camera/color/image_raw\" /\u003e 更改camera_frame \u003cparam name=\"camera_frame\" value=\"/camera_link\"/\u003e 更改Marker ID; marker size \u003carg name=\"markerId\" default=\"582\"/\u003e \u003carg name=\"markerSize\" default=\"0.034\"/\u003e \u003c!-- in m --\u003e ","date":"2021-11-20","objectID":"/aruco_learning/:5:0","tags":["ROS","抓取"],"title":"Aruco配合realsense 使用","uri":"/aruco_learning/"},{"categories":["ROS 学习"],"content":"开始测试 启动realsense节点 roslaunch realsense2_camera rs_camera.launch 启动single.launch 文件 roslaunch aruco_ros single.launch 使用image_view观察识别效果 rosrun image_view image_view image:=/aruco_single/result 查看位姿 rostopic echo /aruco_single/pose 参考：https://blog.csdn.net/qq_34935373/article/details/105098244 ","date":"2021-11-20","objectID":"/aruco_learning/:6:0","tags":["ROS","抓取"],"title":"Aruco配合realsense 使用","uri":"/aruco_learning/"},{"categories":["pointNetGPD"],"content":"资源相关 项目地址 源码地址 论文地址 ","date":"2021-11-18","objectID":"/pointnetgpd_reading/:1:0","tags":["抓取","pointNet"],"title":"1-PointNetGPD论文阅读","uri":"/pointnetgpd_reading/"},{"categories":["pointNetGPD"],"content":"输入输出 input： 点云数据 output： 抓取位姿（6D）(parallel-jaw)方式 ","date":"2021-11-18","objectID":"/pointnetgpd_reading/:2:0","tags":["抓取","pointNet"],"title":"1-PointNetGPD论文阅读","uri":"/pointnetgpd_reading/"},{"categories":["pointNetGPD"],"content":"contribution 网络轻量化 预测夹爪的6D位姿 贡献一个真实的点云抓取数据集 网络模型可以准确的分析出夹爪和抓取物体的几何信息，在点云数据很粗糙的情况下准确度也有保证 ","date":"2021-11-18","objectID":"/pointnetgpd_reading/:3:0","tags":["抓取","pointNet"],"title":"1-PointNetGPD论文阅读","uri":"/pointnetgpd_reading/"},{"categories":["pointNetGPD"],"content":"motivation 现如今的抓取预测方式都是依据RGB和Depth 结合的方式，很少考虑几何信息 PointNet 直接在点云做分割和分类的效果非常好 ","date":"2021-11-18","objectID":"/pointnetgpd_reading/:4:0","tags":["抓取","pointNet"],"title":"1-PointNetGPD论文阅读","uri":"/pointnetgpd_reading/"},{"categories":["pointNetGPD"],"content":"pipeline ","date":"2021-11-18","objectID":"/pointnetgpd_reading/:5:0","tags":["抓取","pointNet"],"title":"1-PointNetGPD论文阅读","uri":"/pointnetgpd_reading/"},{"categories":["pointNetGPD"],"content":"抓取实验评价指标 Meticulous grasp quality scores 包括如下两部分 force-closure GWS analysis ","date":"2021-11-18","objectID":"/pointnetgpd_reading/:6:0","tags":["抓取","pointNet"],"title":"1-PointNetGPD论文阅读","uri":"/pointnetgpd_reading/"},{"categories":["ROS 学习"],"content":"基本概念 urdf 文件， 定义机器人的结构 用于机器人的仿真、 可视化、 tf ROS 的中包含一个urdf包，用来解析urdf文件 ","date":"2021-11-01","objectID":"/ros_learning6/:1:0","tags":["ROS"],"title":"6-URDF","uri":"/ros_learning6/"},{"categories":["ROS 学习"],"content":"描述机器人零部件和零部件之间的关系 link 每个零部件都有自己的link（xyz三个轴） joint 描述两个零部件连接的关节 urdf文件中定义两个link 之间必有一个joint ","date":"2021-11-01","objectID":"/ros_learning6/:2:0","tags":["ROS"],"title":"6-URDF","uri":"/ros_learning6/"},{"categories":["ROS 学习"],"content":"urdf 文件的具体撰写 ","date":"2021-11-01","objectID":"/ros_learning6/:3:0","tags":["ROS"],"title":"6-URDF","uri":"/ros_learning6/"},{"categories":["ROS 学习"],"content":"tf in python 的相关数据类型 tuple list numpy array 四种方式通用 EG： ","date":"2021-11-01","objectID":"/ros_learning5/:1:0","tags":["ROS"],"title":"5-tf in python ","uri":"/ros_learning5/"},{"categories":["ROS 学习"],"content":"四元数、矩阵、欧拉角之间的转换 ","date":"2021-11-01","objectID":"/ros_learning5/:2:0","tags":["ROS"],"title":"5-tf in python ","uri":"/ros_learning5/"},{"categories":["ROS 学习"],"content":"tf.TransformListener 类 构造函数为无参数 tips：查看相对的tf，方法中注意时间要填写为time(0), 不能使用time(now)获取当前时间，因为获取当前的tf消息是空的，需要等待一下才有消息 ","date":"2021-11-01","objectID":"/ros_learning5/:3:0","tags":["ROS"],"title":"5-tf in python ","uri":"/ros_learning5/"},{"categories":["ROS 学习"],"content":"tf.transformBroadcaster 类 构造函数为无参数 ","date":"2021-11-01","objectID":"/ros_learning5/:4:0","tags":["ROS"],"title":"5-tf in python ","uri":"/ros_learning5/"},{"categories":["ROS 学习"],"content":"tf相关指令 根据当前的tf tree 绘制一个PDF图: 接收/tf 消息五秒，然后生成一个树图 rosrun tf view_frames 查看当前的tf tree： 动态显示 rosrun rqt_tf_tree rqt_tf_tree 查看两个frame 之间的变化关系 rosrun tf tf_echo [reference_frame] [target_frame] ","date":"2021-11-01","objectID":"/ros_learning5/:5:0","tags":["ROS"],"title":"5-tf in python ","uri":"/ros_learning5/"},{"categories":["ROS 学习"],"content":"TransFrom 坐标变换（位置+姿态） 坐标系数据的维护工具 ","date":"2021-11-01","objectID":"/ros_learning4/:1:0","tags":["ROS"],"title":"4-tf介绍","uri":"/ros_learning4/"},{"categories":["ROS 学习"],"content":"抓取场景下的坐标转换 涉及的坐标系：基坐标系、摄像头坐标系、机械臂末端坐标系 物体坐标相对于摄像头坐标系-》物体坐标相对于基坐标系 物体坐标相对于夹爪末端坐标系 ","date":"2021-11-01","objectID":"/ros_learning4/:2:0","tags":["ROS"],"title":"4-tf介绍","uri":"/ros_learning4/"},{"categories":["ROS 学习"],"content":"ROS中的tf 一个部件是一个link， 会发布自己的tf消息 与之相连的link， 会接收其tf消息完成连接转化工作（joint工作） ROS中tf表示的意思：标准 话题 工具 接口 ","date":"2021-11-01","objectID":"/ros_learning4/:3:0","tags":["ROS"],"title":"4-tf介绍","uri":"/ros_learning4/"},{"categories":["ROS 学习"],"content":"tf消息格式 ","date":"2021-11-01","objectID":"/ros_learning4/:4:0","tags":["ROS"],"title":"4-tf介绍","uri":"/ros_learning4/"},{"categories":["ROS 学习"],"content":"两个frame之间的tf变化 TransformedStamped.msg seq-序号 stamp-时间戳 frame_id-本frame的id child_frame_id-子frame的id 位置 旋转位姿 很多个节点向/tf 话题发送消息， 形成tf树 ","date":"2021-11-01","objectID":"/ros_learning4/:4:1","tags":["ROS"],"title":"4-tf介绍","uri":"/ros_learning4/"},{"categories":["ROS 学习"],"content":"Client Library 提供ROS编程的库 例如建立node，发布消息，调用服务 提供了如下几种client library ：roscpp、rospy、roslisp ","date":"2021-11-01","objectID":"/ros_learning3/:1:0","tags":["ROS"],"title":"3-roscpp介绍","uri":"/ros_learning3/"},{"categories":["ROS 学习"],"content":"rospy的组成 Node Topic Service Param Time ","date":"2021-11-01","objectID":"/ros_learning3/:2:0","tags":["ROS"],"title":"3-roscpp介绍","uri":"/ros_learning3/"},{"categories":["ROS 学习"],"content":"rospy-Node 相关 ","date":"2021-11-01","objectID":"/ros_learning3/:3:0","tags":["ROS"],"title":"3-roscpp介绍","uri":"/ros_learning3/"},{"categories":["ROS 学习"],"content":"rospy-topic 相关 wait_for_message: 只接收一次消息，不是一直处理消息 publisher-》init: 当中的queue_size, 设置为1， 为异步通信方式， None为同步通信方式 ","date":"2021-11-01","objectID":"/ros_learning3/:4:0","tags":["ROS"],"title":"3-roscpp介绍","uri":"/ros_learning3/"},{"categories":["ROS 学习"],"content":"topic_demo ","date":"2021-11-01","objectID":"/ros_learning3/:5:0","tags":["ROS"],"title":"3-roscpp介绍","uri":"/ros_learning3/"},{"categories":["ROS 学习"],"content":"功能描述： 两个node，一个发布模拟的GPS消息（格式为自定义，包括坐标和工作状态） 另一个node接收并处理该信息（计算到原点的距离） ","date":"2021-11-01","objectID":"/ros_learning3/:5:1","tags":["ROS"],"title":"3-roscpp介绍","uri":"/ros_learning3/"},{"categories":["ROS 学习"],"content":"步骤 建立一个package cd ~/catkin_ws/src catkin_create_pkg topic_demo roscpp rospy std_msg 定义自己的msg文件 cd topic_demo/ mkdir msg cd msg gedit gps.msg 文件内容如下 编写talker.py 编写listener.py 修改CmakeList.txt; package.xml文件 最后执行catkin_make，编译完成之后会在如下路径下生成gps的头文件 使用rosrun运行talker.py和listener.py文件 ","date":"2021-11-01","objectID":"/ros_learning3/:5:2","tags":["ROS"],"title":"3-roscpp介绍","uri":"/ros_learning3/"},{"categories":["ROS 学习"],"content":"ROS常用工具 仿真：Gazebo 调试、可视化：Rviz、rqt 命令行工具：rostopic、roslaunch、rosbag 专用工具：Moveit ","date":"2021-10-28","objectID":"/ros_learning2/:1:0","tags":["ROS"],"title":"2-ROS常用工具","uri":"/ros_learning2/"},{"categories":["ROS 学习"],"content":"Gazebo 机器人仿真工具 ODE、Bullet 等物理引擎 动力学、导航、感知等任务的模拟 ","date":"2021-10-28","objectID":"/ros_learning2/:2:0","tags":["ROS"],"title":"2-ROS常用工具","uri":"/ros_learning2/"},{"categories":["ROS 学习"],"content":"Gazebo 操作 鼠标左键平移， 中键旋转 左侧world：各类物理模型及其属性 左侧insert：可以插入各种模型 ","date":"2021-10-28","objectID":"/ros_learning2/:3:0","tags":["ROS"],"title":"2-ROS常用工具","uri":"/ros_learning2/"},{"categories":["ROS 学习"],"content":"RViz 方便调试和监控的工具 ADD 添加监视器（RbotModel、Laserscan、PointCloud、Camera等） 选中监视器中的topic，进行消息的接收，才能进行可视化 ","date":"2021-10-28","objectID":"/ros_learning2/:4:0","tags":["ROS"],"title":"2-ROS常用工具","uri":"/ros_learning2/"},{"categories":["ROS 学习"],"content":"rqt可视化命令行工具 rqt_graph：显示通信架构（节点和话题的发布状态） rqt_plot：绘制曲线 rqt_console：查看日志 ","date":"2021-10-28","objectID":"/ros_learning2/:5:0","tags":["ROS"],"title":"2-ROS常用工具","uri":"/ros_learning2/"},{"categories":["ROS 学习"],"content":"rosbag ROS命令行工具 记录和回放数据流 回放会将记录的消息重新发布，单独使用回放之前需要roscoe启动master节点 ","date":"2021-10-28","objectID":"/ros_learning2/:6:0","tags":["ROS"],"title":"2-ROS常用工具","uri":"/ros_learning2/"},{"categories":["ROS 学习"],"content":"通信方式 topic service parameter server actionlib ","date":"2021-10-28","objectID":"/ros_learning1/:1:0","tags":["ROS"],"title":"1-ROS通信方式","uri":"/ros_learning1/"},{"categories":["ROS 学习"],"content":"topic 通信方式 异步通信方式 Node间通过publish-subscribe的方式进行通信 topic 发布节点只管发布， 接收节点只管接收 特点 异步通信方式 对于同一个topic可以有多个发送者（例如tf，和rosout），也可以有多个接收者 ","date":"2021-10-28","objectID":"/ros_learning1/:2:0","tags":["ROS"],"title":"1-ROS通信方式","uri":"/ros_learning1/"},{"categories":["ROS 学习"],"content":"Message topic 内容的数据类型—》类 定义在.msg文件当中 包括的类型 ","date":"2021-10-28","objectID":"/ros_learning1/:3:0","tags":["ROS"],"title":"1-ROS通信方式","uri":"/ros_learning1/"},{"categories":["ROS 学习"],"content":"topic 相关命令 列出所有的topic rostopic list 显示某个topic的属性信息 rostopic info /topic_name topic内容 rostopic echo /topic_name 向某个topic发布内容 rostopic pub /topic_name ... 列出所有msg rosmsg list 显示某个msg 的内容 rosmsg show /msg_name ","date":"2021-10-28","objectID":"/ros_learning1/:4:0","tags":["ROS"],"title":"1-ROS通信方式","uri":"/ros_learning1/"},{"categories":["刷题学习"],"content":"基本定义 堆就是一种二叉树结构—完全二叉树 完全二叉树： 1 每个父节点，最多只有两个孩子 2 从上到下，从左到右依次填满 ","date":"2021-10-18","objectID":"/lc_learning8/:1:0","tags":["算法"],"title":"刷题学习8-java 堆 知识点Heap","uri":"/lc_learning8/"},{"categories":["刷题学习"],"content":"堆需要满足的条件： 是一个完全二叉树 每个节点都大于等于孩子节点（最大堆）或者每个每个节点都小于等于孩子节点（最小堆） ","date":"2021-10-18","objectID":"/lc_learning8/:2:0","tags":["算法"],"title":"刷题学习8-java 堆 知识点Heap","uri":"/lc_learning8/"},{"categories":["刷题学习"],"content":"最大堆和最小堆的辨析 根节点：堆顶元素 ","date":"2021-10-18","objectID":"/lc_learning8/:3:0","tags":["算法"],"title":"刷题学习8-java 堆 知识点Heap","uri":"/lc_learning8/"},{"categories":["刷题学习"],"content":"堆常见操作的时间复杂度 访问 Access X 搜索 Search O(1) 堆顶元素 添加 Insert O(logN) 为了满足最大堆或者最小堆的定义，需要进行父节点互换 删除 Delete O(logN) 删除堆顶元素 ","date":"2021-10-18","objectID":"/lc_learning8/:4:0","tags":["算法"],"title":"刷题学习8-java 堆 知识点Heap","uri":"/lc_learning8/"},{"categories":["刷题学习"],"content":"堆化操作的时间复杂度 堆化操作的时间复杂度是O(N)的原理 堆化：将一组无序的数加入到堆里去 堆化：将一组无序的数转化为完全二叉树，然后将完全二叉树转化为最大堆或者最小堆的操作 ","date":"2021-10-18","objectID":"/lc_learning8/:5:0","tags":["算法"],"title":"刷题学习8-java 堆 知识点Heap","uri":"/lc_learning8/"},{"categories":["刷题学习"],"content":"Eg： 有一组数：[10, 9, 7, 12, 16, 8, 5] 构建完全二叉树，结构是唯一的，只需要将数组从头到尾遍历一遍 O(N) 转化为 最小堆｜最大堆 O(N) 整体的时间复杂度为 O(N) ","date":"2021-10-18","objectID":"/lc_learning8/:5:1","tags":["算法"],"title":"刷题学习8-java 堆 知识点Heap","uri":"/lc_learning8/"},{"categories":["刷题学习"],"content":"堆的常见操作 创建堆（最大堆｜最小堆） PriorityQueue\u003cInteger\u003e minHeap = new PriorityQueue\u003c\u003e(); PriorityQueue\u003cInteger\u003e maxHeap = new PriorityQueue\u003c\u003e(Collections.reverseOrder()); 添加元素 minHeap.add(10); minHeap.add(8); minHeap.add(9); minHeap.add(11); minHeap.add(2); maxHeap.add(10); maxHeap.add(8); maxHeap.add(9); maxHeap.add(11); maxHeap.add(2); 获取堆顶元素 System.out.println(minHeap.peek()); System.out.println(maxHeap.peek()); 读取堆顶元素并出堆 minHeap.poll(); System.out.println(minHeap.toString()); maxHeap.poll(); System.out.println(maxHeap.toString()); 堆的长度 System.out.println(minHeap.size()); System.out.println(maxHeap.size()); 堆的遍历 while (!minHeap.isEmpty()){ minHeap.poll(); System.out.println(minHeap.toString()); } while (!maxHeap.isEmpty()){ maxHeap.poll(); System.out.println(maxHeap.toString()); } ","date":"2021-10-18","objectID":"/lc_learning8/:6:0","tags":["算法"],"title":"刷题学习8-java 堆 知识点Heap","uri":"/lc_learning8/"},{"categories":["刷题学习"],"content":"leetcode练习题 215 数组中第k个最大元素 kth largest element in a array 692 前k个高频单词 top k frequent words ","date":"2021-10-18","objectID":"/lc_learning8/:7:0","tags":["算法"],"title":"刷题学习8-java 堆 知识点Heap","uri":"/lc_learning8/"},{"categories":["刷题学习"],"content":"树的基本概念 描述的是节点之间的父子关系 tips： 成环的结构不可能成为树， 因为无法确定父子关系 ","date":"2021-10-16","objectID":"/lc_learning7/:1:0","tags":["算法"],"title":"刷题学习7-java 树知识点Tree","uri":"/lc_learning7/"},{"categories":["刷题学习"],"content":"重要的名词 节点 根节点（开始的节点，没有父节点，具有唯一性） 叶子节点（没有孩子的节点） ","date":"2021-10-16","objectID":"/lc_learning7/:2:0","tags":["算法"],"title":"刷题学习7-java 树知识点Tree","uri":"/lc_learning7/"},{"categories":["刷题学习"],"content":"高度、深度、层 概念辨析 高度：从叶子向根看，从0开始计数 深度：从根向叶子看，从0开始计数 层： 从根向叶子看，从1开始计数 ","date":"2021-10-16","objectID":"/lc_learning7/:3:0","tags":["算法"],"title":"刷题学习7-java 树知识点Tree","uri":"/lc_learning7/"},{"categories":["刷题学习"],"content":"二叉树 普通二叉树：每个节点最多两个孩子 满二叉树：除了叶子节点，每个节点都有左右两个孩子，且所有的叶子节点都在同一层 完全二叉树：从树的根节点，从上到下，从左到右，依次填满节点形成二叉树 tips：如果一个二叉树是满二叉树，那么一定是完全二叉树，反过来不一定 ","date":"2021-10-16","objectID":"/lc_learning7/:4:0","tags":["算法"],"title":"刷题学习7-java 树知识点Tree","uri":"/lc_learning7/"},{"categories":["刷题学习"],"content":"遍历 前序遍历： 根节点、左子树、右子树 中序遍历： 左子树、根节点、右子树 后序遍历： 左子树、右子树，根节点 EG: 前序遍历：A B D E C F G 中序遍历：D B E A F C G 后序遍历：D E B F G C A ","date":"2021-10-16","objectID":"/lc_learning7/:5:0","tags":["算法"],"title":"刷题学习7-java 树知识点Tree","uri":"/lc_learning7/"},{"categories":["刷题学习"],"content":"leetcode 练习题 144 Binary Tree Preorder Traversal 前序遍历 94 Binary Tree Inorder Traversal 中序遍历 145 Binary Tree Postorder Traversal 后序遍历 ","date":"2021-10-16","objectID":"/lc_learning7/:6:0","tags":["算法"],"title":"刷题学习7-java 树知识点Tree","uri":"/lc_learning7/"},{"categories":["kinova"],"content":"我的环境 ubuntu 16.04 64bits ROS Kinetic ","date":"2021-10-14","objectID":"/kinova_ros/:1:0","tags":["ROS","kinova"],"title":"4-Kinova_ros 配置文档","uri":"/kinova_ros/"},{"categories":["kinova"],"content":"Kinova SDK 下载 进入kinova官网 kinovarobotics.com 找到右上角resource， 根据自己kinova机械臂的名称找到对应的资源库，我的是Gen2 选择对应自由度的机械臂，然后找到SDK下载 ","date":"2021-10-14","objectID":"/kinova_ros/:2:0","tags":["ROS","kinova"],"title":"4-Kinova_ros 配置文档","uri":"/kinova_ros/"},{"categories":["kinova"],"content":"Kinova SDK 安装 解压SDK, 切换到目录中 打开终端 cd Ubuntu/16_04/64\\ bits/ 使用.sh文件安装 sudo bash installSDK64.sh 一直下一步即可，　一般是默认安装在opt目录下 ","date":"2021-10-14","objectID":"/kinova_ros/:3:0","tags":["ROS","kinova"],"title":"4-Kinova_ros 配置文档","uri":"/kinova_ros/"},{"categories":["kinova"],"content":"SDK DevelopmentCenter GUI 简单使用 切换到安装目录下 cd /opt/JACO-SDK/GUI/ 运行GUI文件 sudo ./DevelopmentCenter.sh 右上角检测到序列号，　且使用Virtual joystick可以使用说明成功 ","date":"2021-10-14","objectID":"/kinova_ros/:4:0","tags":["ROS","kinova"],"title":"4-Kinova_ros 配置文档","uri":"/kinova_ros/"},{"categories":["kinova"],"content":"Kinova-ros 安装 创建工作空间 mkdir \"~/catkin_ws/src/\" 切换到工作空间 cd ~/catkin_ws/src/ 下载 git clone https://github.com/Kinovarobotics/kinova-ros.git kinova-ros 可以导入到gitee 再下载 编译 cd ~/catkin_ws/ catkin_make 更改bashrc文件 source ~/catkin_ws/devel/setup.bash 此句话加入到bashrc中 ","date":"2021-10-14","objectID":"/kinova_ros/:5:0","tags":["ROS","kinova"],"title":"4-Kinova_ros 配置文档","uri":"/kinova_ros/"},{"categories":["kinova"],"content":"机器人唤醒 TIPS： 注意ROS节点和Development Center不能一起打开 source source devel/setup.bash bringup机械臂 roslaunch kinova_bringup kinova_robot.launch kinova_robotType:=j2n7s300 ","date":"2021-10-14","objectID":"/kinova_jaco2_7dof/:1:0","tags":["ROS","kinova"],"title":"3-kinova jaco2 7dof 机械臂基础控制","uri":"/kinova_jaco2_7dof/"},{"categories":["kinova"],"content":"cartesian 控制模式 重新起一个终端 cd ~/catkin_ws source devel/setup.bash 运行pose_action_client.py 文件 tips： pose参数解释，机器人方向看手 a.非相对（指定6D位置）移动， 不带-r参数 （小）左（大）右 （小）高（大）低 （大）前（小）后 rosrun kinova_demo pose_action_client.py -v j2n7s300 mdeg -- -0.193846275806 -0.265829235315 0.505497992039 94.2 -43.2 -167.1 rosrun kinova_demo pose_action_client.py -v j2n7s300 mdeg -- -0.193846275806 -0.265829235315 0.705497992039 94.2 -43.2 -167.1 rosrun kinova_demo pose_action_client.py -v j2n7s300 mdeg -- -0.193846275806 -0.465829235315 0.505497992039 94.2 -43.2 -167.1 rosrun kinova_demo pose_action_client.py -v j2n7s300 mdeg -- -0.393846275806 -0.265829235315 0.505497992039 94.2 -43.2 -167.1 rosrun kinova_demo pose_action_client.py -v j2n7s300 mdeg -- -0.193846275806 -0.265829235315 0.705497992039 94.2 -43.2 -167.1 b.相对（在当前6D位置基础上）移动，带-r参数 rosrun kinova_demo pose_action_client.py -v -r j2n7s300 mdeg -- 0.01 0 0 0 10 10 ","date":"2021-10-14","objectID":"/kinova_jaco2_7dof/:2:0","tags":["ROS","kinova"],"title":"3-kinova jaco2 7dof 机械臂基础控制","uri":"/kinova_jaco2_7dof/"},{"categories":["kinova"],"content":"手指控制 参数 robotType： j2n7s300 手指移动模式： percent 手指打开程度： 100 100 100（完全闭合） ； 0 0 0（完全打开） 控制命令 rosrun kinova_demo fingers_action_client.py j2n7s300 percent -- 100 100 100 rosrun kinova_demo fingers_action_client.py j2n7s300 percent -- 0 0 0 ","date":"2021-10-14","objectID":"/kinova_jaco2_7dof/:3:0","tags":["ROS","kinova"],"title":"3-kinova jaco2 7dof 机械臂基础控制","uri":"/kinova_jaco2_7dof/"},{"categories":["刷题学习"],"content":"特点 无序 不重复 注重自己独一无二的特性 ","date":"2021-10-13","objectID":"/lc_learning6/:1:0","tags":["算法"],"title":"刷题学习6-java集合Set学习","uri":"/lc_learning6/"},{"categories":["刷题学习"],"content":"主要作用 检查某一个元素是否存在 有无重复元素 ","date":"2021-10-13","objectID":"/lc_learning6/:2:0","tags":["算法"],"title":"刷题学习6-java集合Set学习","uri":"/lc_learning6/"},{"categories":["刷题学习"],"content":"Set的种类 HashSet 主要使用 LinkListSet TreeSet ","date":"2021-10-13","objectID":"/lc_learning6/:3:0","tags":["算法"],"title":"刷题学习6-java集合Set学习","uri":"/lc_learning6/"},{"categories":["刷题学习"],"content":"将一个元素加入到HashSet过程原理 取得元素 通过哈希函数得到哈希值 通过哈希值在哈希表中寻找，如果表中没有此元素，就直接存入到哈希表中 如果有元素，然后进行对比 如果已有元素和当前元素相等，则不做操作 如果不相等，则发生哈希冲突（使用链表方法解决） ","date":"2021-10-13","objectID":"/lc_learning6/:4:0","tags":["算法"],"title":"刷题学习6-java集合Set学习","uri":"/lc_learning6/"},{"categories":["刷题学习"],"content":"哈希集合的操作的时间复杂度 访问：不存在 搜索：无哈希冲突O(1) ，有哈希冲突O(k) —k为冲突元素的个数 插入：无哈希冲突O(1) ，有哈希冲突O(k) —k为冲突元素的个数 删除：无哈希冲突O(1) ，有哈希冲突O(k) —k为冲突元素的个数 ","date":"2021-10-13","objectID":"/lc_learning6/:5:0","tags":["算法"],"title":"刷题学习6-java集合Set学习","uri":"/lc_learning6/"},{"categories":["刷题学习"],"content":"哈希集合的常用操作 创建集合 HashSet\u003cInteger\u003e set = new HashSet\u003c\u003e(); 添加元素 set.add(10); System.out.println(set.add(10)); // 检测到元素重复，添加不成功 add 会返回一个boolean值 set.add(3); set.add(5); set.add(2); set.add(2); System.out.println(set.toString()); 查询元素 System.out.println(set.contains(2)); 删除元素 set.remove(2); System.out.println(set.toString()); 长度 System.out.println(set.size()); ","date":"2021-10-13","objectID":"/lc_learning6/:6:0","tags":["算法"],"title":"刷题学习6-java集合Set学习","uri":"/lc_learning6/"},{"categories":["刷题学习"],"content":"leetcode 练习题 217 Contains Duplicate 存在重复元素 705 Design Hashset 设计哈希集合 ","date":"2021-10-13","objectID":"/lc_learning6/:7:0","tags":["算法"],"title":"刷题学习6-java集合Set学习","uri":"/lc_learning6/"},{"categories":["yoloV5"],"content":"标注方法 自己获取的数据集，人工进行标注（全人工） 自己获取的数据集，首先使用训练好的网络标注一遍，然后手动进行微调（半人工） 仿真数据集（GAN网络来生成自己的数据集– synthetic data） ","date":"2021-10-10","objectID":"/yolov5_owndatasettrain/:1:0","tags":["yoloV5","python","pytorch"],"title":"3-如何制作和训练自己的数据集（YoloV5）","uri":"/yolov5_owndatasettrain/"},{"categories":["yoloV5"],"content":"标注工具 CVAT（需要安装） makesense.ai（在线标注工具） ","date":"2021-10-10","objectID":"/yolov5_owndatasettrain/:2:0","tags":["yoloV5","python","pytorch"],"title":"3-如何制作和训练自己的数据集（YoloV5）","uri":"/yolov5_owndatasettrain/"},{"categories":["yoloV5"],"content":"makesense.ai 标注过程 输入图片 选择Object Detection 创建自己的分类 根据自己的分类开始进行标注（标注的时候也可以使用action中的load models进行半人工标注） 导出文件（action-》export annotation-》yolo format） ","date":"2021-10-10","objectID":"/yolov5_owndatasettrain/:3:0","tags":["yoloV5","python","pytorch"],"title":"3-如何制作和训练自己的数据集（YoloV5）","uri":"/yolov5_owndatasettrain/"},{"categories":["yoloV5"],"content":"文件组织过程 将images和labels分别放入对应的文件夹中 参照coco.yaml， 写自己数据集的配置 # train and val data as 1) directory: path/images/, 2) file: path/images.txt, or 3) list: [path1/images/, path2/images/]train:mydata/images/trainval:mydata/images/train# number of classesnc:3# class namesnames:['person','car','bike'] 修改train.py中的--data参数 parser.add_argument('--data', type=str, default='mydata/mydata.yaml', help='data.yaml path') 运行train.py开始训练 使用detect测试自己训练的模型 修改detect 中的权重文件为自己训练的模型（一般问train当中最新的那个exp） ","date":"2021-10-10","objectID":"/yolov5_owndatasettrain/:4:0","tags":["yoloV5","python","pytorch"],"title":"3-如何制作和训练自己的数据集（YoloV5）","uri":"/yolov5_owndatasettrain/"},{"categories":["yoloV5"],"content":"tips pycharm左侧工程目录文件个数太多了会占用大量的资源（需要检索） 可以右键文件夹，在此处选择exclude， 则可以节省资源 需要有路径的地方，只要路径正确， exclude的文件依然可以找到，知识在目录视图中找不到 ","date":"2021-10-10","objectID":"/yolov5_owndatasettrain/:5:0","tags":["yoloV5","python","pytorch"],"title":"3-如何制作和训练自己的数据集（YoloV5）","uri":"/yolov5_owndatasettrain/"},{"categories":["刷题学习"],"content":"基础定义 键值对：key：value 例如学号姓名： 1：张三 2：李四 3：王五 查找元素的方式不需要从头遍历到尾，直接通过键（key）来进行查找，时间复杂度低 ","date":"2021-10-08","objectID":"/lc_learning5/:1:0","tags":["算法"],"title":"刷题学习5-java 哈希表学习-散列表","uri":"/lc_learning5/"},{"categories":["刷题学习"],"content":"语言的使用 Java—HashMap python—-字典 ","date":"2021-10-08","objectID":"/lc_learning5/:2:0","tags":["算法"],"title":"刷题学习5-java 哈希表学习-散列表","uri":"/lc_learning5/"},{"categories":["刷题学习"],"content":"哈希查找对应元素的机制 ","date":"2021-10-08","objectID":"/lc_learning5/:3:0","tags":["算法"],"title":"刷题学习5-java 哈希表学习-散列表","uri":"/lc_learning5/"},{"categories":["刷题学习"],"content":"哈希碰撞 两个不同的key通过同一个哈希函数，得到相同的内存地址 ","date":"2021-10-08","objectID":"/lc_learning5/:4:0","tags":["算法"],"title":"刷题学习5-java 哈希表学习-散列表","uri":"/lc_learning5/"},{"categories":["刷题学习"],"content":"哈希碰撞解决方法 ","date":"2021-10-08","objectID":"/lc_learning5/:5:0","tags":["算法"],"title":"刷题学习5-java 哈希表学习-散列表","uri":"/lc_learning5/"},{"categories":["刷题学习"],"content":"拉链法 当数组上的某个节点发生Hash冲突时,就把这个节点作为头节点,将新插入的节点挂到这个节点上,形成一个连表,新来的节点通过尾插的形式逐个插入节点 jdk1.8 之后采用链表或者红黑树的方法进行解决 优点：处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短 优点：拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况 优点：在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可 ","date":"2021-10-08","objectID":"/lc_learning5/:5:1","tags":["算法"],"title":"刷题学习5-java 哈希表学习-散列表","uri":"/lc_learning5/"},{"categories":["刷题学习"],"content":"开放地址法 如果当前位置发生了Hash冲突,就在数据里找寻其他没有冲突的位置存放这个数据 ","date":"2021-10-08","objectID":"/lc_learning5/:5:2","tags":["算法"],"title":"刷题学习5-java 哈希表学习-散列表","uri":"/lc_learning5/"},{"categories":["刷题学习"],"content":"再散列法 我们可以再弄另外一个Hash函数，对落在同一个位置的关键字进行再次的Hash ","date":"2021-10-08","objectID":"/lc_learning5/:5:3","tags":["算法"],"title":"刷题学习5-java 哈希表学习-散列表","uri":"/lc_learning5/"},{"categories":["刷题学习"],"content":"各种操作的时间复杂度 访问 X 搜索（无哈希碰撞） O(1) 搜索（有哈希碰撞） O(K) 链表遍历时经过了k个元素 插入 O(1) 删除 O(1) ","date":"2021-10-08","objectID":"/lc_learning5/:6:0","tags":["算法"],"title":"刷题学习5-java 哈希表学习-散列表","uri":"/lc_learning5/"},{"categories":["刷题学习"],"content":"Java 哈希表的常用操作 创建哈希表 // 通过字符串数组创建哈希表 String[] hashTable = new String[4]; // 通过HashMap 库创建哈希表 HashMap\u003cInteger, String\u003e hashMap = new HashMap\u003c\u003e(); 添加 // 添加 hashTable[1] = \"张三\"; hashTable[2] = \"李四\"; hashTable[3] = \"王五\"; // 使用数组的方式将其输出 for(int i = 0; i\u003chashTable.length-1; i++){ System.out.println((i+1)+\"-\"+hashTable[i+1]); } hashMap.put(1, \"张三\"); hashMap.put(2, \"李四\"); hashMap.put(3, \"王五\"); System.out.println(hashMap.toString()); 删除 hashTable[1] = \"\"; for(int i = 0; i\u003chashTable.length-1; i++){ System.out.println((i+1)+\"-\"+hashTable[i+1]); } hashMap.remove(1); System.out.println(hashMap.toString()); 更新元素 hashTable[1] = \"赵四\"; for(int i = 0; i\u003chashTable.length-1; i++){ System.out.println((i+1)+\"-\"+hashTable[i+1]); } hashMap.put(1 , \"赵四\"); 获取元素 System.out.println(hashTable[2]); System.out.println(hashMap.get(2)); 检查key的值是否存在 System.out.println(hashMap.containsKey(3)); 哈希表的长度 System.out.println(hashTable.length);// 有一个内存位置为空，4 System.out.println(hashMap.size()); 哈希表是否还有元素 System.out.println(hashMap.isEmpty()); ","date":"2021-10-08","objectID":"/lc_learning5/:7:0","tags":["算法"],"title":"刷题学习5-java 哈希表学习-散列表","uri":"/lc_learning5/"},{"categories":["刷题学习"],"content":"leetcode 练习题 217 存在重复元素 Contains Duplicate 389 找不同 Find Difference 496 下一个最大元素 Next Great Element ","date":"2021-10-08","objectID":"/lc_learning5/:8:0","tags":["算法"],"title":"刷题学习5-java 哈希表学习-散列表","uri":"/lc_learning5/"},{"categories":["yoloV5"],"content":"parser 参数详解 --weights 初始化模型： 有yolov5m，yolov5s，yolov5x，yolov5l，如果为设置为空就是没有任何与训练模型 --config 训练配置文件：.yaml 文件，与预训练模型相对应。 --data 所使用的数据集的配置文件：.yaml 文件，训练自己的数据集是也需要编辑相应的yaml文件 --hyp 超参数配置文件： 学习率等 --epoch 训练轮数 --batch-size batchsize 大小 --img-size 图片大小 --rect padding之后会有灰色区域的冗余信息，此参数设置为真，可以去除冗余信息 --resume 从之前训练的节点开始训练（已经训练的网络在runs/train/exp文件夹下的pt文件） 发现从此pt权重文件开始继续训练 --nosave 是否只保留最后一个epoch的权重文件 --notest 是否只测试最后一个epoch --noautoanchor （目标检测算法中是否使用锚点、锚框）关闭autoanchor --evolve 进化超参数（寻找最优参数的一种方式） --bucket 没有必要 --cache-images 缓存图片以备更快的训练 --image-weights 上一轮中训练情况不好的图片，在下一轮中加一些相关的权重 --device 训练设备选择 选择cpu或者gpu --multi-scale 对图片的尺寸进行变化 --single-cls 训练的数据集是但类别还是多类别 --adam 优化方法使用adam 优化法 --sync-bn DDP参数 --local_rank DDP参数 --workers 最好设置成0，不然很容易出错 --poject 项目存储位置 --entity W\u0026B 训练可视化的库是否启用 --name 训练结果保存名字 --quad 开启之后在尺寸大于640的图像上识别效果更好，但是有可能会使在640尺寸的图片上效果更差 --Linear-lr 学习速率的变化，如果开启就使用线性的方式进行变化，不开启就使用余弦退火的方式变化 --label-smoothing 防止在分了算法中出现过拟合的情况发生 --save_log 每隔多少个epoch，在tensorboard 中打一个标签 ","date":"2021-10-02","objectID":"/yolov5_train/:1:0","tags":["yoloV5","python","pytorch"],"title":"2-YoloV5 train.py 如何使用","uri":"/yolov5_train/"},{"categories":["kinova"],"content":"安全使用 不要进行剪裁操作，尖锐物体可能会上伤到手臂 关闭的时候会泄力，注意提前用手拖着 关节移动的时候不要限位 ","date":"2021-09-28","objectID":"/kinova_gen2learning2/:1:0","tags":["ROS","kinova"],"title":"2-kinova-gen2 使用学习","uri":"/kinova_gen2learning2/"},{"categories":["kinova"],"content":"部件 手臂主体部件 背面接口部件 USB、网线接口：公kinova SDK 控制使用 switch：开关 8pin口：摇杆控制 4pin口：电源线 ","date":"2021-09-28","objectID":"/kinova_gen2learning2/:2:0","tags":["ROS","kinova"],"title":"2-kinova-gen2 使用学习","uri":"/kinova_gen2learning2/"},{"categories":["kinova"],"content":"控制机械臂 ","date":"2021-09-28","objectID":"/kinova_gen2learning2/:3:0","tags":["ROS","kinova"],"title":"2-kinova-gen2 使用学习","uri":"/kinova_gen2learning2/"},{"categories":["kinova"],"content":"手柄控制 两种控制模式：Cartesian velocity（默认）、Angular velocity 手柄结构： 手柄按键指示表： ","date":"2021-09-28","objectID":"/kinova_gen2learning2/:3:1","tags":["ROS","kinova"],"title":"2-kinova-gen2 使用学习","uri":"/kinova_gen2learning2/"},{"categories":["kinova"],"content":"ROS 控制 具体访问https://github.com/Kinovarobotics/kinova-ros 选择对应ros版本的branch，然后进行安装 ","date":"2021-09-28","objectID":"/kinova_gen2learning2/:3:2","tags":["ROS","kinova"],"title":"2-kinova-gen2 使用学习","uri":"/kinova_gen2learning2/"},{"categories":["kinova"],"content":"3 SDK 控制 C++ library ","date":"2021-09-28","objectID":"/kinova_gen2learning2/:3:3","tags":["ROS","kinova"],"title":"2-kinova-gen2 使用学习","uri":"/kinova_gen2learning2/"},{"categories":["yoloV5"],"content":"pycharm 文件目录展开折叠管理 打开已打开文件的目录 展开所有目录 折叠所有目录 ","date":"2021-09-25","objectID":"/yolov5_macair/:1:0","tags":["m1 mac","yoloV5","python","pytorch"],"title":"1-yoloV5 本地训练 - m1 Mac Air（仅仅是为了调通代码）","uri":"/yolov5_macair/"},{"categories":["yoloV5"],"content":"number of workers 设置 此项为dataloader的载入数据的线程数量 初始运行的时候最好设置成0，由于不同机器的性能不同，数目大了很容易出问题 ","date":"2021-09-25","objectID":"/yolov5_macair/:2:0","tags":["m1 mac","yoloV5","python","pytorch"],"title":"1-yoloV5 本地训练 - m1 Mac Air（仅仅是为了调通代码）","uri":"/yolov5_macair/"},{"categories":["yoloV5"],"content":"导入nnpack 错误，m1 Mac 硬件不支持 在运行detect.py文件时同样报错，应该没有影响 ","date":"2021-09-25","objectID":"/yolov5_macair/:3:0","tags":["m1 mac","yoloV5","python","pytorch"],"title":"1-yoloV5 本地训练 - m1 Mac Air（仅仅是为了调通代码）","uri":"/yolov5_macair/"},{"categories":["yoloV5"],"content":"缺失coco 数据集错误 本地缺失coco128数据集 但是联网之后无法在该网址下载coco128 所有复制链接手动下载 最后复制到指定文件夹 完成后问题解决 开始训练 ","date":"2021-09-25","objectID":"/yolov5_macair/:4:0","tags":["m1 mac","yoloV5","python","pytorch"],"title":"1-yoloV5 本地训练 - m1 Mac Air（仅仅是为了调通代码）","uri":"/yolov5_macair/"},{"categories":["刷题学习"],"content":"问号 ？冒号 ：条件语句 int i = 0; int x = i\u003e1 ? 0:1; 问号冒号将其分为代码分为三个部分A、B、C A？B：C 如果A为真则执行B，如果为假则执行C ","date":"2021-09-23","objectID":"/lc_learning4/:1:0","tags":["算法"],"title":"刷题学习4-java 零碎基础知识","uri":"/lc_learning4/"},{"categories":["刷题学习"],"content":"字符串charAt 函数 String 类型的变量使用 指定index，返回该位置上的字符，返回类型为char类型 ","date":"2021-09-23","objectID":"/lc_learning4/:2:0","tags":["算法"],"title":"刷题学习4-java 零碎基础知识","uri":"/lc_learning4/"},{"categories":["刷题学习"],"content":"String 和 StringBuilder 的使用 ","date":"2021-09-23","objectID":"/lc_learning4/:3:0","tags":["算法"],"title":"刷题学习4-java 零碎基础知识","uri":"/lc_learning4/"},{"categories":["刷题学习"],"content":"初始化 StringBuilder str = new StringBuilder(); ","date":"2021-09-23","objectID":"/lc_learning4/:3:1","tags":["算法"],"title":"刷题学习4-java 零碎基础知识","uri":"/lc_learning4/"},{"categories":["刷题学习"],"content":"增加元素 str.append(1); str.append('a'); str.append(1.2); System.out.println(str.toString()); ","date":"2021-09-23","objectID":"/lc_learning4/:3:2","tags":["算法"],"title":"刷题学习4-java 零碎基础知识","uri":"/lc_learning4/"},{"categories":["刷题学习"],"content":"指定位置增加 str.insert(2, 's'); System.out.println(str.toString()); ","date":"2021-09-23","objectID":"/lc_learning4/:3:3","tags":["算法"],"title":"刷题学习4-java 零碎基础知识","uri":"/lc_learning4/"},{"categories":["刷题学习"],"content":"返回指定位置子序列 System.out.println(str.subSequence(0, 3)); ","date":"2021-09-23","objectID":"/lc_learning4/:3:4","tags":["算法"],"title":"刷题学习4-java 零碎基础知识","uri":"/lc_learning4/"},{"categories":["刷题学习"],"content":"搜索元素 System.out.println(str.indexOf(\"as\")); ","date":"2021-09-23","objectID":"/lc_learning4/:3:5","tags":["算法"],"title":"刷题学习4-java 零碎基础知识","uri":"/lc_learning4/"},{"categories":["刷题学习"],"content":"是否为空 System.out.println(str.isEmpty()); ","date":"2021-09-23","objectID":"/lc_learning4/:3:6","tags":["算法"],"title":"刷题学习4-java 零碎基础知识","uri":"/lc_learning4/"},{"categories":["刷题学习"],"content":"leetcode 题目强化 剑指offer 2 字符串二进制加法 ","date":"2021-09-23","objectID":"/lc_learning4/:4:0","tags":["算法"],"title":"刷题学习4-java 零碎基础知识","uri":"/lc_learning4/"},{"categories":["Java学习"],"content":"class 文件结构 ListNode.java 链表节点类 linkListString.java 链表类 test_ll_string.java 测试文件 ","date":"2021-09-20","objectID":"/java_learning/:1:0","tags":["Java","算法"],"title":"Java 学习1-快速实现自定义字符链表","uri":"/java_learning/"},{"categories":["Java学习"],"content":"ListNode.java val 存放字符串 next 指向下一个节点 构造函数 package linkList_string; public class ListNode { char val; ListNode next; public ListNode(char val) { this.val = val; } } ","date":"2021-09-20","objectID":"/java_learning/:2:0","tags":["Java","算法"],"title":"Java 学习1-快速实现自定义字符链表","uri":"/java_learning/"},{"categories":["Java学习"],"content":"linkListString.java 链表类 头节点head 尾节点tail size 存放链表节点数目 构造函数 成员方法：尾部添加元素 package linkList_string; public class linkListString { ListNode head; ListNode tail; int size; public linkListString() { head = null; tail = null; size = 0; } public void add(char val) { ListNode node = new ListNode(val); if (head == null) { head = node; tail = node; } else { tail.next = node; tail = node; } size++; } } ","date":"2021-09-20","objectID":"/java_learning/:3:0","tags":["Java","算法"],"title":"Java 学习1-快速实现自定义字符链表","uri":"/java_learning/"},{"categories":["Java学习"],"content":"test_ll_string.java 测试文件 实例化linkListString对象 添加节点 package linkList_string; public class test_ll_string { public static void main(String[] args) { linkListString list = new linkListString(); list.add('a'); list.add('b'); list.add('c'); list.add('d'); list.add('e'); list.add('f'); list.add('g'); } } Debug 运行成功 ","date":"2021-09-20","objectID":"/java_learning/:4:0","tags":["Java","算法"],"title":"Java 学习1-快速实现自定义字符链表","uri":"/java_learning/"},{"categories":["刷题学习"],"content":"特点 先进后出，与队列这种数据结构相反，队列是先进先出。 实用例子： 浏览器后退功能 ","date":"2021-09-20","objectID":"/lc_learning3/:1:0","tags":["算法"],"title":"刷题学习3-java 栈学习","uri":"/lc_learning3/"},{"categories":["刷题学习"],"content":"操作的时间复杂度 访问栈顶元素 O(1) 搜索 O(N) 插入 O(1) 入栈 删除 O(1) 出栈 ","date":"2021-09-20","objectID":"/lc_learning3/:2:0","tags":["算法"],"title":"刷题学习3-java 栈学习","uri":"/lc_learning3/"},{"categories":["刷题学习"],"content":"Java栈的常用操作 ","date":"2021-09-20","objectID":"/lc_learning3/:3:0","tags":["算法"],"title":"刷题学习3-java 栈学习","uri":"/lc_learning3/"},{"categories":["刷题学习"],"content":"创建栈 Stack\u003cInteger\u003e stack = new Stack\u003c\u003e(); ","date":"2021-09-20","objectID":"/lc_learning3/:3:1","tags":["算法"],"title":"刷题学习3-java 栈学习","uri":"/lc_learning3/"},{"categories":["刷题学习"],"content":"添加元素 stack.push(1); stack.push(2); stack.push(3); System.out.println(stack.toString()); ","date":"2021-09-20","objectID":"/lc_learning3/:3:2","tags":["算法"],"title":"刷题学习3-java 栈学习","uri":"/lc_learning3/"},{"categories":["刷题学习"],"content":"查看栈顶元素 - 即将出栈的元素 int num = stack.peek(); ","date":"2021-09-20","objectID":"/lc_learning3/:3:3","tags":["算法"],"title":"刷题学习3-java 栈学习","uri":"/lc_learning3/"},{"categories":["刷题学习"],"content":"删除栈顶元素 - 即将出栈的元素 int temp = stack.pop(); System.out.println(temp); ","date":"2021-09-20","objectID":"/lc_learning3/:3:4","tags":["算法"],"title":"刷题学习3-java 栈学习","uri":"/lc_learning3/"},{"categories":["刷题学习"],"content":"返回栈的长度 System.out.println(stack.size()); ","date":"2021-09-20","objectID":"/lc_learning3/:3:5","tags":["算法"],"title":"刷题学习3-java 栈学习","uri":"/lc_learning3/"},{"categories":["刷题学习"],"content":"栈是否为空 System.out.println(\"is empty: \"+stack.isEmpty()); ","date":"2021-09-20","objectID":"/lc_learning3/:3:6","tags":["算法"],"title":"刷题学习3-java 栈学习","uri":"/lc_learning3/"},{"categories":["刷题学习"],"content":"遍历栈 while (!stack.isEmpty()){ System.out.println(stack.pop()); } ","date":"2021-09-20","objectID":"/lc_learning3/:3:7","tags":["算法"],"title":"刷题学习3-java 栈学习","uri":"/lc_learning3/"},{"categories":["刷题学习"],"content":"leetcode 练习题 20 valid Parentheses 有效的括号 496 Next Great Element 下一个最大的元素 ","date":"2021-09-20","objectID":"/lc_learning3/:4:0","tags":["算法"],"title":"刷题学习3-java 栈学习","uri":"/lc_learning3/"},{"categories":["Java学习"],"content":"平台区分 这里指不同的操作系统：macos windows linux ","date":"2021-09-19","objectID":"/java_learning1/:1:0","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"跨平台运行原理 java 语言要想在不同的平台运行， 只需要该平台上有翻译java语言的虚拟机即可 称为 JVM （Java Virtual Machine） ","date":"2021-09-19","objectID":"/java_learning1/:2:0","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"JRE 和 JDK ","date":"2021-09-19","objectID":"/java_learning1/:3:0","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"JRE（Java Runtime Environment） 是Java运行时的环境，包含JVM和运行时所需要的核心类库 运行一个已有的java程序只需要安装JRE即可 ","date":"2021-09-19","objectID":"/java_learning1/:3:1","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"JDK（Java Development Kit） Java程序开发的工具包， 包含JRE和开发人员使用的工具 其中的开发工具：编译工具（javac.exe), 运行工具（java.exe） ","date":"2021-09-19","objectID":"/java_learning1/:3:2","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"总结：JDK、JRE、JVM之间的关系 实际上运行java 只需要一个JDK就可以了 ","date":"2021-09-19","objectID":"/java_learning1/:4:0","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"本机JDK安装 ","date":"2021-09-19","objectID":"/java_learning1/:5:0","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"Java JDK 安装目录 ","date":"2021-09-19","objectID":"/java_learning1/:6:0","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"IDEA HelloWorld 案例操作步骤 ","date":"2021-09-19","objectID":"/java_learning1/:7:0","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"IDEA 的项目结构 项目(Project) \u003e 模块(Module) \u003e 包(Package) \u003e java文件 对应到这个项目当中 项目(Project)—-java_learning 模块(Module)—–idea_test 包(Package)——swagger_test java文件———HelloWorld.java ","date":"2021-09-19","objectID":"/java_learning1/:8:0","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"内容辅助键 ","date":"2021-09-19","objectID":"/java_learning1/:9:0","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"快速生成语句 快速生成main方法：psvm，回车 快速生成输出语句：sout，回车 ","date":"2021-09-19","objectID":"/java_learning1/:9:1","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"内容辅助键 Ctrl+alt+space—-内容提示，代码补全 ","date":"2021-09-19","objectID":"/java_learning1/:9:2","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"快捷键 ","date":"2021-09-19","objectID":"/java_learning1/:10:0","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"注释 command+/ ","date":"2021-09-19","objectID":"/java_learning1/:10:1","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"格式化 command+options+L ","date":"2021-09-19","objectID":"/java_learning1/:10:2","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"IDEA模块操作 新建模块 删除模块 导入模块 ","date":"2021-09-19","objectID":"/java_learning1/:11:0","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["刷题学习"],"content":"队列的基本特征 先进先出 单端队列–只有一个口可以进，一个口可以出 双端队列–两个口都可以进， 两个口都可以出 ","date":"2021-09-17","objectID":"/lc_learning2/:1:0","tags":["算法"],"title":"刷题学习2-java 队列学习","uri":"/lc_learning2/"},{"categories":["刷题学习"],"content":"队列数据结构的特点 访问O(N) 需要从头到尾遍历一遍 搜索O(N) 需要从头到尾遍历一遍 插入O(1) 插入只能在队尾插入，不需要遍历，所以时间复杂度为O(1) 删除O(1) 删除只能在队头删除，不需要遍历，所以时间复杂度为O(1) tips 队列的底层实现是链表 ","date":"2021-09-17","objectID":"/lc_learning2/:2:0","tags":["算法"],"title":"刷题学习2-java 队列学习","uri":"/lc_learning2/"},{"categories":["刷题学习"],"content":"队列的常见操作 创建队列 Queue\u003cInteger\u003e queue = new LinkedList\u003c\u003e(); 添加元素 for (int i = 0; i\u003c 3 ; i++){ queue.add(i+1); } System.out.println(queue.toString()); 获取即将出队的元素 peek() int temp1 = queue.peek(); System.out.println(temp1); 删除即将出队的元素 remove()、pop()、poll() int temp2 = queue.poll(); System.out.println(temp2); System.out.println(queue.toString()); 判断队列是不是为空 System.out.println(queue.isEmpty());//O(1) 队列长度 System.out.println(queue.size());//O(1) 遍历队列（边删除边遍历队列的操作） while (!queue.isEmpty()){ int temp = queue.poll(); System.out.println(temp); }//O(N) ","date":"2021-09-17","objectID":"/lc_learning2/:3:0","tags":["算法"],"title":"刷题学习2-java 队列学习","uri":"/lc_learning2/"},{"categories":["刷题学习"],"content":"leetcode 队列基础练习题 ","date":"2021-09-17","objectID":"/lc_learning2/:4:0","tags":["算法"],"title":"刷题学习2-java 队列学习","uri":"/lc_learning2/"},{"categories":["刷题学习"],"content":"933 最近的请求次数 number of Recent calls 参数使用： 类的成员变量-队列queue、ping函数中变量-temp保存即将出队的元素 构造函数中初始化queue为一个队列 调用ping时首先最新的t入队 while开始条件：队列不为空 查找即将出列元素到存入temp，如果t-temp大于3000，则出列 如果小于，不出列，停止循环，返回队列长度为最终结果 ","date":"2021-09-17","objectID":"/lc_learning2/:4:1","tags":["算法"],"title":"刷题学习2-java 队列学习","uri":"/lc_learning2/"},{"categories":["刷题学习"],"content":"239 滑动窗口最大值 ","date":"2021-09-17","objectID":"/lc_learning2/:4:2","tags":["算法"],"title":"刷题学习2-java 队列学习","uri":"/lc_learning2/"},{"categories":["刷题学习"],"content":"链表与数组的区别 数组的存放为连续的内存空间， 链表不需要，任意碎片式的内存空间都可以形成链表。 ","date":"2021-09-16","objectID":"/lc_learninglistnode/:1:0","tags":["算法"],"title":"刷题学习1.5-java 链表 知识点ListNode","uri":"/lc_learninglistnode/"},{"categories":["刷题学习"],"content":"链表的分类 双端链表：既有next指向下一个数据也有previous指向前一个数据，可以双向遍历。 单端链表：只有next指向下一个数据，只能单向遍历。 ","date":"2021-09-16","objectID":"/lc_learninglistnode/:2:0","tags":["算法"],"title":"刷题学习1.5-java 链表 知识点ListNode","uri":"/lc_learninglistnode/"},{"categories":["刷题学习"],"content":"链表的基本操作 访问—-O(N) 需要遍历，从头找到尾 搜索—-O(N) 需要遍历，从头找到尾 插入—-O(1) 直接需要插入的位置断开指针，使上一个的指针指向新的元素的位置，新元素的下一个指向原本的下一个元素 删除—-O(1) 断开删除元素前一个元素的next指向删除元素的next即可 ","date":"2021-09-16","objectID":"/lc_learninglistnode/:3:0","tags":["算法"],"title":"刷题学习1.5-java 链表 知识点ListNode","uri":"/lc_learninglistnode/"},{"categories":["刷题学习"],"content":"tips 这里的插入删除操作的时间复杂度实际上说的插入或删除这一个操作的时间复杂度。 实际上整个操作的时间复杂度是O(N)，因为需要先查找到元素，遍历到指定位置，再进行插入。 ","date":"2021-09-16","objectID":"/lc_learninglistnode/:3:1","tags":["算法"],"title":"刷题学习1.5-java 链表 知识点ListNode","uri":"/lc_learninglistnode/"},{"categories":["刷题学习"],"content":"应用场景 写多读少的场景 ","date":"2021-09-16","objectID":"/lc_learninglistnode/:4:0","tags":["算法"],"title":"刷题学习1.5-java 链表 知识点ListNode","uri":"/lc_learninglistnode/"},{"categories":["刷题学习"],"content":"java 链表的常见操作 创建链表 LinkedList\u003cInteger\u003e list_1 = new LinkedList\u003c\u003e(); 添加元素 for (int i = 0; i\u003c3 ;i++){ list_1.add(i+1); } System.out.println(list_1.toString()); list_1.add(2,99); System.out.println(list_1.toString()); 访问元素 System.out.println(list_1.get(2)); 查找元素 System.out.println(list_1.indexOf(99)); System.out.println(list_1.indexOf(88)); 删除元素 list_1.remove(2); System.out.println(list_1.toString()); 链表长度 System.out.println(list_1.size()); 更新元素 list_1.set(2, 88); System.out.println(list_1.toString()); ","date":"2021-09-16","objectID":"/lc_learninglistnode/:5:0","tags":["算法"],"title":"刷题学习1.5-java 链表 知识点ListNode","uri":"/lc_learninglistnode/"},{"categories":["刷题学习"],"content":"链表基础leetcode题目 ","date":"2021-09-16","objectID":"/lc_learninglistnode/:6:0","tags":["算法"],"title":"刷题学习1.5-java 链表 知识点ListNode","uri":"/lc_learninglistnode/"},{"categories":["刷题学习"],"content":"1 leetcode 203 删除指定元素 参数设置：head（移动节点）， prev（head的前一个），dummy（保存头节点，最后返回结果） 1 遍历整个链表，入口的条件是链表的头节点不为空（这样最后一个节点也可以遍历到） 2 如果碰到指定值，prev 指向head的下一个节点head移动一步 3 如果没有碰到指定值，prev指向head，head后移一步 4 最后返回头节点（需要有dummy存储头节点）， 最后返回 ","date":"2021-09-16","objectID":"/lc_learninglistnode/:6:1","tags":["算法"],"title":"刷题学习1.5-java 链表 知识点ListNode","uri":"/lc_learninglistnode/"},{"categories":["刷题学习"],"content":"2 leetcode 206 反转链表 参数设置：head（移动节点）， hNext（head的后一个），dummy（保存头节点，最后返回结果），dNext（dummy的后一个节点） dNext = dummy.next; hNext = head.next; dummy.next = hNext; head.next = hNext.next; hNext.next = dNext; ","date":"2021-09-16","objectID":"/lc_learninglistnode/:6:2","tags":["算法"],"title":"刷题学习1.5-java 链表 知识点ListNode","uri":"/lc_learninglistnode/"},{"categories":["kinova"],"content":"注：此方法适用于系统不能通过自检，并自动启动的情况 ","date":"2021-09-14","objectID":"/kinova_launch1/:0:1","tags":["ROS","kinova"],"title":"1-Kinova MOVO 手动启动操作","uri":"/kinova_launch1/"},{"categories":["kinova"],"content":"手动启动bash roslaunch movo_bringup movo_system.launch ","date":"2021-09-14","objectID":"/kinova_launch1/:1:0","tags":["ROS","kinova"],"title":"1-Kinova MOVO 手动启动操作","uri":"/kinova_launch1/"},{"categories":["kinova"],"content":"运行tractor_node脚本，解决MOVO底盘问题 ./tractor_node ","date":"2021-09-14","objectID":"/kinova_launch1/:2:0","tags":["ROS","kinova"],"title":"1-Kinova MOVO 手动启动操作","uri":"/kinova_launch1/"},{"categories":["kinova"],"content":"直连MOVO进行joystick手柄操作 cd /home/movo/movo_ws roslaunch movo_remote_teleop movo_remote_teleop.launch ","date":"2021-09-14","objectID":"/kinova_launch1/:3:0","tags":["ROS","kinova"],"title":"1-Kinova MOVO 手动启动操作","uri":"/kinova_launch1/"},{"categories":["kinova"],"content":"手柄操作方式 操作方式图解，所有的操作除了手指操作，其他的都需要DeadMan按键激活操作 ","date":"2021-09-14","objectID":"/kinova_launch1/:4:0","tags":["ROS","kinova"],"title":"1-Kinova MOVO 手动启动操作","uri":"/kinova_launch1/"},{"categories":["kinova"],"content":"rviz 操作 进入rviz rviz 点击motion planning 中planning Query栏中状态更新，选中状态之后点击update Commands栏中先点击plan，再update ","date":"2021-09-14","objectID":"/kinova_launch1/:5:0","tags":["ROS","kinova"],"title":"1-Kinova MOVO 手动启动操作","uri":"/kinova_launch1/"},{"categories":["刷题学习"],"content":"时间复杂度 时间复杂度即为代码的执行次数量级 算法的执行时间与输入之间的关系 ","date":"2021-09-08","objectID":"/lc_learning/:1:0","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"O(1) 常量数量级的时间复杂度, 没有for循环和while循环 ","date":"2021-09-08","objectID":"/lc_learning/:1:1","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"O(N) 常量不看，其中total=0，return total为常量执行次数 只有一层循环，循环的执行次数为N ","date":"2021-09-08","objectID":"/lc_learning/:1:2","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"O(logN) 常量不看，其中i=1，return i 为常量执行次数 i=i*2的执行次数为log2(N)，舍去2，则最后结果为O(logN) ","date":"2021-09-08","objectID":"/lc_learning/:1:3","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"O(M+N) 同理常量次数不看 两个O(N)，一个执行M次，一个执行N次 组合之后变成O(M+N)， 实际上等同于O(N) ","date":"2021-09-08","objectID":"/lc_learning/:1:4","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"O(NlogN) 同理常量次数不看 N次执行次数的循环内嵌套了一个logN次执行次数的循环 总次数为二者相乘即为O(NlogN) ","date":"2021-09-08","objectID":"/lc_learning/:1:5","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"O(N2) N次执行次数的循环内嵌套了一个N次执行次数的循环 总次数为二者相乘即为O(N2) ","date":"2021-09-08","objectID":"/lc_learning/:1:6","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"时间复杂度的判断方式 首先看有没有循环，没有则为常量次数O(1) 如果有，首先判断每一次循环的执行次数 循环之间的嵌套使用相乘的方式，得出最终的时间复杂度 ","date":"2021-09-08","objectID":"/lc_learning/:1:7","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"各个时间复杂度之间的比较 O(1) \u003c O(logN) \u003c O(N) \u003c O(NlogN) \u003c O(N2) \u003c O(2N) \u003c O(N!) 二分查找：O(logN) 堆排序：O(NlogN) 冒泡排序：O(N2) 快速排序：O(N2) 选择排序：O(N2) 二叉树排序：O(N2) 插入排序：O(N2) ","date":"2021-09-08","objectID":"/lc_learning/:1:8","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"空间复杂度 算法的存储空间和算法的关系 占空间的都是声明出来的变量 ","date":"2021-09-08","objectID":"/lc_learning/:2:0","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"O(1) 存储的变量为常数数量级 total在初始化之后虽然在循环当中被重复赋值，但是始终只占用total的空间 所以存储的变量为常数数量级 ","date":"2021-09-08","objectID":"/lc_learning/:2:1","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"O(N) 存储的数量级为N，循环的次数 数组的内的数字在不断增多，不断开辟新的内存空间 ","date":"2021-09-08","objectID":"/lc_learning/:2:2","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"tip1 arrary = [] for num in nums: array.append(num) return arrary 空间占用分为堆空间和栈空间 在for循环中条件部分申明的变量 num 开辟的空间为栈空间 使用完毕就会释放 而其他变量使用的是堆空间，程序完成之后才会释放 ","date":"2021-09-08","objectID":"/lc_learning/:3:0","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"tip2 递归的函数内本身的空间复杂度如果为O(1)， 则调用递归的空间复杂度为O(N) 递归的函数内本身的空间复杂度如果为O(N)， 则调用递归的空间复杂度为O(N2) ","date":"2021-09-08","objectID":"/lc_learning/:4:0","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["Latex"],"content":"算法加入 在tex 文件开头引用以下包： algorithm、algorithmics、algpseudocode、amsmath \\usepackage{algorithm} \\usepackage{algorithmicx} \\usepackage{algpseudocode} \\usepackage{amsmath} f 如果算法中包含输入输出模块，还应加入如下代码： \\renewcommand{\\algorithmicrequire}{\\textbf{Input:}} % Use Input in the format of Algorithm \\renewcommand{\\algorithmicensure}{\\textbf{Output:}} % Use Output in the format of Algorithm 算法主体 \\begin{algorithm}[thpb] \\caption{algorithm name} \\label{algorithmlabel} \\begin{algorithmic}[1] \\Require algorithm input \\Ensure algorithm output \\State algorithm content1; \\While{while loop} \\State algorithm content2;\\EndWhile \\\\ \\Return algorithm output. \\end{algorithmic} \\end{algorithm} 完成之后呈现为这种状态 注意： 在while之后不要忘记endwhile while内部的代码会自动缩近 ","date":"2021-09-08","objectID":"/latex_learning2/:1:0","tags":["Latex"],"title":"Latex 语法学习笔记2","uri":"/latex_learning2/"},{"categories":["Latex"],"content":"各种文件 .bib 存放参考文献 .tex 文献源码 .bst 参考文献风格，与.bib组合使用 .sty 风格文件 ","date":"2021-09-08","objectID":"/latex_learning2/:2:0","tags":["Latex"],"title":"Latex 语法学习笔记2","uri":"/latex_learning2/"},{"categories":["Latex"],"content":"overleaf 使用 overleaf 左下角为文章结构 方便快速定位到tex代码文件的位置 ","date":"2021-09-08","objectID":"/latex_learning1/:1:0","tags":["Latex"],"title":"Latex 语法学习笔记1","uri":"/latex_learning1/"},{"categories":["Latex"],"content":"图片的插入与引用 插入 \\begin{figure}[t] \\centering \\includegraphics[scale=0.25]{intro.png} \\caption{描述} \\label{pic-label} \\vspace{-0.4cm} \\end{figure} \\centering 放置位置剧中 \\includegraphics[scale=0.25]{intro.png} 图片名称（同一目录下）及大小 \\caption{描述}图片下方的描述 \\label{pic-label}图片的引用 引用 Fig. \\ref{pic-label} 此处的pic-label 即为图片插入时的图片引用 ","date":"2021-09-08","objectID":"/latex_learning1/:2:0","tags":["Latex"],"title":"Latex 语法学习笔记1","uri":"/latex_learning1/"},{"categories":["Latex"],"content":"文献的插入与引用 首先bib文件中加入此格式的代码 @article{cosio2004autonomous, title={Autonomous robot navigation using adaptive potential fields}, author={Cos{\\'\\i}o, F Arambula and Casta{\\~n}eda, MA Padilla}, journal={Mathematical and Computer Modelling}, volume={40}, number={9-10}, pages={1141--1156}, year={2004} } 在tex文件中加入对bib文件和bst文献的支持 \\bibliographystyle{IEEEtranS} \\bibliography{IEEEexample} 最后在tex文件中引用该文献， 此处引用label为 cosio2004autonomous ~\\cite{cosio2004autonomous} ","date":"2021-09-08","objectID":"/latex_learning1/:3:0","tags":["Latex"],"title":"Latex 语法学习笔记1","uri":"/latex_learning1/"}]