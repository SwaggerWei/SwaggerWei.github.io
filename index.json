[{"categories":["Java网络编程"],"content":"TCP 实现文件上传 ","date":"2022-05-13","objectID":"/java_net2/:1:0","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"客户端 创建一个Socket连接 创建一个输出流，用于发送TCP连接中的数据 创建一个文件输入流fis，用于读取文件 通过文件输入流fis，将文件写出到输出流os中 通过shutdownOutput提示服务器已经传输完毕 确定服务器已经接收完毕了 最后关闭资源，顺序和创建顺序相反 tips：注意尽量不要抛出，否则会有很多异常需要抛出，尽量用try catch来处理 package com.swagger.lesson02; import java.io.*; import java.net.InetAddress; import java.net.Socket; import java.net.UnknownHostException; // TCP上传文件 客户端发送 public class TCPClientDemo02 { public static void main(String[] args) throws IOException { // 尽量不要抛出，否则会有很多异常需要抛出 // 1 创建一个Socket连接 Socket socket = new Socket(InetAddress.getByName(\"127.0.0.1\"), 9000); // 2 创建一个输出流 OutputStream os = socket.getOutputStream(); // 3 读取文件 FileInputStream fis = new FileInputStream(new File(\"pic.png\")); // 4 写出文件 到输出流 os中去 byte[] buffer = new byte[1024]; int len; while ((len = fis.read(buffer)) != -1){ os.write(buffer); } // 5 通知服务器，我已经结束了 socket.shutdownOutput();// 我已经传输完了 // 6 确定服务端接收完毕了 InputStream inputStream = socket.getInputStream(); ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] buffer2 = new byte[1024]; int len2; while ((len2 = inputStream.read(buffer2)) != -1){ baos.write(buffer2); } System.out.println(baos.toString()); // 7 关闭资源，关闭顺序和创建顺序相反 baos.close(); inputStream.close(); fis.close(); os.close(); socket.close(); } } ","date":"2022-05-13","objectID":"/java_net2/:1:1","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"服务端 创建一个服务 监听客户端的请求连接，阻塞式监听，会一直等待客户端的连接请求 读取客户端的消息, 获取输入流 读取文件，将文件进行输出 通知客户端我已经接收完了 关闭资源 package com.swagger.lesson02; import java.io.*; import java.net.ServerSocket; import java.net.Socket; // TCP上传文件 服务端接收端 public class TCPServerDemo02 { public static void main(String[] args) throws IOException { // 1 创建一个服务 ServerSocket serverSocket = new ServerSocket(9000); // 2 监听客户端的请求连接 // 阻塞式监听，会一直等待客户端的连接请求 Socket socket = serverSocket.accept(); // 3 读取客户端的消息, 获取输入流 InputStream is = socket.getInputStream(); // 4 读取文件，将文件进行输出 FileOutputStream fileOutputStream = new FileOutputStream(new File(\"received.png\")); byte[] buffer = new byte[1024]; int len; while ((len = is.read(buffer)) != -1){ fileOutputStream.write(buffer, 0, len); } // 5 通知客户端我已经接收完了 OutputStream outputStream = socket.getOutputStream(); outputStream.write(\"我接受完毕了，你可以断开了\".getBytes()); // 6 关闭资源 fileOutputStream.close(); is.close(); socket.close(); serverSocket.close(); } } ","date":"2022-05-13","objectID":"/java_net2/:1:2","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"Tomcat tomcat是一个免费的，开放源代码的Web应用服务器，是Apache软件基金会项目中的一个核心项目，由Apache ，Sun和一些公司以及个人共同开发而成，深受Java爱好者的喜爱，是一款比较流行的web应用服务器 可以自定义服务端和客户端，就像前文的TCP实现消息传输和文件上传一样 也可以使用已经写好的开源Web应用服务项目Tomcat ","date":"2022-05-13","objectID":"/java_net2/:2:0","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"Tomcat 核心组件 web容器:完成web服务器的功能 servlet容器:名字为catalina，用于处理Servlet代码。 JSP容器:用于将JSP动态网页翻译成Servlet代码 因此Tomcat是web应用服务器，也是一个Servlet/JSP容器。Tomcat作为 Servlet容器，负责处理客户请求，把请求传送给servlet，并将servlet的响应传送回给客户 ","date":"2022-05-13","objectID":"/java_net2/:2:1","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"什么是servlet Servlet 是 Java Servlet 的简称，可以理解为是一个服务连接器，是用Java编写的服务器端程序，具有独立于平台和协议的特性，简单的理解: servlet就是一个中间件，包含了接口和方法，将客户端和数据库连接，从而实现动态网页的创建 ","date":"2022-05-13","objectID":"/java_net2/:2:2","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"什么是JSP JSP 全称 Java Server Pages，是一种动态网页开发技术。它使用JSP 标签在HTML,网页中插入Java代码。标签通常以 \u003c% 开头，以 %\u003e 结束。 JSP是一种Java servlet，主要用于实现Java web 应用程序的用户界面部分 JSP通过网页表单获取用户输入数据、访问数据库及其他数据源，然后动态地创建网页 ","date":"2022-05-13","objectID":"/java_net2/:2:3","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"Tomcat 功能组件结构 负责接收和反馈外部请求的连接器Connector，和负责处理请求的容器Container 连接器和容器相辅相成，一起构成了基本的 web服务Service。每个Tomcat服务器可以管理多个Service Conector: 负责对外接收和响应请求。它是Tomcat与外界的交通枢纽，监听端口接收外界请求，并将请求处理后传递给容器做业务处理，最后将容器处理后的结果响应给外界 Container: 负责对内处理业务逻辑。其内部由 Engine、Host、Context和wrapper 四个容器组成，用于管理和调用Servlet相关逻辑 Service:对外提供的web服务。主要包含Connector和 Container两个核心组件，以及其他功能组件。Tomcat可以管理多个Service，且各Service 之间相互独立 ","date":"2022-05-13","objectID":"/java_net2/:2:4","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"Container结构分析 每个Service 会包含一个Container容器。在Container内部包含了4个子容器:4个子容器的作用分别是 Engine:引擎，用来管理多个虚拟主机，一个Service最多只能有一个Engine； Host:代表一个虚拟主机，也可以叫站点，通过配置 Host 就可以添加站点 Context:代表一个 web 应用，包含多个Servlet封装器 wrapper:封装器，容器的最底层。每一Wrapper封装着一个Servlet，负责对象实例的创建、执行和销毁功能 Engine、Host、Context和 wrapper，这四个容器之间属于父子关系。 容器由一个引擎可以管理多个虚拟主机。每个虚拟主机可以管理多个web应用。每个web应用会有多个Servlet封装器 ","date":"2022-05-13","objectID":"/java_net2/:2:5","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"Tomcat请求过程 用户在浏览器中输入网址，请求被发送到本机端口8080，被在那里监听的 Connector获得； Connector 把该请求交给它所在的Service 的 Engine (Container）来处理，并等待Engine的回应; 请求在Engine、Host、Context和Wwrapper 这四个容器之间层层调用，最后在Servlet 中执行对应的业务逻辑、数据存储等 执行完之后的请求响应在Context、Host、Engine容器之间层层返回，最后返回给Connector，并通过Connector 返回给客户端 ","date":"2022-05-13","objectID":"/java_net2/:2:6","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"UDP消息发送 不用连接上，就可以发送消息，只用知道对方的地址 ","date":"2022-05-13","objectID":"/java_net2/:3:0","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"客户端 建立一个UDP Socket 建一个数据包 指明packet中的参数，说明发送给谁 发送数据包 关闭流close 不需要服务器端打开就可以发送消息，不保证消息的一定可达，所以直接运行客户端是不报错的 package com.swagger.lesson03; import java.io.IOException; import java.net.*; public class UdpClientDemo01 { public static void main(String[] args) throws IOException { // 1 建立一个UDP Socket DatagramSocket socket = new DatagramSocket(); // 2 建一个数据包 String msg = \"你好服务器\"; // 3 发送给谁 InetAddress inetAddress = InetAddress.getByName(\"localhost\"); int port = 9090; DatagramPacket packet = new DatagramPacket(msg.getBytes(), 0, msg.getBytes().length, inetAddress, port); // 4 发送数据包 socket.send(packet); // 5 关闭流 socket.close(); // 不需要服务器端打开就可以发送消息，不保证消息的一定可达，所以直接运行客户端是不报错的 } } ","date":"2022-05-13","objectID":"/java_net2/:3:1","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"接收端 开放端口 接收数据包，并且打印接收的数据 关闭连接 实际上不存在TCP中的服务端，因为服务端也可以用客户端的方式发送消息 package com.swagger.lesson03; import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.SocketException; // 只有保持服务端在监听状态，才能接收到数据包 public class UdpServerDemo01 { public static void main(String[] args) throws IOException { // 1 开放端口 DatagramSocket socket = new DatagramSocket(9090); // 2 接收数据包 byte[] buffer = new byte[1024]; DatagramPacket packet = new DatagramPacket(buffer, 0, buffer.length); socket.receive(packet); System.out.println(packet.getAddress().getHostAddress()); System.out.println(new String(packet.getData(), 0, packet.getLength())); // 3 关闭连接 socket.close(); } } ","date":"2022-05-13","objectID":"/java_net2/:3:2","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"UDP聊天实现 ","date":"2022-05-13","objectID":"/java_net2/:4:0","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"发送方 新建一个UDP Socket 新建一个Buffer Reader 用于读取发送的消息 新建一个UDP Packet ，并将发送的数据填入其中，发送 如果检测到bye，字样的消息，则结束 消息可以循环发送 最后关闭socket package com.swagger.lesson04_chat; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; import java.net.SocketException; public class UdpSenderDemo01 { public static void main(String[] args) throws IOException { DatagramSocket socket = new DatagramSocket(8888); // 准备数据：控制台读取数据 System.in BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); while (true){ String data = reader.readLine(); byte[] datas = data.getBytes(); InetAddress inetAddress = InetAddress.getByName(\"localhost\"); int port = 6666; DatagramPacket packet = new DatagramPacket(datas, 0, datas.length, inetAddress, port); socket.send(packet); if (data.equals(\"bye\")){ break; } } socket.close(); } } ","date":"2022-05-13","objectID":"/java_net2/:4:1","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"接收方 新建一个UDP Socket 新建一个UDP Packet，并将接收到的数据填入到容器中 阻塞式接收包裹 socket.receive(packet); 使用packet中的getData 取出接收的数据 打印出接收的消息 检测如果消息为bye，则停止接收消息 package com.swagger.lesson04_chat; import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.SocketException; public class UdpReceiverDemo01 { public static void main(String[] args) throws IOException { DatagramSocket socket = new DatagramSocket(6666); while (true){ // 准备接收包裹 byte[] container = new byte[1024]; DatagramPacket packet = new DatagramPacket(container, 0, container.length); socket.receive(packet); // 阻塞式接收包裹 // 断开连接 如果为bye，则断开连接 byte[] data = packet.getData(); String receive_data = new String(data, 0, packet.getLength()); System.out.println(receive_data); if (receive_data.equals(\"bye\")){ break; } } socket.close(); } } ","date":"2022-05-13","objectID":"/java_net2/:4:2","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"UDP多线程实现咨询 多线程实现 聊天的双方都需要有发送线程和接收线程 互相之间的发送线程和接收线程需要对应 ","date":"2022-05-13","objectID":"/java_net2/:5:0","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"发送线程类 实现Runnable接口即可 package com.swagger.lesson04_chat; import java.io.BufferedReader; import java.io.InputStreamReader; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; import java.net.InetSocketAddress; public class TalkSend implements Runnable{ DatagramSocket socket = null; BufferedReader reader = null; private int fromPort; private String toIP; private int toPort; public TalkSend(int fromPort, String toIP, int toPort) { this.fromPort = fromPort; this.toIP = toIP; this.toPort = toPort; try{ socket = new DatagramSocket(this.fromPort); reader = new BufferedReader(new InputStreamReader(System.in)); }catch (Exception e){ e.printStackTrace(); } } @Override public void run() { while (true){ try{ String data = reader.readLine(); byte[] datas = data.getBytes(); InetAddress inetAddress = InetAddress.getByName(\"localhost\"); int port = 6666; DatagramPacket packet = new DatagramPacket(datas, 0, datas.length, new InetSocketAddress(this.toIP, this.toPort)); socket.send(packet); if (data.equals(\"bye\")){ break; } }catch (Exception e){ e.printStackTrace(); } } socket.close(); } } ","date":"2022-05-13","objectID":"/java_net2/:5:1","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"接收线程类 实现Runnable 接口 package com.swagger.lesson04_chat; import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; public class TalkReceive implements Runnable{ DatagramSocket socket = null; private int port; private String msgFrom; public TalkReceive(int port, String msgFrom) { this.port = port; this.msgFrom = msgFrom; try{ socket = new DatagramSocket(port); }catch (Exception e){ e.printStackTrace(); } } @Override public void run() { while (true){ try { // 准备接收包裹 byte[] container = new byte[1024]; DatagramPacket packet = new DatagramPacket(container, 0, container.length); socket.receive(packet); // 阻塞式接收包裹 // 断开连接 如果为bye，则断开连接 byte[] data = packet.getData(); String receive_data = new String(data, 0, packet.getLength()); System.out.println(msgFrom+\":\"+receive_data); if (receive_data.equals(\"bye\")){ break; } } catch (IOException e) { e.printStackTrace(); } } socket.close(); } } ","date":"2022-05-13","objectID":"/java_net2/:5:2","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["Java网络编程"],"content":"聊天双方 均同时创建发送和接收线程 总共四个线程之间在通信 package com.swagger.lesson04_chat; public class TalkStudent { public static void main(String[] args) { // 开启线程 // 静态代理模式 new Thread(new TalkSend(777, \"localhost\", 9999)).start(); new Thread(new TalkReceive(8888, \"老师\")).start(); } } package com.swagger.lesson04_chat; public class TalkTeacher { public static void main(String[] args) { // 开启线程 // 静态代理模式 new Thread(new TalkSend(5555, \"localhost\", 8888)).start(); new Thread(new TalkReceive(9999, \"学生\")).start(); } } ","date":"2022-05-13","objectID":"/java_net2/:5:3","tags":["Java","网络编程"],"title":"Java网络编程学习2","uri":"/java_net2/"},{"categories":["小开发"],"content":" 游戏名：贪吃蛇 github 地址：https://github.com/SwaggerWei/SnakeGame ","date":"2022-05-12","objectID":"/develop_gamesnake/:0:0","tags":["Java游戏","awt","swing"],"title":"贪吃蛇开发","uri":"/develop_gamesnake/"},{"categories":["小开发"],"content":"资源导入 ","date":"2022-05-12","objectID":"/develop_gamesnake/:1:0","tags":["Java游戏","awt","swing"],"title":"贪吃蛇开发","uri":"/develop_gamesnake/"},{"categories":["小开发"],"content":"步骤 单独定一个资源类，所有的数据变量都定义为静态变量，方便获取 使用 java.net.URL 获取文件地址 然后转换为swing中的ImageIcon格式 ","date":"2022-05-12","objectID":"/develop_gamesnake/:1:1","tags":["Java游戏","awt","swing"],"title":"贪吃蛇开发","uri":"/develop_gamesnake/"},{"categories":["小开发"],"content":"源码 package com.swagger.snake; import javax.swing.*; import java.net.URL; // 存放外部数据 public class Data { // 头部图片 使用URL类，定位图片地址 public static URL headerUrl = Data.class.getResource(\"/statics/header1.png\"); public static ImageIcon header = new ImageIcon(headerUrl); // // 头部图片 public static URL upUrl = Data.class.getResource(\"/statics/up1.png\"); public static URL downUrl = Data.class.getResource(\"/statics/down1.png\"); public static URL leftUrl = Data.class.getResource(\"/statics/left1.png\"); public static URL rightUrl = Data.class.getResource(\"/statics/right1.png\"); public static ImageIcon up = new ImageIcon(upUrl); public static ImageIcon down = new ImageIcon(downUrl); public static ImageIcon left = new ImageIcon(leftUrl); public static ImageIcon right = new ImageIcon(rightUrl); // // 身体 public static URL bodyUrl1 = Data.class.getResource(\"/statics/body1.png\"); public static ImageIcon body1 = new ImageIcon(bodyUrl1); // // 食物 public static URL foodUrl = Data.class.getResource(\"/statics/food1.png\"); public static ImageIcon food = new ImageIcon(foodUrl); } ","date":"2022-05-12","objectID":"/develop_gamesnake/:1:2","tags":["Java游戏","awt","swing"],"title":"贪吃蛇开发","uri":"/develop_gamesnake/"},{"categories":["小开发"],"content":"绘制主窗口 ","date":"2022-05-12","objectID":"/develop_gamesnake/:2:0","tags":["Java游戏","awt","swing"],"title":"贪吃蛇开发","uri":"/develop_gamesnake/"},{"categories":["小开发"],"content":"步骤 使用JFrame绘制一个静态窗口 设置页面打洗哦啊 设置窗口是否可调整大小 设置关闭事件,可以通过右上角叉叉进行关闭 加入一个JPanel到JFrame窗口当中 设置窗口的可见性，这一步应该放到最后，不然画板中的内容不能生效 ","date":"2022-05-12","objectID":"/develop_gamesnake/:2:1","tags":["Java游戏","awt","swing"],"title":"贪吃蛇开发","uri":"/develop_gamesnake/"},{"categories":["小开发"],"content":"源码 package com.swagger.snake; import javax.swing.*; public class StartGames { public static void main(String[] args) { // 1 绘制一个静态窗口 JFrame JFrame jFrame = new JFrame(\"swagger-Java-贪吃蛇小游戏\"); // 设置页面大小 jFrame.setBounds(10, 10, 900, 720); // 设置窗口是否可调整大小 jFrame.setResizable(true); // 设置关闭事件,可以通过右上角叉叉进行关闭 jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 2 面板 JPanel 可以加入到JFrame jFrame.add(new GamePanel()); // 设置窗口的可见性，这一步应该放到最后，不然画板中的内容不能生效 jFrame.setVisible(true); } } ","date":"2022-05-12","objectID":"/develop_gamesnake/:2:2","tags":["Java游戏","awt","swing"],"title":"贪吃蛇开发","uri":"/develop_gamesnake/"},{"categories":["小开发"],"content":"GamePanel 类：继承JPanel，实现KeyListener和ActionListener ","date":"2022-05-12","objectID":"/develop_gamesnake/:3:0","tags":["Java游戏","awt","swing"],"title":"贪吃蛇开发","uri":"/develop_gamesnake/"},{"categories":["小开发"],"content":"构造函数 调用init() 完成各种初始化操作 获取键盘监听事件，是的键盘聚焦到游戏上，然后添加一个键盘监听者 让事件定义的Timer实例动起来start public GamePanel(){ init(); // 获取键盘的监听事件 this.setFocusable(true);// 键盘聚焦到游戏上 this.addKeyListener(this); // 时间动起来 timer.start(); } ","date":"2022-05-12","objectID":"/develop_gamesnake/:3:1","tags":["Java游戏","awt","swing"],"title":"贪吃蛇开发","uri":"/develop_gamesnake/"},{"categories":["小开发"],"content":"初始化init 初始化长度和蛇头蛇身坐标 初始化食物坐标，注意不能和蛇重合 初始化分数为0 public void init(){ length = 3; snakeX[0] = 100; snakeY[0] = 100; // 蛇头坐标 snakeX[1] = 75; snakeY[1] = 100; // 第一节身体坐标 snakeX[2] = 50; snakeY[2] = 100; // 蛇头坐标 boolean isFoodCoveredByBody = false; while (true){ // 重新生成食物坐标 foodx = 25 + 25 * random.nextInt(34); foody = 75 + 25 * random.nextInt(24); for (int i = 0; i \u003c length; i++) { if (foodx == snakeX[i] \u0026\u0026 foody == snakeY[i]){ isFoodCoveredByBody = true; } } if (isFoodCoveredByBody == true){ continue; }else { break; } } score = 0; } ","date":"2022-05-12","objectID":"/develop_gamesnake/:3:2","tags":["Java游戏","awt","swing"],"title":"贪吃蛇开发","uri":"/develop_gamesnake/"},{"categories":["小开发"],"content":"绘制静态画板 调用父类，达到清屏效果 设置背景的颜色 从Data中获取header绘制头部广告栏 绘制游戏区域 画一条静态小蛇，注意头方向的判断，然后绘制身体 画积分，设置画积分的各种参数 画一个食物 提示游戏开始，注意判断是否为开始状态 失败提醒，注意判断是否为失败状态 protected void paintComponent(Graphics g) { // 1 绘制静态面板 // 调用父类，达到清屏效果 super.paintComponent(g); // 设置背景的颜色 this.setBackground(Color.WHITE); // 绘制头部广告栏 Data.header.paintIcon(this, g, 25, 11); // 绘制游戏区域 g.fillRect(25, 75, 850, 600); // 2 画一条静态的小蛇 // 画蛇头 if (direction.equals(\"R\")){ Data.right.paintIcon(this, g, snakeX[0], snakeY[0]); }else if (direction.equals(\"L\")){ Data.left.paintIcon(this, g, snakeX[0], snakeY[0]); }else if (direction.equals(\"U\")){ Data.up.paintIcon(this, g, snakeX[0], snakeY[0]); }else if (direction.equals(\"D\")){ Data.down.paintIcon(this, g, snakeX[0], snakeY[0]); } // 画蛇身体 for (int i = 1; i \u003c length; i++) { // 蛇的身体长度，通过length 参数来控制 Data.body1.paintIcon(this, g, snakeX[i], snakeY[i]); } String font = \"微软雅黑\"; // 字体类型 // 3 画积分 g.setColor(Color.WHITE); // 设置画笔的颜色 g.setFont(new Font(font, Font.BOLD, 18)); g.drawString(\"长度：\" + length, 750, 30); g.drawString(\"分数：\" + score, 750, 50); // 4 画一个食物 Data.food.paintIcon(this, g, foodx, foody); // 5 游戏提示，是否开始 if (isStart == false){ // 画一个文字 g.setColor(Color.WHITE); // 设置画笔的颜色 g.setFont(new Font(font, Font.BOLD, 40)); g.drawString(\"按下空格开始游戏\", 300, 300); } // 6 失败提醒 if (isFail == true){ // 画一个文字 g.setColor(Color.RED); // 设置画笔的颜色 g.setFont(new Font(font, Font.BOLD, 40)); g.drawString(\"游戏失败，按下空格重新开始\", 200, 300); } } ","date":"2022-05-12","objectID":"/develop_gamesnake/:3:3","tags":["Java游戏","awt","swing"],"title":"贪吃蛇开发","uri":"/develop_gamesnake/"},{"categories":["小开发"],"content":"接受键盘输入 空格键控制暂停和开始，注意首先判断是否为失败状态，如果为失败状态，则重新init，重制各项数据，如果没有失败则进把是否开始状态置反 接受键盘输入，改变方向，注意控制相反方向不能改变 public void keyPressed(KeyEvent e) { // 键盘：按下（未释放） // 获取按下的键盘是哪一个键 int keyCode = e.getKeyCode(); if (keyCode == KeyEvent.VK_SPACE){ // 如果按下的是空格键 if (isFail == true){ isFail = false; init(); // 重新初始化游戏 }else { isStart = !isStart; } // 刷新界面 repaint(); } // 键盘控制走向 if (keyCode == KeyEvent.VK_LEFT){ if (direction != \"R\"){direction = \"L\";} }else if (keyCode == KeyEvent.VK_RIGHT){ if (direction != \"L\"){direction = \"R\";} }else if (keyCode == KeyEvent.VK_UP){ if (direction != \"D\"){direction = \"U\";} }else if (keyCode == KeyEvent.VK_DOWN){ if (direction != \"U\"){direction = \"D\";} } } ","date":"2022-05-12","objectID":"/develop_gamesnake/:3:4","tags":["Java游戏","awt","swing"],"title":"贪吃蛇开发","uri":"/develop_gamesnake/"},{"categories":["小开发"],"content":"actionPerformed 首先身体移动，再移动头部，注意控制边界判断 判断蛇头是否和食物重合，如果重合则重新生成食物，注意重新生成的食物不能和蛇重合 进行失败判断，蛇头不能和蛇身重合 刷新界面repaint，进入下一帧 public void actionPerformed(ActionEvent e) { // 如果游戏处于开始状态, 并且游戏没有失败 if (isStart \u0026\u0026 isFail == false){ for (int i = length - 1; i \u003e 0 ; i--) { // 身体移动 snakeX[i] = snakeX[i-1]; snakeY[i] = snakeY[i-1]; } // 通过控制方向让头部移动 if (direction == \"R\"){ if (snakeX[0] \u003e 825){snakeX[0] = 0;}// 边界判断 snakeX[0] = snakeX[0] + 25; // 头部移动 }else if (direction == \"L\"){ if (snakeX[0] \u003c 50){snakeX[0] = 825;}// 边界判断 snakeX[0] = snakeX[0] - 25; // 头部移动 }else if (direction == \"U\"){ if (snakeY[0] \u003c 100){snakeY[0] = 675;}// 边界判断 snakeY[0] = snakeY[0] - 25; // 头部移动 }else if (direction == \"D\"){ if (snakeY[0] \u003e 625){snakeY[0] = 75;}// 边界判断 snakeY[0] = snakeY[0] + 25; // 头部移动 } // 如果蛇头和食物的坐标重合，说明吃到了食物 if (snakeX[0] == foodx \u0026\u0026 snakeY[0] == foody){ // 蛇的长度+1 length ++; score = score+10; // 重新生成食物 // 如果重新生成的食物坐标和蛇身或者头部相重合，则重新生成 boolean isFoodCoveredByBody = false; while (true){ // 重新生成食物坐标 foodx = 25 + 25 * random.nextInt(34); foody = 75 + 25 * random.nextInt(24); for (int i = 0; i \u003c length; i++) { if (foodx == snakeX[i] \u0026\u0026 foody == snakeY[i]){ isFoodCoveredByBody = true; } } if (isFoodCoveredByBody == true){ continue; }else { break; } } } // 失败判断 for (int i = 1; i \u003c length; i++) { if (snakeX[0] == snakeX[i] \u0026\u0026 snakeY[0] == snakeY[i]){ isFail = true; } } // 刷新界面 this.repaint(); } timer.start();// 时间动起来 } ","date":"2022-05-12","objectID":"/develop_gamesnake/:3:5","tags":["Java游戏","awt","swing"],"title":"贪吃蛇开发","uri":"/develop_gamesnake/"},{"categories":["小开发"],"content":"源码 package com.swagger.snake; import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.KeyEvent; import java.awt.event.KeyListener; import java.util.Random; public class GamePanel extends JPanel implements KeyListener, ActionListener{ // 定义一个蛇 int length; // 蛇的长度 int[] snakeX = new int[600];// 蛇的坐标X int[] snakeY = new int[500];// 蛇的坐标Y boolean isStart = false;// 游戏是否开始 String direction = \"R\";// 蛇的方向 Timer timer = new Timer(100, this); // 间隔100ms 触发一次 // 定义一个食物 int foodx; int foody; Random random = new Random(); // 判断失败 boolean isFail = false; // 游戏积分榜 int score; // 构造函数 public GamePanel(){ init(); // 获取键盘的监听事件 this.setFocusable(true);// 键盘聚焦到游戏上 this.addKeyListener(this); // 时间动起来 timer.start(); } // 初始化 public void init(){ length = 3; snakeX[0] = 100; snakeY[0] = 100; // 蛇头坐标 snakeX[1] = 75; snakeY[1] = 100; // 第一节身体坐标 snakeX[2] = 50; snakeY[2] = 100; // 蛇头坐标 boolean isFoodCoveredByBody = false; while (true){ // 重新生成食物坐标 foodx = 25 + 25 * random.nextInt(34); foody = 75 + 25 * random.nextInt(24); for (int i = 0; i \u003c length; i++) { if (foodx == snakeX[i] \u0026\u0026 foody == snakeY[i]){ isFoodCoveredByBody = true; } } if (isFoodCoveredByBody == true){ continue; }else { break; } } score = 0; } // 画板： 画界面、画蛇 // Graphics：为一个画笔 @Override protected void paintComponent(Graphics g) { // 1 绘制静态面板 // 调用父类，达到清屏效果 super.paintComponent(g); // 设置背景的颜色 this.setBackground(Color.WHITE); // 绘制头部广告栏 Data.header.paintIcon(this, g, 25, 11); // 绘制游戏区域 g.fillRect(25, 75, 850, 600); // 2 画一条静态的小蛇 // 画蛇头 if (direction.equals(\"R\")){ Data.right.paintIcon(this, g, snakeX[0], snakeY[0]); }else if (direction.equals(\"L\")){ Data.left.paintIcon(this, g, snakeX[0], snakeY[0]); }else if (direction.equals(\"U\")){ Data.up.paintIcon(this, g, snakeX[0], snakeY[0]); }else if (direction.equals(\"D\")){ Data.down.paintIcon(this, g, snakeX[0], snakeY[0]); } // 画蛇身体 for (int i = 1; i \u003c length; i++) { // 蛇的身体长度，通过length 参数来控制 Data.body1.paintIcon(this, g, snakeX[i], snakeY[i]); } String font = \"微软雅黑\"; // 字体类型 // 3 画积分 g.setColor(Color.WHITE); // 设置画笔的颜色 g.setFont(new Font(font, Font.BOLD, 18)); g.drawString(\"长度：\" + length, 750, 30); g.drawString(\"分数：\" + score, 750, 50); // 4 画一个食物 Data.food.paintIcon(this, g, foodx, foody); // 5 游戏提示，是否开始 if (isStart == false){ // 画一个文字 g.setColor(Color.WHITE); // 设置画笔的颜色 g.setFont(new Font(font, Font.BOLD, 40)); g.drawString(\"按下空格开始游戏\", 300, 300); } // 6 失败提醒 if (isFail == true){ // 画一个文字 g.setColor(Color.RED); // 设置画笔的颜色 g.setFont(new Font(font, Font.BOLD, 40)); g.drawString(\"游戏失败，按下空格重新开始\", 200, 300); } } // 接受键盘输入 @Override public void keyPressed(KeyEvent e) { // 键盘：按下（未释放） // 获取按下的键盘是哪一个键 int keyCode = e.getKeyCode(); if (keyCode == KeyEvent.VK_SPACE){ // 如果按下的是空格键 if (isFail == true){ isFail = false; init(); // 重新初始化游戏 }else { isStart = !isStart; } // 刷新界面 repaint(); } // 键盘控制走向 if (keyCode == KeyEvent.VK_LEFT){ if (direction != \"R\"){direction = \"L\";} }else if (keyCode == KeyEvent.VK_RIGHT){ if (direction != \"L\"){direction = \"R\";} }else if (keyCode == KeyEvent.VK_UP){ if (direction != \"D\"){direction = \"U\";} }else if (keyCode == KeyEvent.VK_DOWN){ if (direction != \"U\"){direction = \"D\";} } } // 定时器，监听时间 帧：执行定时操作 @Override public void actionPerformed(ActionEvent e) { // 如果游戏处于开始状态, 并且游戏没有失败 if (isStart \u0026\u0026 isFail == false){ for (int i = length - 1; i \u003e 0 ; i--) { // 身体移动 snakeX[i] = snakeX[i-1]; snakeY[i] = snakeY[i-1]; } // 通过控制方向让头部移动 if (direction == \"R\"){ if (snakeX[0] \u003e 825){snakeX[0] = 0;}// 边界判断 snakeX[0] = snakeX[0] + 25; // 头部移动 }else if (direction == \"L\"){ if (snakeX[0] \u003c 50){snakeX[0] = 825;}// 边界判断 snakeX[0] = snakeX[0] - 25; // 头部移动 }else if (direction == \"U\"){ if (snakeY[0] \u003c 100){snakeY[0] = 675;}// 边界判断 snakeY[0] = snakeY[0] - 25; // 头部移动 }else if (direction == \"D\"){ if (snakeY[0] \u003e 625){snakeY[0] = 75;}// 边界判断 snakeY[0] = snakeY[0] + 25; // 头部移动 } // 如果蛇头和食物的坐标重合，说明吃到了食物 if (snakeX[0] == foodx \u0026\u0026 snakeY[0] == foody){ // 蛇的长度+1 length ++; score = score+1","date":"2022-05-12","objectID":"/develop_gamesnake/:3:6","tags":["Java游戏","awt","swing"],"title":"贪吃蛇开发","uri":"/develop_gamesnake/"},{"categories":["pytorch"],"content":"Loss损失函数与反向传播 ","date":"2022-05-11","objectID":"/pytorch_learning2/:1:0","tags":["Pytorch","深度学习"],"title":"pytorch学习2","uri":"/pytorch_learning2/"},{"categories":["pytorch"],"content":"loss 损失函数 描述输出与真实值之间的差距 为更新输出提供一定的证据 ","date":"2022-05-11","objectID":"/pytorch_learning2/:1:1","tags":["Pytorch","深度学习"],"title":"pytorch学习2","uri":"/pytorch_learning2/"},{"categories":["pytorch"],"content":"L1Loss 衡量Groud Truth 和 output 之间的平均绝对误差 MAE（Mean Absolute Error）平均绝对误差 ","date":"2022-05-11","objectID":"/pytorch_learning2/:1:2","tags":["Pytorch","深度学习"],"title":"pytorch学习2","uri":"/pytorch_learning2/"},{"categories":["pytorch"],"content":"MSELoss MSE Mean square Error 平局平方误差 ","date":"2022-05-11","objectID":"/pytorch_learning2/:1:3","tags":["Pytorch","深度学习"],"title":"pytorch学习2","uri":"/pytorch_learning2/"},{"categories":["pytorch"],"content":"CrossEntropyLoss 交叉熵误差， 适用于分类问题 输入参数：target 真实分类数、x 每一个类别的可能性数组 EG：target = 0 在第0,1,2三个类别中属于第1类；x = [0.2, 0.3, 0.1] (对应每一种类别的可能性) ","date":"2022-05-11","objectID":"/pytorch_learning2/:1:4","tags":["Pytorch","深度学习"],"title":"pytorch学习2","uri":"/pytorch_learning2/"},{"categories":["pytorch"],"content":"反向传播 计算完loss之后反向传播, 计算每个节点梯度 每一次计算出一个每一个数据计算出一个loss，就会对应一个梯度；然后根据梯度进行下降，更新参数节点，达到使得loss 越来越小的机制 ","date":"2022-05-11","objectID":"/pytorch_learning2/:1:5","tags":["Pytorch","深度学习"],"title":"pytorch学习2","uri":"/pytorch_learning2/"},{"categories":["pytorch"],"content":"各种loss源码测试 import torch from torch import nn input = torch.tensor([1, 2, 3], dtype=float) target = torch.tensor([1, 2, 5], dtype=float) input = torch.reshape(input, (1, 1, 1, 3)) target = torch.reshape(target, (1, 1, 1, 3)) # loss = nn.L1Loss(reduction=\"sum\") loss_mae = nn.L1Loss() loss_mse = nn.MSELoss() output_mae = loss_mae(input, target) output_mse = loss_mse(input, target) print(output_mae) print(output_mse) ","date":"2022-05-11","objectID":"/pytorch_learning2/:1:6","tags":["Pytorch","深度学习"],"title":"pytorch学习2","uri":"/pytorch_learning2/"},{"categories":["pytorch"],"content":"loss 训练测试 import torchvision from torch import nn from torch.nn import Sequential, Conv2d, MaxPool2d from torch.nn import Flatten, Linear, CrossEntropyLoss from torch.utils.data import DataLoader # 准备数据集 # 代码在src中， 把数据集下载到 \"../data\"， 也就是退到上一层目录， 新建一个目data dataset = torchvision.datasets.CIFAR10(\"../data\", train=False, transform=torchvision.transforms.ToTensor(), download=True) # 将数据转换为tensor数据类型 一个batch为64 dataloader = DataLoader(dataset=dataset, batch_size=1) class SwaggerCifar(nn.Module): def __init__(self): super(SwaggerCifar, self).__init__() self.model1 = Sequential( Conv2d(in_channels=3, out_channels=32, kernel_size=5, stride=1, padding=2), MaxPool2d(kernel_size=2), Conv2d(in_channels=32, out_channels=32, kernel_size=5, stride=1, padding=2), MaxPool2d(kernel_size=2), Conv2d(in_channels=32, out_channels=64, kernel_size=5, stride=1, padding=2), MaxPool2d(kernel_size=2), Flatten(), Linear(in_features=1024, out_features=64), Linear(in_features=64, out_features=10) ) def forward(self, x): x = self.model1(x) return x swagger = SwaggerCifar() # print(swagger) # 创建loss函数 loss = CrossEntropyLoss() # 从dataloader中取数据 for data in dataloader: imgs, targets = data outputs = swagger(imgs) loss_result = loss(input=outputs, target=targets) loss_result.backward() # print(outputs) # print(targets) print(loss_result) ","date":"2022-05-11","objectID":"/pytorch_learning2/:1:7","tags":["Pytorch","深度学习"],"title":"pytorch学习2","uri":"/pytorch_learning2/"},{"categories":["pytorch"],"content":"optim优化器使用 ","date":"2022-05-11","objectID":"/pytorch_learning2/:2:0","tags":["Pytorch","深度学习"],"title":"pytorch学习2","uri":"/pytorch_learning2/"},{"categories":["pytorch"],"content":"原理 在求出loss之后执行backward 得到每个节点的梯度（gradient） 然后使用优化器进行优化 ","date":"2022-05-11","objectID":"/pytorch_learning2/:2:1","tags":["Pytorch","深度学习"],"title":"pytorch学习2","uri":"/pytorch_learning2/"},{"categories":["pytorch"],"content":"常用的优化器及其参数 Adam optimizer SGD optimizer 参数：模型参数、学习率LR、momentum ","date":"2022-05-11","objectID":"/pytorch_learning2/:2:2","tags":["Pytorch","深度学习"],"title":"pytorch学习2","uri":"/pytorch_learning2/"},{"categories":["pytorch"],"content":"SGD optimizer 在循环外定义一个优化器 型中上一步计算的梯度进行清零 输入经过网络 计算loss 反向传播计算梯度 梯度下降法更新梯度 ","date":"2022-05-11","objectID":"/pytorch_learning2/:2:3","tags":["Pytorch","深度学习"],"title":"pytorch学习2","uri":"/pytorch_learning2/"},{"categories":["pytorch"],"content":"学习率设置 太大容易模型优化不稳定 太小模型一直是保持正向优化， 但是优化速度过慢 应该设置一个合适的学习率 或者开始的时候设置一个大的学习率，在后期设置一个小的学习率 ","date":"2022-05-11","objectID":"/pytorch_learning2/:2:4","tags":["Pytorch","深度学习"],"title":"pytorch学习2","uri":"/pytorch_learning2/"},{"categories":["pytorch"],"content":"源码测试 import torchvision from torch import nn, optim from torch.nn import Sequential, Conv2d, MaxPool2d from torch.nn import Flatten, Linear, CrossEntropyLoss from torch.utils.data import DataLoader # 准备数据集 # 代码在src中， 把数据集下载到 \"../data\"， 也就是退到上一层目录， 新建一个目data dataset = torchvision.datasets.CIFAR10(\"../data\", train=False, transform=torchvision.transforms.ToTensor(), download=True) # 将数据转换为tensor数据类型 一个batch为64 dataloader = DataLoader(dataset=dataset, batch_size=64) class SwaggerCifar(nn.Module): def __init__(self): super(SwaggerCifar, self).__init__() self.model1 = Sequential( Conv2d(in_channels=3, out_channels=32, kernel_size=5, stride=1, padding=2), MaxPool2d(kernel_size=2), Conv2d(in_channels=32, out_channels=32, kernel_size=5, stride=1, padding=2), MaxPool2d(kernel_size=2), Conv2d(in_channels=32, out_channels=64, kernel_size=5, stride=1, padding=2), MaxPool2d(kernel_size=2), Flatten(), Linear(in_features=1024, out_features=64), Linear(in_features=64, out_features=10) ) def forward(self, x): x = self.model1(x) return x swagger = SwaggerCifar() # print(swagger) # 创建loss函数 loss = CrossEntropyLoss() # 定义optimizer optimizer = optim.SGD(swagger.parameters(), lr=0.01) # 从dataloader中取数据 for epoch in range(20): loss_per_epoch = 0.0 for data in dataloader: # 清零上一个循环计算的梯度grad optimizer.zero_grad() # 取数据 imgs, targets = data # 数据输入进神经网络 outputs = swagger(imgs) # 计算loss loss_result = loss(input=outputs, target=targets) # 反向传播计算梯度 loss_result.backward() # 优化器根据梯度对网络参数进行更新（step） optimizer.step() loss_per_epoch = loss_per_epoch + loss_result # print(outputs) # print(targets) # print(loss_result) print(loss_per_epoch) ","date":"2022-05-11","objectID":"/pytorch_learning2/:2:5","tags":["Pytorch","深度学习"],"title":"pytorch学习2","uri":"/pytorch_learning2/"},{"categories":["pytorch"],"content":"完整模型训练验证源码 # -*- coding:utf-8 -*- import torch import torchvision from torch import nn, optim from torch.nn import Sequential, Conv2d, MaxPool2d from torch.nn import Flatten, Linear, CrossEntropyLoss from torch.utils.data import DataLoader from torch.utils.tensorboard import SummaryWriter gpu_device = 7 train_data = torchvision.datasets.CIFAR10(\"../data_cifar10\", train=True, transform=torchvision.transforms.ToTensor(), download=True) test_data = torchvision.datasets.CIFAR10(\"../data_cifar10\", train=False, transform=torchvision.transforms.ToTensor(), download=True) train_data_size = train_data.__len__() test_data_size = test_data.__len__() print(\"train dataset length: {}\".format(train_data_size)) print(\"test dataset length: {}\".format(test_data_size)) batchsize = 64 train_dataloader = DataLoader(train_data, batch_size=batchsize) test_dataloader = DataLoader(test_data, batch_size=batchsize) class SwaggerCifar(nn.Module): def __init__(self): super(SwaggerCifar, self).__init__() self.module1 = Sequential( Conv2d(in_channels=3, out_channels=32, kernel_size=5, stride=1, padding=2), MaxPool2d(kernel_size=2), Conv2d(in_channels=32, out_channels=32, kernel_size=5, stride=1, padding=2), MaxPool2d(kernel_size=2), Conv2d(in_channels=32, out_channels=64, kernel_size=5, stride=1, padding=2), MaxPool2d(kernel_size=2), Flatten(), Linear(in_features=1024, out_features=64), Linear(in_features=64, out_features=10) ) def forward(self, x): x = self.module1(x) return x swagger = SwaggerCifar() if torch.cuda.is_available(): swagger = swagger.cuda(gpu_device) loss = CrossEntropyLoss() if torch.cuda.is_available(): loss = loss.cuda(gpu_device) learing_rate = 0.01 optimizer = optim.SGD(swagger.parameters(), learing_rate) writer = SummaryWriter(\"../logs_cifar\") total_train_step = 0 total_test_step = 0 epoch = 2 for i in range(epoch): print(\"------the {}th epoch------\".format(i + 1)) total_train_loss = 0.0 swagger.train() for data in train_dataloader: imgs, targets = data if torch.cuda.is_available(): imgs = imgs.cuda(gpu_device) targets = targets.cuda(gpu_device) outputs = swagger(imgs) loss_result = loss(input=outputs, target=targets) optimizer.zero_grad() loss_result.backward() optimizer.step() total_train_step = total_train_step + 1 total_train_loss = total_train_loss + loss_result if total_train_step % 50 == 0: print(\"train step: {}, loss: {}\".format(total_train_step, loss_result.item())) writer.add_scalar(\"train_loss\", loss_result.item(), total_train_step) swagger.eval() total_test_loss = 0.0 total_accuracy = 0.0 with torch.no_grad(): for data in test_dataloader: imgs, targets = data if torch.cuda.is_available(): imgs = imgs.cuda(gpu_device) targets = targets.cuda(gpu_device) outputs = swagger(imgs) loss_result = loss(input=outputs, target=targets) total_test_loss = total_test_loss + loss_result.item() preds = outputs.argmax(1) accuracy = (preds == targets).sum() total_accuracy = total_accuracy + accuracy.item() print(\"total test loss: {}\".format(total_test_loss)) print(\"total accuracy: {}\".format(total_accuracy / test_data_size)) writer.add_scalar(\"test_loss\", total_test_loss, total_test_step) writer.add_scalar(\"test_accuracy\", total_accuracy / test_data_size, total_test_step) total_test_step = total_test_step + 1 torch.save(swagger, \"../models/swagger_cifar_{}.pth\".format(i)) print(\"The model has been saved\") writer.close() ","date":"2022-05-11","objectID":"/pytorch_learning2/:3:0","tags":["Pytorch","深度学习"],"title":"pytorch学习2","uri":"/pytorch_learning2/"},{"categories":["pytorch"],"content":"卷机层的使用 ","date":"2022-05-11","objectID":"/pytorch_learning/:1:0","tags":["Pytorch","深度学习"],"title":"pytorch学习1","uri":"/pytorch_learning/"},{"categories":["pytorch"],"content":"准备数据集 定义自己的数据集：做必要的transform等 定义自己数据集的data、label dataset = torchvision.datasets.CIFAR10(\"../data_cifar10\", train=False, transform=torchvision.transforms.ToTensor(), download=False) ","date":"2022-05-11","objectID":"/pytorch_learning/:1:1","tags":["Pytorch","深度学习"],"title":"pytorch学习1","uri":"/pytorch_learning/"},{"categories":["pytorch"],"content":"根据数据集准备dataloader 输入batchsize， dataset等参数 dataloader = DataLoader(dataset=dataset, batch_size=64) ","date":"2022-05-11","objectID":"/pytorch_learning/:1:2","tags":["Pytorch","深度学习"],"title":"pytorch学习1","uri":"/pytorch_learning/"},{"categories":["pytorch"],"content":"定义自己的网络结构 继承父辈的init函数 定义自己的网络结构-卷积层：输入通道数、输出通道数、卷机核大小等参数 定义前向传播：依次前向顺序调用自己的各个层 class SwaggerConv(nn.Module): def __init__(self): super(SwaggerConv, self).__init__() self.conv1 = Conv2d(in_channels=3, out_channels=6, kernel_size=3, stride=1, padding=0) # 前向传播， 输入为x， 输出为y def forward(self, x): y = self.conv1(x) return y ","date":"2022-05-11","objectID":"/pytorch_learning/:1:3","tags":["Pytorch","深度学习"],"title":"pytorch学习1","uri":"/pytorch_learning/"},{"categories":["pytorch"],"content":"后续操作 实例化网络结构 通过dataloader 取数据 将取出的数据 输送入网络结构当中 前向传播得到输出 将输出写入到tensorboard日志当中 swagger = SwaggerConv() writer = SummaryWriter(\"../logs\") step = 0 for data in dataloader: imgs, targets = data output = swagger(imgs) # 原图写入到tensorboard当中 writer.add_images(\"input\", img_tensor=imgs, global_step=step) # 经过卷积之后的图像 # output为6通道，无法在tensorboard中以图片的格式显示， # 将其使用reshape 改成三通道（不严谨操作方式） output = torch.reshape(output, (-1, 3, 30, 30)) writer.add_images(\"output\", img_tensor=output, global_step=step) step = step + 1 writer.close() ","date":"2022-05-11","objectID":"/pytorch_learning/:1:4","tags":["Pytorch","深度学习"],"title":"pytorch学习1","uri":"/pytorch_learning/"},{"categories":["pytorch"],"content":"测试源码 # 卷积层的使用 torch.nn.Conv2d import torch import torchvision from torch.utils.data import DataLoader from torch import nn from torch.nn import Conv2d from torch.utils.tensorboard import SummaryWriter # 准备数据集 # 代码在src中， 把数据集下载到 \"../data\"， 也就是退到上一层目录， 新建一个目data # dataset = torchvision.datasets.CIFAR10(\"../data\", train=False, transform=torchvision.transforms.ToTensor(), # download=True) # 不下载该数据集download=False，数据集在本地的路径为../data_cifar10， dataset = torchvision.datasets.CIFAR10(\"../data_cifar10\", train=False, transform=torchvision.transforms.ToTensor(), download=False) # 将数据转换为tensor数据类型 一个batch为64 dataloader = DataLoader(dataset=dataset, batch_size=64) # 定义自己的网络结构， 输入通道为3， 输出通道为6（意味着有两个卷积核）， 卷积核的大小为3， 步长为1， 不增加padding class SwaggerConv(nn.Module): def __init__(self): super(SwaggerConv, self).__init__() self.conv1 = Conv2d(in_channels=3, out_channels=6, kernel_size=3, stride=1, padding=0) # 前向传播， 输入为x， 输出为y def forward(self, x): y = self.conv1(x) return y swagger = SwaggerConv() writer = SummaryWriter(\"../logs\") step = 0 for data in dataloader: imgs, targets = data output = swagger(imgs) # 原图写入到tensorboard当中 writer.add_images(\"input\", img_tensor=imgs, global_step=step) # 经过卷积之后的图像 # output为6通道，无法在tensorboard中以图片的格式显示， # 将其使用reshape 改成三通道（不严谨操作方式） output = torch.reshape(output, (-1, 3, 30, 30)) writer.add_images(\"output\", img_tensor=output, global_step=step) step = step + 1 writer.close() ","date":"2022-05-11","objectID":"/pytorch_learning/:1:5","tags":["Pytorch","深度学习"],"title":"pytorch学习1","uri":"/pytorch_learning/"},{"categories":["pytorch"],"content":"最大池化层使用 ","date":"2022-05-11","objectID":"/pytorch_learning/:2:0","tags":["Pytorch","深度学习"],"title":"pytorch学习1","uri":"/pytorch_learning/"},{"categories":["pytorch"],"content":"最大池化-取窗口中的最大值 MaxPool2d — 最大池化 （下采样） MaxUnPool2d — 最大池化 （上采样） ","date":"2022-05-11","objectID":"/pytorch_learning/:2:1","tags":["Pytorch","深度学习"],"title":"pytorch学习1","uri":"/pytorch_learning/"},{"categories":["pytorch"],"content":"参数使用 kernel_size：核 窗口大小 the size of the window to take a max over stride：步长 the stride of the window. Default value is kernel_size padding：边缘补零 implicit zero padding to be added on both sides dilation：核的数字之间是否紧密相连 a parameter that controls the stride of elements in the window ceil_mode：是使用ceil还是floor 模式进行计算 （ceil-》不足填充整个窗口丢弃） ","date":"2022-05-11","objectID":"/pytorch_learning/:2:2","tags":["Pytorch","深度学习"],"title":"pytorch学习1","uri":"/pytorch_learning/"},{"categories":["pytorch"],"content":"源码测试 # 最大池化层的使用 # 非线性激活的使用 # sigmoid 层 # relu 层 import torch import torchvision from torch.utils.data import DataLoader from torch import nn from torch.nn import Conv2d from torch.nn import MaxPool2d from torch.nn import ReLU from torch.nn import Sigmoid from torch.utils.tensorboard import SummaryWriter # 准备数据集 # 代码在src中， 把数据集下载到 \"../data\"， 也就是退到上一层目录， 新建一个目data dataset = torchvision.datasets.CIFAR10(\"../data\", train=False, transform=torchvision.transforms.ToTensor(), download=True) # 将数据转换为tensor数据类型 一个batch为64 dataloader = DataLoader(dataset=dataset, batch_size=64) # 定义自己的网络结构， 输入通道为3， 输出通道为6（意味着有两个卷积核）， 卷积核的大小为3， 步长为1， 不增加padding class SwaggerMaxPool(nn.Module): def __init__(self): super(SwaggerMaxPool, self).__init__() self.conv1 = Conv2d(in_channels=3, out_channels=6, kernel_size=3, stride=1, padding=0) self.maxpool1 = MaxPool2d(kernel_size=3, stride=3, padding=0) self.relu1 = ReLU() self.sigmoid1 = Sigmoid() # 前向传播， 输入为x， 输出为y def forward(self, x): # y = self.conv1(x) # y = self.maxpool1 # y = self.relu1(x) y = self.sigmoid1(x) return y swagger = SwaggerMaxPool() writer = SummaryWriter(\"../logs\") step = 0 for data in dataloader: imgs, targets = data output = swagger(imgs) # 原图写入到tensorboard当中 writer.add_images(\"input\", img_tensor=imgs, global_step=step) writer.add_images(\"output\", img_tensor=output, global_step=step) step = step + 1 writer.close() ","date":"2022-05-11","objectID":"/pytorch_learning/:2:3","tags":["Pytorch","深度学习"],"title":"pytorch学习1","uri":"/pytorch_learning/"},{"categories":["pytorch"],"content":"非线性激活 nn.ReLU 对非0数字进行截断，其中的参数inplace， 如果为TRUE，则对input 进行原地替换操作，默认为False，不进行原地操作。 nn.Sigmoid 使得模型能够使用各种非线性结构的特征，增强模型的泛化能力 ","date":"2022-05-11","objectID":"/pytorch_learning/:3:0","tags":["Pytorch","深度学习"],"title":"pytorch学习1","uri":"/pytorch_learning/"},{"categories":["pytorch"],"content":"线性层和及其他层 Normalization Layers：标准化层：映射到指定的区间，可以增加训练的速度 Recurrent Layers：文字识别网络结构 Transformer Layers：特定的网络结构（paper： attention is all you need） Dropout Layers：满足服从B-p分布的特性将输入中的数据随机置零—-\u003e防止过拟合（Efficient Object Localization Using Convolutional networks） Sparse Layers：自然语言处理（NLP）网络 Distance Functions：计算距离的函数 Loss Function：计算loss Linear Layers：线性层，全连接层 fully connected layers ","date":"2022-05-11","objectID":"/pytorch_learning/:4:0","tags":["Pytorch","深度学习"],"title":"pytorch学习1","uri":"/pytorch_learning/"},{"categories":["pytorch"],"content":"sequential和网络搭建实战 ","date":"2022-05-11","objectID":"/pytorch_learning/:5:0","tags":["Pytorch","深度学习"],"title":"pytorch学习1","uri":"/pytorch_learning/"},{"categories":["pytorch"],"content":"不使用sequential init 当中定义网络结构 forward当中按照顺序调用各层网络 ","date":"2022-05-11","objectID":"/pytorch_learning/:5:1","tags":["Pytorch","深度学习"],"title":"pytorch学习1","uri":"/pytorch_learning/"},{"categories":["pytorch"],"content":"使用sequential init 使用sequential定义model 在model中按照顺序添加网络结构 forward 中直接调用model ","date":"2022-05-11","objectID":"/pytorch_learning/:5:2","tags":["Pytorch","深度学习"],"title":"pytorch学习1","uri":"/pytorch_learning/"},{"categories":["pytorch"],"content":"测试网络是否正确小技巧 torch.ones / torch.zeros 生成input 输入到网络当中看是否出错 ","date":"2022-05-11","objectID":"/pytorch_learning/:5:3","tags":["Pytorch","深度学习"],"title":"pytorch学习1","uri":"/pytorch_learning/"},{"categories":["pytorch"],"content":"源码测试 import torch import torchvision from torch.nn import Flatten from torch.utils.data import DataLoader from torch import nn from torch.nn import Conv2d from torch.nn import MaxPool2d from torch.nn import ReLU from torch.nn import Sigmoid from torch.nn import Linear from torch.nn import Sequential from collections import OrderedDict from torch.utils.tensorboard import SummaryWriter # 准备数据集 # 代码在src中， 把数据集下载到 \"../data\"， 也就是退到上一层目录， 新建一个目data dataset = torchvision.datasets.CIFAR10(\"../data\", train=False, transform=torchvision.transforms.ToTensor(), download=True) # 将数据转换为tensor数据类型 一个batch为64 dataloader = DataLoader(dataset=dataset, batch_size=64) class SwaggerCifar(nn.Module): def __init__(self): super(SwaggerCifar, self).__init__() # self.conv1 = Conv2d(in_channels=3, out_channels=32, kernel_size=5, # stride=1, padding=2) # self.maxpool1 = MaxPool2d(kernel_size=2) # self.conv2 = Conv2d(in_channels=32, out_channels=32, kernel_size=5, # stride=1, padding=2) # self.maxpool2 = MaxPool2d(kernel_size=2) # self.conv3 = Conv2d(in_channels=32, out_channels=64, kernel_size=5, # stride=1, padding=2) # self.maxpool3 = MaxPool2d(kernel_size=2) # self.flatten = Flatten() # self.linear1 = Linear(in_features=1024, out_features=64) # self.linear2 = Linear(in_features=64, out_features=10) self.model1 = Sequential( Conv2d(in_channels=3, out_channels=32, kernel_size=5, stride=1, padding=2), MaxPool2d(kernel_size=2), Conv2d(in_channels=32, out_channels=32, kernel_size=5, stride=1, padding=2), MaxPool2d(kernel_size=2), Conv2d(in_channels=32, out_channels=64, kernel_size=5, stride=1, padding=2), MaxPool2d(kernel_size=2), Flatten(), Linear(in_features=1024, out_features=64), Linear(in_features=64, out_features=10) ) def forward(self, x): # x = self.conv1(x) # x = self.maxpool1(x) # x = self.conv2(x) # x = self.maxpool2(x) # x = self.conv3(x) # x = self.maxpool3(x) # x = self.flatten(x) # x = self.linear1(x) # x = self.linear2(x) x = self.model1(x) return x swagger = SwaggerCifar() # 使用torch的数字生成器简单检验网络的输入输出是否正确 input = torch.ones(64, 3, 32, 32) output = swagger(input) # print(output[0]) print(output.shape) print(swagger) # tensorboard 网络结构的可视化 writer = SummaryWriter(\"../logs\") writer.add_graph(swagger, input) writer.close() ","date":"2022-05-11","objectID":"/pytorch_learning/:5:4","tags":["Pytorch","深度学习"],"title":"pytorch学习1","uri":"/pytorch_learning/"},{"categories":["6D pose"],"content":"Object Localization的三种分类 object localization without classification：输出物体的区域 object detection：输出物体在图像中所处的bounding box、物体的类别 object instance segmentation：输出像素级或者点级别的目标物体区域、物体类别 ","date":"2022-05-01","objectID":"/6dpose_survey_2_object_localization/:1:0","tags":["6D Pose","Category level","Instance level","Object Localization"],"title":"6DPose—Object Localization总结","uri":"/6dpose_survey_2_object_localization/"},{"categories":["6D pose"],"content":"object localization without classification ","date":"2022-05-01","objectID":"/6dpose_survey_2_object_localization/:2:0","tags":["6D Pose","Category level","Instance level","Object Localization"],"title":"6DPose—Object Localization总结","uri":"/6dpose_survey_2_object_localization/"},{"categories":["6D pose"],"content":"Fitting 2D shape primitives 对目标物体进行轮廓提取 然后对基础形状原语进行拟合，从而得出目标物体的位置 ","date":"2022-05-01","objectID":"/6dpose_survey_2_object_localization/:2:1","tags":["6D Pose","Category level","Instance level","Object Localization"],"title":"6DPose—Object Localization总结","uri":"/6dpose_survey_2_object_localization/"},{"categories":["6D pose"],"content":"2D salient object detection 没有任何形状原语，对任意的形状的物体都可以进行拟合 深度学习方法：对原图进行特征提取之后，进行聚类或者回归 深度学习方法分类：MLP、Fully Connected Convolutional Network、Capsule Based Method 工业上物体多为固定形状的物体，所以多用形状拟合的方式进行识别，性能高，速度快 共融机器人抓取对于多用深度学习方法 ","date":"2022-05-01","objectID":"/6dpose_survey_2_object_localization/:2:2","tags":["6D Pose","Category level","Instance level","Object Localization"],"title":"6DPose—Object Localization总结","uri":"/6dpose_survey_2_object_localization/"},{"categories":["6D pose"],"content":"Fitting 3D shape primitives 对目标物体进行3D点云的轮廓提取 然后对基础形状原语进行拟合，提取得到物体的位置 ","date":"2022-05-01","objectID":"/6dpose_survey_2_object_localization/:2:3","tags":["6D Pose","Category level","Instance level","Object Localization"],"title":"6DPose—Object Localization总结","uri":"/6dpose_survey_2_object_localization/"},{"categories":["6D pose"],"content":"3D salient object detection ","date":"2022-05-01","objectID":"/6dpose_survey_2_object_localization/:2:4","tags":["6D Pose","Category level","Instance level","Object Localization"],"title":"6DPose—Object Localization总结","uri":"/6dpose_survey_2_object_localization/"},{"categories":["Java网络编程"],"content":"网络编程的必要条件 定位互联网上的一台主机 192.168.16.124:port 定位到计算机的某个资源 找到了这个主机，如果传输数据（UDP， TCP） ","date":"2022-04-09","objectID":"/java_net1/:1:0","tags":["Java","网络编程"],"title":"Java网络编程学习1","uri":"/java_net1/"},{"categories":["Java网络编程"],"content":"混淆概念 JavaWeb：网页编程 B/S TCP/IP：网络编程 C/S ","date":"2022-04-09","objectID":"/java_net1/:2:0","tags":["Java","网络编程"],"title":"Java网络编程学习1","uri":"/java_net1/"},{"categories":["Java网络编程"],"content":"网络通信的要素 ","date":"2022-04-09","objectID":"/java_net1/:3:0","tags":["Java","网络编程"],"title":"Java网络编程学习1","uri":"/java_net1/"},{"categories":["Java网络编程"],"content":"通信双方的地址 IP地址（唯一） 端口号 ","date":"2022-04-09","objectID":"/java_net1/:3:1","tags":["Java","网络编程"],"title":"Java网络编程学习1","uri":"/java_net1/"},{"categories":["Java网络编程"],"content":"规则，网络通信协议 HTTP：互联网网络通信协议（超文本传输协议） FTP：文件上传协议 SMTP: QQ邮件的发送 Telnet：远程登陆相关 DNS：域名解析 网络层的东西为封包使用 数据链路层有无线也有有线 ","date":"2022-04-09","objectID":"/java_net1/:3:2","tags":["Java","网络编程"],"title":"Java网络编程学习1","uri":"/java_net1/"},{"categories":["Java网络编程"],"content":"两个主要问题 如何主要定位到一个和几个主机 找到主机之后如何进行通信 ","date":"2022-04-09","objectID":"/java_net1/:3:3","tags":["Java","网络编程"],"title":"Java网络编程学习1","uri":"/java_net1/"},{"categories":["Java网络编程"],"content":"网络编程重的要素 IP和端口号—–IP 网络通信协议——UDP，TCP协议 ","date":"2022-04-09","objectID":"/java_net1/:3:4","tags":["Java","网络编程"],"title":"Java网络编程学习1","uri":"/java_net1/"},{"categories":["Java网络编程"],"content":"IP java.net.InetAddress 都是和网络编程相关的内容 唯一定位一台网络中的计算机 127.0.0.1 localhost 默认本机ip地址 IP地址分为广域网和局域网 IPv4：形如127.0.0.1，由四个字节组成，每个字节的范围为0-255，大概有42亿个，30亿都在北美，亚洲4亿。2011年就用尽了 IPv6：形如fe80::2852:63ff:fe79:8013%anpi0, 128 位，8个无符号整数 2001:0bb2:aaaa:0015:0000:0000:1aaa:1312 局域网：192.168.xx.xx IP地址四大分类：ABCD类 域名：IP地址是一串数字，难以记忆，所以可以通过申请域名的方式，得到www.vip.com此类的域名地址，方便记忆 ","date":"2022-04-09","objectID":"/java_net1/:4:0","tags":["Java","网络编程"],"title":"Java网络编程学习1","uri":"/java_net1/"},{"categories":["Java网络编程"],"content":"InetAddress 测试源码 package com.swagger.lesson01; import java.net.InetAddress; import java.net.UnknownHostException; // IP public class TestInetAddress { public static void main(String[] args) throws UnknownHostException { // 查询本机地址 // InetAddress 没有构造函数，不能被new出来，直接调用其中的静态方法即可 InetAddress inetAddress = InetAddress.getByName(\"127.0.0.1\"); InetAddress inetAddress_local = InetAddress.getByName(\"localhost\"); InetAddress local_name = InetAddress.getLocalHost(); System.out.println(inetAddress); System.out.println(inetAddress_local); System.out.println(local_name); // 查询域名的IP地址 InetAddress inetAddress2 = InetAddress.getByName(\"www.baidu.com\"); System.out.println(inetAddress2); // 常用方法 System.out.println(inetAddress2.getAddress()); // 地址 通常为一组 System.out.println(inetAddress2.getCanonicalHostName()); // 获取规范主机名 System.out.println(inetAddress2.getHostAddress()); // ip System.out.println(inetAddress2.getHostName()); // 获取域名，或者自己的主机名 } } ","date":"2022-04-09","objectID":"/java_net1/:4:1","tags":["Java","网络编程"],"title":"Java网络编程学习1","uri":"/java_net1/"},{"categories":["Java网络编程"],"content":"端口 port 不同的进程有不同的端口号，用来区分软件 被规定为0-65535 分为TCP和UDP端口号，总共有0-65535 * 2，单个协议下端口号不能冲突 ","date":"2022-04-09","objectID":"/java_net1/:5:0","tags":["Java","网络编程"],"title":"Java网络编程学习1","uri":"/java_net1/"},{"categories":["Java网络编程"],"content":"端口分类 公有端口 0-1023 HTTP：80 HTTPS：443 FTP：21 Telnet：23 程序注册端口 1014-49151 分配给用户或者程序的 Tomcat：8080 MySQL：3306 ORACLE：1521 动态、私有 49152 - 65535 IDEA HTML 默认端口：63342 常见的命令-MacOS 查看端口占用情况：netstat -AaLlnW 查看指定端口情况：lsof -i:80 ","date":"2022-04-09","objectID":"/java_net1/:5:1","tags":["Java","网络编程"],"title":"Java网络编程学习1","uri":"/java_net1/"},{"categories":["Java网络编程"],"content":"通信协议 统一的通信标准 TCP：传输控制协议 UDP：用户数据报协议 IP：网路互联协议，实际上 TCP/IP是一个协议簇 ","date":"2022-04-09","objectID":"/java_net1/:6:0","tags":["Java","网络编程"],"title":"Java网络编程学习1","uri":"/java_net1/"},{"categories":["Java网络编程"],"content":"TCP 实现聊天 ","date":"2022-04-09","objectID":"/java_net1/:7:0","tags":["Java","网络编程"],"title":"Java网络编程学习1","uri":"/java_net1/"},{"categories":["Java网络编程"],"content":"客户端 得到服务器的地址 创建一个Socket连接 通过IO流发送消息 package com.swagger.lesson02; import java.io.IOException; import java.io.OutputStream; import java.net.InetAddress; import java.net.Socket; import java.net.UnknownHostException; // 客户端 public class TCPClientDemo01 { public static void main(String[] args) { Socket socket = null; OutputStream os = null; try { // 1 得到服务器的地址 InetAddress serverIp = InetAddress.getByName(\"127.0.0.1\"); // 2 端口号 int port = 9999; // 3 创建一个socket 链接 socket = new Socket(serverIp, port); // 4 发送消息 IO流 os = socket.getOutputStream(); os.write(\"你好，欢迎学习javanet\".getBytes()); } catch (UnknownHostException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { if (os != null){ try { os.close(); } catch (IOException e) { e.printStackTrace(); } } if (socket != null){ try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } } } } ","date":"2022-04-09","objectID":"/java_net1/:7:1","tags":["Java","网络编程"],"title":"Java网络编程学习1","uri":"/java_net1/"},{"categories":["Java网络编程"],"content":"服务器 建立服务的端口 ServerSocket 等待用户连接过来 accept 读取客户端的消息 package com.swagger.lesson02; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.InputStream; import java.net.ServerSocket; import java.net.Socket; // 服务器段 public class TCPServerDemo01 { public static void main(String[] args) { ServerSocket serverSocket = null; Socket socket = null; InputStream is = null; ByteArrayOutputStream baos = null; try { // 1 有一个地址 serverSocket = new ServerSocket(9999); // 2 等待客户端链接过来 socket = serverSocket.accept(); // 这里即为得到的客户端socket // 3 读取客户端的消息 is = socket.getInputStream(); // 4 管道流, 将输入的is 进行管道过滤 baos = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len; while ((len = is.read(buffer)) != -1){ baos.write(buffer, 0, len); } System.out.println(baos.toString()); } catch (IOException e) { e.printStackTrace(); } finally { // 5 关闭资源 if (baos != null){ try { baos.close(); } catch (IOException e) { e.printStackTrace(); } } if (is != null){ try { is.close(); } catch (IOException e) { e.printStackTrace(); } } if (socket != null){ try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } if (serverSocket != null){ try { serverSocket.close(); } catch (IOException e) { e.printStackTrace(); } } } } } ","date":"2022-04-09","objectID":"/java_net1/:7:2","tags":["Java","网络编程"],"title":"Java网络编程学习1","uri":"/java_net1/"},{"categories":["Java多线程学习"],"content":"同步方法和同步块 同步方法：public synchronized void method(int args){} 使用synchronized方法控制对对象的访问 每个对象都有一把锁，synchronized方法必须要获得对象的锁才能够执行，否则线程阻塞 一旦得到该对象锁，同步方法才开始执行，直到方法返回才释放锁，后面阻塞的线程才能获得这个锁，继续执行 ","date":"2022-04-08","objectID":"/java_threads_learning4/:1:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"同步方法的弊端 缺陷：如果将一个大的方法声明为synchronized 将会影响效率 方法里面需要写的部分才需要加锁，读不用加锁，锁太多会浪费资源 ","date":"2022-04-08","objectID":"/java_threads_learning4/:1:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"同步块 同步块synchronized(Obj){} Obj为同步监视器，Obj可以是任何对象，推荐使用共享资源作为同步监视器 同步方法中无需指定监视器，因为监视器就是this，这个对象本身 同步监视器的执行过程 第一个线程访问，锁定同步监视器，执行其中代码 第二个线程访问，发现同步监视器被锁定，无法访问 第一个线程访问完毕，解锁同步监视器 第二个线程访问，发现同步监视器没有锁，然后锁定之后进行访问 ","date":"2022-04-08","objectID":"/java_threads_learning4/:1:2","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"具体实现（同步方法）–安全地买票 package MultiThread_learning.syncron; public class SafeBuyTicket { public static void main(String[] args) { SafeBuy safeBuy = new SafeBuy(); new Thread(safeBuy, \"swagger\").start(); new Thread(safeBuy, \"psyche\").start(); new Thread(safeBuy, \"dad\").start(); } } class SafeBuy implements Runnable{ // 票 private int ticketNums = 10; boolean flag = true; @Override public void run() { // 买票操作 while(flag){ buy(); } } private synchronized void buy(){ // 判断是否有票 if (ticketNums \u003c= 0){ flag = false; return; } // 模拟延时 try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } // 买票 System.out.println(Thread.currentThread().getName() + \"拿到票\" + ticketNums--); } } 将买票这个方法加上synchronized 修饰符之后就变成了同步方法 ","date":"2022-04-08","objectID":"/java_threads_learning4/:1:3","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"具体实现（同步代码块） —安全地取钱 package MultiThread_learning.syncron; public class SafeBank { public static void main(String[] args) { SafeAccount safeAccount = new SafeAccount(100, \"结婚基金\"); SafeWithdraw swagger = new SafeWithdraw(safeAccount, 50, \"swagger\"); SafeWithdraw psyche = new SafeWithdraw(safeAccount, 100, \"psyche\"); swagger.start(); psyche.start(); } } // 账户 class SafeAccount{ int money; String name; SafeAccount(int money, String name) { this.money = money; this.name = name; } } // 银行：模拟取钱 class SafeWithdraw extends Thread{ SafeAccount safeAccount; int withdrawNums; int nowMoney; public SafeWithdraw(SafeAccount safeAccount, int withdrawNums, String name){ super(name); this.safeAccount = safeAccount; this.withdrawNums = withdrawNums; this.nowMoney = 0; } @Override public void run() { synchronized (safeAccount){ if(safeAccount.money - withdrawNums \u003c 0){ System.out.println(Thread.currentThread().getName() + \"要取钱，\" + \"基金钱不够，取不了了\"); return; } // 延时，放大问题发生性 try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } safeAccount.money = safeAccount.money - withdrawNums; nowMoney = nowMoney + withdrawNums; System.out.println(safeAccount.name + \"账户余额为\" + this.safeAccount.money); System.out.println(Thread.currentThread().getName() + \"手里的钱为\" + this.nowMoney); } } } 代码块中地加锁参数只要为多个线程需要增删改地对象即可 这里结婚基金为多个线程修改，所以需要在run方法中加锁 ","date":"2022-04-08","objectID":"/java_threads_learning4/:1:4","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"具体实现（同步代码块） —安全的集合 package MultiThread_learning.syncron; import java.util.ArrayList; import java.util.List; public class SafeList { public static void main(String[] args) { List\u003cString\u003e list = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c 10000; i++) { new Thread(()-\u003e{ synchronized (list){ list.add(Thread.currentThread().getName()); } }).start(); } System.out.println(list.size()); } } list被多个线程同时修改 对list进行加锁，就不会出问题 ","date":"2022-04-08","objectID":"/java_threads_learning4/:1:5","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"JUC（Java Util Concurrent） Java 并发包 此包里的类都是线程安全的，不用再使用synchronized package MultiThread_learning.syncron; import java.util.concurrent.CopyOnWriteArrayList; public class TestJUC { public static void main(String[] args) throws InterruptedException { CopyOnWriteArrayList\u003cString\u003e list = new CopyOnWriteArrayList\u003c\u003e(); for (int i = 0; i \u003c 10000; i++) { new Thread(()-\u003e{ list.add(Thread.currentThread().getName()); }).start(); } Thread.sleep(3000); System.out.println(list.size()); } } ","date":"2022-04-08","objectID":"/java_threads_learning4/:2:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"死锁 两个活着多个线程都在等待对方释放资源 具体来说：一个同步块同时拥有两个以上的对象锁，就有可能发生死锁 ","date":"2022-04-08","objectID":"/java_threads_learning4/:3:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"产生死锁的四个条件 互斥：一个资源每次只能被一个线程使用 请求与保持：一个进程因请求资源而阻塞时，对已获得的资源保持不放 不剥夺：线程已获得的资源，在未使用完之前，不能强行剥夺 循环等待条件：若干进行之间形成一种头尾相接的循环等待资源关系 ","date":"2022-04-08","objectID":"/java_threads_learning4/:3:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"具体实现，产生死锁 package MultiThread_learning.syncron; // 多个线程互相抱着对方的资源，形成僵持 public class DeadLock { public static void main(String[] args) { MakeUp makeUp1 = new MakeUp(0, \"swagger\"); MakeUp makeUp2 = new MakeUp(1, \"psyche\"); makeUp1.start(); makeUp2.start(); } } class Lipstick{ } class Mirror{ } class MakeUp extends Thread{ // 需要只有一份的资源 static Lipstick lipstick = new Lipstick(); static Mirror mirror = new Mirror(); int choice; String girlName; MakeUp(int choice, String girlName){ this.choice = choice; this.girlName = girlName; } @Override public void run() { super.run(); try { makeup(); } catch (InterruptedException e) { e.printStackTrace(); } } private void makeup () throws InterruptedException { if (choice == 0){ synchronized (lipstick){ System.out.println(this.girlName + \"get lipstick's lock\"); Thread.sleep(1000); synchronized (mirror){ System.out.println(this.girlName + \"get mirror's lock\"); } } }else { synchronized (mirror){ System.out.println(this.girlName + \"get mirror's lock\"); Thread.sleep(2000); synchronized (lipstick){ System.out.println(this.girlName + \"get lipstick's lock\"); } } } } } 产生死锁，程序停不下来 互相想要得到对方资源的锁 但是不放开自己手中资源的锁 ","date":"2022-04-08","objectID":"/java_threads_learning4/:3:2","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"具体实现，解开死锁 package MultiThread_learning.syncron; // 多个线程互相抱着对方的资源，形成僵持 public class DeadLock { public static void main(String[] args) { MakeUp makeUp1 = new MakeUp(0, \"swagger\"); MakeUp makeUp2 = new MakeUp(1, \"psyche\"); makeUp1.start(); makeUp2.start(); } } class Lipstick{ } class Mirror{ } class MakeUp extends Thread{ // 需要只有一份的资源 static Lipstick lipstick = new Lipstick(); static Mirror mirror = new Mirror(); int choice; String girlName; MakeUp(int choice, String girlName){ this.choice = choice; this.girlName = girlName; } @Override public void run() { super.run(); try { makeup(); } catch (InterruptedException e) { e.printStackTrace(); } } private void makeup () throws InterruptedException { if (choice == 0){ synchronized (lipstick){ System.out.println(this.girlName + \"get lipstick's lock\"); Thread.sleep(1000); } synchronized (mirror){ System.out.println(this.girlName + \"get mirror's lock\"); } }else { synchronized (mirror){ System.out.println(this.girlName + \"get mirror's lock\"); Thread.sleep(2000); } synchronized (lipstick){ System.out.println(this.girlName + \"get lipstick's lock\"); } } } } 解开死锁 获取对方资源的锁之前，放开手中持有资源的锁 ","date":"2022-04-08","objectID":"/java_threads_learning4/:3:3","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"Lock（锁） 显式定义同步锁 JUC包下的内容 java.util.concurrent.locks Lock对象开始访问共享资源之前应先活着Lock对象 ReentrantLock类实现了Lock，他拥有和synchronized相同的并发性和内存语义 在实现线程安全控制中，比较常用的是ReentrantLock，可以显式地加锁和释放锁 如果有异常，需要将解锁放入到finally之中 ","date":"2022-04-08","objectID":"/java_threads_learning4/:4:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"lock和synchronized 的区别 lock 是显示锁（手动开启和关闭）；synchronized是隐式锁，出了作用域自动关闭 Lock 只能锁代码块，synchronized既可以锁方法，也可以锁代码块 使用Lock，JVM将花费较少的时间来调度线程，性能更好，并且扩展性更好 优先使用顺序：Lock \u003e 同步代码块（已经进入了方法体，非配了相应资源）\u003e 同步方法（在方法体之外） ","date":"2022-04-08","objectID":"/java_threads_learning4/:4:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"具体实现 package MultiThread_learning.SeniorMethod; import java.util.concurrent.locks.ReentrantLock; // 测试Lock锁 public class TestLock { public static void main(String[] args) { TestLock2 testLock2 = new TestLock2(); new Thread(testLock2).start(); new Thread(testLock2).start(); new Thread(testLock2).start(); } } class TestLock2 implements Runnable{ int ticketNums = 10; // 定义Lock锁 private final ReentrantLock lock = new ReentrantLock(); @Override public void run() { while (true){ try { // 加锁 lock.lock(); if(ticketNums \u003e 0){ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(ticketNums--); }else { break; } }finally { // 解锁 // 如果有异常，需要将解锁放入到finally之中 lock.unlock(); } } } } ","date":"2022-04-08","objectID":"/java_threads_learning4/:4:2","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"线程通信 ","date":"2022-04-08","objectID":"/java_threads_learning4/:5:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"生产者消费者问题 仓库只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将仓库中的产品取走消费 对于生产者，如果仓库中没有产品，则生产者将产品放入仓库，如果仓库中已经有产品，生产者停止生产，直到产品被消费者取走为止 对于消费者，仓库中如果放有产品，消费者可以将产品取走，否则停止消费并等待，直到仓库中有产品为止 生产者消费者问题之中synchronized是不够的，只能加锁，但是无法实现通信 ","date":"2022-04-08","objectID":"/java_threads_learning4/:5:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"Java 线程通信问题的方法 注意：局势Object类的方法，都只能在同步方法和同步代码块中使用，否则会抛出IllegalMonitorStateException异常 ","date":"2022-04-08","objectID":"/java_threads_learning4/:5:2","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"通信解决方式1-管程法 设置一个缓冲区 ","date":"2022-04-08","objectID":"/java_threads_learning4/:6:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"具体实现 package MultiThread_learning.SeniorMethod; /** * @author swaggerwei * @version 1.0 * @since 1.8 */ // 测试：生产者消费者问题 利用缓冲区（管程法） public class TestPandC { public static void main(String[] args) { SynContainer container = new SynContainer(); new Producer(container).start(); new Consumer(container).start(); } } // 生产者 class Producer extends Thread{ SynContainer container; public Producer(SynContainer container){ this.container = container; } @Override public void run() { super.run(); for (int i = 0; i \u003c 100; i++) { try { container.push(new Chicken(i)); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"生产了\" + i + \"只鸡\"); } } } // 消费者 class Consumer extends Thread{ SynContainer container; public Consumer(SynContainer container){ this.container = container; } @Override public void run() { super.run(); for (int i = 0; i \u003c 100; i++) { try { System.out.println(\"消费了\" + container.pop().id + \"只鸡\"); } catch (InterruptedException e) { e.printStackTrace(); } } } } // 产品 class Chicken{ int id;// 产品编号 public Chicken(int id) { this.id = id; } } // 缓冲区 class SynContainer{ // 容器大小 Chicken[] chickens = new Chicken[10]; // 容器计数器 int count = 0; // 生产者上货 public synchronized void push(Chicken chicken) throws InterruptedException { // 如果容器满了，就要等待消费者消费 if(count == chickens.length){ // 通知消费者消费，生产等待 this.wait(); } // 如果没有满，就要上货 chickens[count] = chicken; count++; // 可以通知消费这消费了 this.notifyAll(); } // 消费者消费产品 public synchronized Chicken pop() throws InterruptedException { // 判断是否可以消费 if(count == 0){ this.wait(); // 等待生产者生产，消费者等待 } // 如果可以消费 count--; Chicken chicken = chickens[count]; // 通知生产者开始上货 this.notifyAll(); return chicken; } } ","date":"2022-04-08","objectID":"/java_threads_learning4/:6:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"通信解决方式2-信号灯法 设置一个标志位 ","date":"2022-04-08","objectID":"/java_threads_learning4/:7:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"具体实现 package MultiThread_learning.SeniorMethod; /** * @author swaggerwei * @since 1.8 */ // 生产者消费者问题 // 信号灯法解决 public class TestPandC2 { public static void main(String[] args) { TV tv = new TV(); new Player(tv).start(); new Audience(tv).start(); } } // 生产者---演员 class Player extends Thread{ TV tv; public Player(TV tv){ this.tv = tv; } @Override public void run() { for (int i = 0; i \u003c 20; i++) { if (i%2 == 0){ try { this.tv.play(\"甄嬛传\"); } catch (InterruptedException e) { e.printStackTrace(); } }else { try { this.tv.play(\"天下足球\"); } catch (InterruptedException e) { e.printStackTrace(); } } } } } // 消费者---观众 class Audience extends Thread{ TV tv; public Audience(TV tv){ this.tv = tv; } @Override public void run() { for (int i = 0; i \u003c 20; i++) { try { tv.watch(); } catch (InterruptedException e) { e.printStackTrace(); } } } } // 产品---节目 class TV{ // 演员表演，观众等待 // 观众观看，演员等待 String voice;//表演节目 boolean flag = true; // 表演 public synchronized void play(String voice) throws InterruptedException { if (!flag){ this.wait(); } System.out.println(\"演员表演了节目：\" + voice); // 通知观众观看 this.voice = voice; this.notifyAll(); this.flag = !this.flag; } // 观看 public synchronized void watch() throws InterruptedException { if(flag){ this.wait(); } System.out.println(\"观众观看了\" + voice); // 通知演员表演 notifyAll(); this.flag = !this.flag; } } ","date":"2022-04-08","objectID":"/java_threads_learning4/:7:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"线程池 经常创建和销毁线程非常浪费资源，对性能影响很大 提前创建好多个线程池，使用时直接获取，使用完放回池中 优点：提高了相应速度 优点：降低了资源消耗，重复利用线程池中线程，不需要重复创建 便于线程管理：corePoolSize核心池大小, maximumPoolSize最大线程数，keepAliveTime线程没有任务时最多保持多长时间后终止 ","date":"2022-04-08","objectID":"/java_threads_learning4/:8:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"具体使用 JDK5 开始提供线程池相关的API：ExecutorService 和 Executors ExecutorService为真正的线程池接口，常见的子类ThreadPoolExecutor Executors为工具类，线程池的工厂类，用于创建并返回不同类型的线程池 ","date":"2022-04-08","objectID":"/java_threads_learning4/:8:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"具体实现 package MultiThread_learning.SeniorMethod; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.ForkJoinPool; /** * @author swaggerwei * @since 1.8 * @version 1.0 */ // 测试线程池 public class TestPool { public static void main(String[] args) { // 1 创建线程池, 参数为线程池的大小（线程的数目） ExecutorService service = Executors.newFixedThreadPool(10); service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); // 关闭链接 service.shutdown(); } } class MyThread implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()); } } ","date":"2022-04-08","objectID":"/java_threads_learning4/:8:2","tags":["Java","Thread","多线程"],"title":"Java多线程学习4","uri":"/java_threads_learning4/"},{"categories":["Java多线程学习"],"content":"线程强制执行 Join合并线程，此线程执行完成后再执行其他线程，其他线程阻塞 可以想像成插队 线程中尽量少使用次方法，会让其他线程陷入阻塞 ","date":"2022-04-06","objectID":"/java_threads_learning3/:1:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习3","uri":"/java_threads_learning3/"},{"categories":["Java多线程学习"],"content":"具体实现 package MultiThread_learning; // 测试join方法,想象为插队 public class TestJoin implements Runnable{ @Override public void run() { for (int i = 0; i \u003c 500; i++) { System.out.println(\"线程VIP来了\" + i); } } public static void main(String[] args) { // 启动线程 TestJoin testJoin = new TestJoin(); Thread thread = new Thread(testJoin); thread.start(); // 主线程 for (int i = 0; i \u003c 500; i++) { if (i == 200){ try { thread.join(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"main\" + i); } } } ","date":"2022-04-06","objectID":"/java_threads_learning3/:1:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习3","uri":"/java_threads_learning3/"},{"categories":["Java多线程学习"],"content":"线程状态观测（Thread.State） NEW：尚未启动的线程 RUNNABLE：在执行中的线程 BLOCKED：被阻塞等待监视器锁定的线程处于次状态 WAITING：正在等待另一个线程执行特定动作的线程处于次状态 TIMED_WAITING：正在等待另一个线程执行动作达到到指定等待时间的线程处于次状态 TERMINATED：已退出的线程 ","date":"2022-04-06","objectID":"/java_threads_learning3/:2:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习3","uri":"/java_threads_learning3/"},{"categories":["Java多线程学习"],"content":"观测线程状态具体实现 package MultiThread_learning; // 观察线程状态 public class TestState { public static void main(String[] args) throws InterruptedException { Thread thread = new Thread(()-\u003e{ for (int i = 0; i \u003c 5; i++) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"////////\"); }); // 观察线程状态 NEW Thread.State state = thread.getState(); System.out.println(state.toString()); // 观察线程启动后状态 RUNNABLE thread.start(); state = thread.getState(); System.out.println(state.toString()); while (state != Thread.State.TERMINATED){// 只要线程不终止，就一直出状态 Thread.sleep(100); state = thread.getState();//更新线程状态 System.out.println(state.toString()); } } } 线程在死亡之后无法在启动 ","date":"2022-04-06","objectID":"/java_threads_learning3/:2:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习3","uri":"/java_threads_learning3/"},{"categories":["Java多线程学习"],"content":"线程优先级 Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行 线程的优先级用数字表示，范围从1～10 Thread.MIN_PRIORITY = 1 Thread.MAX_PRIORITY = 10 Thread.NORM_PRIORITY = 5 获取优先级：getPriority() 修改优先级：setPriority() 需要先设置优先级，再启动 ","date":"2022-04-06","objectID":"/java_threads_learning3/:3:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习3","uri":"/java_threads_learning3/"},{"categories":["Java多线程学习"],"content":"具体实现 package MultiThread_learning; // 测试线程优先级 public class TestPriority { public static void main(String[] args) { // 主线程优先级 System.out.println(Thread.currentThread().getName() + \"---\u003e\" + Thread.currentThread().getPriority()); MyPriority myPriority = new MyPriority(); Thread thread1 = new Thread(myPriority); Thread thread2 = new Thread(myPriority); Thread thread3 = new Thread(myPriority); Thread thread4 = new Thread(myPriority); Thread thread5 = new Thread(myPriority); Thread thread6 = new Thread(myPriority); // 设置优先级 thread1.start(); thread2.setPriority(1); thread2.start(); thread3.setPriority(4); thread3.start(); thread4.setPriority(Thread.MAX_PRIORITY); thread4.start(); thread5.setPriority(2); thread5.start(); thread6.setPriority(8); thread6.start(); } } class MyPriority implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName() + \"---\u003e\" + Thread.currentThread().getPriority()); } } 实际上优先级高的不一定先跑 最终的执行还是看CPU调度器的心情 可能CPU会执行优先级低的线程（性能倒置） ","date":"2022-04-06","objectID":"/java_threads_learning3/:3:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习3","uri":"/java_threads_learning3/"},{"categories":["Java多线程学习"],"content":"守护（daemon）线程 线程分为用户线程和守护线程 虚拟机必须确保用户线程执行完毕 虚拟机不用等待守护线程执行完毕 如：后台记录操作日志，监控内存，垃圾回收等待 守护线程参数默认为false 表示为用户线程，正常线程都为用户线程 thread.setDaemon(true); // 默认为false 表示为用户线程，正常线程都为用户线程 ","date":"2022-04-06","objectID":"/java_threads_learning3/:4:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习3","uri":"/java_threads_learning3/"},{"categories":["Java多线程学习"],"content":"线程同步机制（并发） 多个线程操作同一个资源 并发，多个线程在同一时刻操作同一个对象 实际上线程同步就是一种等待机制，多个同时需要访问一个对象的线程需要进入对象等待池形成队列，等待前面的线程使用完毕，下一个再使用 一个线程在使用数据对象时需要对对象进行加锁，防止其他线程进入篡改 每个对象都有一把锁，sleep不会释放锁，所以其他的线程依旧无法使用此对象 ","date":"2022-04-06","objectID":"/java_threads_learning3/:5:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习3","uri":"/java_threads_learning3/"},{"categories":["Java多线程学习"],"content":"锁机制 访问时加入锁机制synchronized 当一个线程获得了对象的排他锁，独占资源，其他线程必须等待，使用后释放锁即可 ","date":"2022-04-06","objectID":"/java_threads_learning3/:5:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习3","uri":"/java_threads_learning3/"},{"categories":["Java多线程学习"],"content":"锁机制带来的问题 一个线程持有锁会导致其他所有需要此锁的线程挂起 多线程竞争时，加锁个释放锁会导致比较多的上下文切换和调度延时，引起性能问题 如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题 ","date":"2022-04-06","objectID":"/java_threads_learning3/:5:2","tags":["Java","Thread","多线程"],"title":"Java多线程学习3","uri":"/java_threads_learning3/"},{"categories":["Java多线程学习"],"content":"不安全案例1 package MultiThread_learning.syncron; // 线程不安全，出现负数 // 不安全的买票 public class UnSafeBuyTicket { public static void main(String[] args) { BuyTicket buyTicket = new BuyTicket(); new Thread(buyTicket, \"swagger\").start(); new Thread(buyTicket, \"psyche\").start(); new Thread(buyTicket, \"dad\").start(); } } class BuyTicket implements Runnable{ // 票 private int ticketNums = 10; boolean flag = true; @Override public void run() { // 买票操作 while(flag){ buy(); } } private void buy(){ // 判断是否有票 if (ticketNums \u003c 0){ flag = false; return; } // 模拟延时 try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } // 买票 System.out.println(Thread.currentThread().getName() + \"拿到票\" + ticketNums--); } } 每个线程都有自己的CPU内工作内存，不加锁会造成票数为负数的情况 ","date":"2022-04-06","objectID":"/java_threads_learning3/:5:3","tags":["Java","Thread","多线程"],"title":"Java多线程学习3","uri":"/java_threads_learning3/"},{"categories":["Java多线程学习"],"content":"不安全案例2 package MultiThread_learning.syncron; // 不安全的取钱 // 两个人去银行取钱，账户出问题 public class UnsafeBank { public static void main(String[] args) { Account account = new Account(100, \"基金\"); Withdrawing swagger = new Withdrawing(account, 50, \"swagger\"); Withdrawing psyche = new Withdrawing(account, 100, \"psyche\"); swagger.start(); psyche.start(); } } // 账户 class Account{ int money; String name; Account(int money, String name) { this.money = money; this.name = name; } } // 银行：模拟取款 class Withdrawing extends Thread{ Account account; int withdrawNums; int nowMoney; public Withdrawing(Account account, int WithdrawNums, String name){ super(name); this.account = account; this.withdrawNums = WithdrawNums; this.nowMoney = 0; } @Override public void run() { if (account.money - withdrawNums \u003c 0){ System.out.println(Thread.currentThread().getName() + \"要取钱，\" + \"基金钱不够，取不了了\"); return; } // 延时，放大问题发生性 try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } account.money = account.money - withdrawNums; nowMoney = nowMoney + withdrawNums; System.out.println(account.name + \"账户余额为\" + this.account.money); System.out.println(Thread.currentThread().getName() + \"手里的钱为\" + this.nowMoney); } } ","date":"2022-04-06","objectID":"/java_threads_learning3/:5:4","tags":["Java","Thread","多线程"],"title":"Java多线程学习3","uri":"/java_threads_learning3/"},{"categories":["Java多线程学习"],"content":"线程不安全集合 package MultiThread_learning.syncron; import java.util.ArrayList; import java.util.List; // 线程不安全的集合 public class UnsafeList { public static void main(String[] args) { List\u003cString\u003e strings = new ArrayList\u003cString\u003e(); // 创建10000个线程, 加入到数组当中 for (int i = 0; i \u003c 10000; i++) { new Thread(()-\u003e{ strings.add(Thread.currentThread().getName()); }).start(); } // 最后的数组size和线程数量不一致 System.out.println(strings.size()); } } 数组为线程不安全的 说明有线程在同一瞬间操作了同一个地址，导致最后数组size和线程数量不一致 ","date":"2022-04-06","objectID":"/java_threads_learning3/:5:5","tags":["Java","Thread","多线程"],"title":"Java多线程学习3","uri":"/java_threads_learning3/"},{"categories":["Java多线程学习"],"content":"静态代理模式 真实对象和代理对象都要实现同一个接口 代理对象要代理真实角色 优点，代理对象无法做很多真实对象无法做的事，真实对象可以专注于自己的事情 实际上Thread实现了Runnable接口，对线程实现代理 ","date":"2022-04-05","objectID":"/java_threads_learning2/:1:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习2","uri":"/java_threads_learning2/"},{"categories":["Java多线程学习"],"content":"婚庆公司代理结婚 package MultiThread_learning; public class TestStaticProxy { public static void main(String[] args) { you swagger = new you(); WeddingCompany weddingCompany = new WeddingCompany(swagger); weddingCompany.HappyMarry(); } } interface Marry{ void HappyMarry(); } // 真实角色，实现接口（新郎本人） class you implements Marry{ @Override public void HappyMarry() { System.out.println(\"swagger is going to marry\"); } } // 代理角色，代理实现接口（婚庆公司） class WeddingCompany implements Marry{ private Marry target; WeddingCompany(Marry target) { this.target = target; } @Override public void HappyMarry() { before(); this.target.HappyMarry(); after(); } private void after() { System.out.println(\"pay money\"); } private void before() { System.out.println(\"prepare the wedding procedure\"); } } 婚庆公司代理新郎结婚 新郎可以专注于自己的事情 new Thread(()-\u003e System.out.println(\"I love you\")).start(); new WeddingCompany(new you()).HappyMarry(); 如上述代码，Thread代理输出I love you进行执行start()方法 ","date":"2022-04-05","objectID":"/java_threads_learning2/:1:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习2","uri":"/java_threads_learning2/"},{"categories":["Java多线程学习"],"content":"Lambda表达式 JDK8才出现 lambda 表达式只有实现接口部分代码的核心只有一句话是才能简化成一行，如果有多行，则需要花括号进行代码快包裹 前提是为函数式接口 多个参数也可以去掉参数类型，只能同时都去掉，活着同时都不去掉，必须加上括号 new Thread(()-\u003e System.out.println(\"I love you\")).start(); ","date":"2022-04-05","objectID":"/java_threads_learning2/:2:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习2","uri":"/java_threads_learning2/"},{"categories":["Java多线程学习"],"content":"使用lambda表达式的原因 避免匿名内部类的定义过多 使代码更简介 去掉没有意义的代码，只留下核心逻辑 ","date":"2022-04-05","objectID":"/java_threads_learning2/:2:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习2","uri":"/java_threads_learning2/"},{"categories":["Java多线程学习"],"content":"函数接口定义 任何接口，如果只包含唯一一个抽象方法，那么他就是一个函数式接口 函数式接口，可以通过lambda表达式创建该接口， ","date":"2022-04-05","objectID":"/java_threads_learning2/:2:2","tags":["Java","Thread","多线程"],"title":"Java多线程学习2","uri":"/java_threads_learning2/"},{"categories":["Java多线程学习"],"content":"具体实现1 package MultiThread_learning; // 推导lambda表达式 public class TestLambda { //3 静态内部类 static class Like2 implements ILike{ @Override public void lambda() { System.out.println(\"i like lambda2\"); } } public static void main(String[] args) { // 声明一个接口，使用实现类Like来new ILike like = new Like(); like.lambda(); // 静态内部类 like = new Like2(); like.lambda(); // 4 局部内部类 class Like3 implements ILike{ @Override public void lambda() { System.out.println(\"i like lambda3\"); } } like = new Like3(); like.lambda(); // 5 匿名内部类 like = new ILike() { @Override public void lambda() { System.out.println(\"i like lambda4\"); } }; like.lambda(); // 6 用lambda表达式简化 like = ()-\u003e{ System.out.println(\"i like lambda5\"); }; like.lambda(); } } // 1 定一个函数式接口 interface ILike{ void lambda(); } // 2 定义一个实现类 class Like implements ILike{ @Override public void lambda() { System.out.println(\"i like lambda\"); } } ","date":"2022-04-05","objectID":"/java_threads_learning2/:2:3","tags":["Java","Thread","多线程"],"title":"Java多线程学习2","uri":"/java_threads_learning2/"},{"categories":["Java多线程学习"],"content":"具体实现2 package MultiThread_learning; public class TestLambda2 { public static void main(String[] args) { // 原版lambda 表达式 Ilove love = (int a)-\u003e { System.out.println(\"i love you\" + \" \" + a + 1); }; // 简化1：省略参数类型 love = (a)-\u003e{ System.out.println(\"i love you\" + \" \" + a + 2); }; // 简化2：简化花括号 love = a -\u003e { System.out.println(\"i love you\" + \" \" + a + 3); }; // 简化3：去掉花括号 love = a -\u003e System.out.println(\"i love you\" + \" \" + a + 4); love.love(1); } } interface Ilove { void love(int a); } ","date":"2022-04-05","objectID":"/java_threads_learning2/:2:4","tags":["Java","Thread","多线程"],"title":"Java多线程学习2","uri":"/java_threads_learning2/"},{"categories":["Java多线程学习"],"content":"线程的五大状态 具体内容如下 ","date":"2022-04-05","objectID":"/java_threads_learning2/:3:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习2","uri":"/java_threads_learning2/"},{"categories":["Java多线程学习"],"content":"线程方法 ","date":"2022-04-05","objectID":"/java_threads_learning2/:4:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习2","uri":"/java_threads_learning2/"},{"categories":["Java多线程学习"],"content":"停止线程 不推荐使用JDK提供的stop()，destroy()方法，已经废弃了 推荐线程自己停下来，利用次数，不建议死循环 建议使用一个标志位进行终止变量，比如当flag=false时，终止线程运行 ","date":"2022-04-05","objectID":"/java_threads_learning2/:5:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习2","uri":"/java_threads_learning2/"},{"categories":["Java多线程学习"],"content":"具体实现 package MultiThread_learning; public class TestStop implements Runnable{ // 1 设置一个标志位 private boolean flag = true; @Override public void run() { int i = 0; while (flag){ System.out.println(\"run.....Thread\" + i++); } } // 2 设置一个公开的方法停止线程，转换标志位，方法为自己定义 public void mystop(){ this.flag = false; } public static void main(String[] args) { TestStop testStop = new TestStop(); new Thread(testStop).start(); for (int i = 0; i \u003c 1000; i++) { System.out.println(\"main\" + i); if (i == 900){ testStop.mystop(); System.out.println(\"线程停止了\"); } } } } ","date":"2022-04-05","objectID":"/java_threads_learning2/:5:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习2","uri":"/java_threads_learning2/"},{"categories":["Java多线程学习"],"content":"线程休眠 sleep(时间毫秒) sleep存在异常InterruptedException sleep时间到达后线程进入就绪状态，等待CPU调度 sleep可以模拟网络延迟，倒计时等 每一个对象都有一个锁，sleep不会释放锁 ","date":"2022-04-05","objectID":"/java_threads_learning2/:6:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习2","uri":"/java_threads_learning2/"},{"categories":["Java多线程学习"],"content":"具体实现1 模拟网络延迟：放大线程的发生性 package MultiThread_learning; public class TestSleep implements Runnable{ private int ticketNums = 10; @Override public void run() { while (true){ if(ticketNums \u003c=0){ break; } // 模拟延时 try { Thread.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } // 买票 System.out.println(Thread.currentThread().getName() + \"拿到了第\" + ticketNums-- + \"票\"); } } public static void main(String[] args) { TestSleep testSleep = new TestSleep(); new Thread(testSleep, \"小明\").start(); new Thread(testSleep, \"老师\").start(); new Thread(testSleep, \"黄牛党\").start(); } } ","date":"2022-04-05","objectID":"/java_threads_learning2/:6:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习2","uri":"/java_threads_learning2/"},{"categories":["Java多线程学习"],"content":"具体实现2 模拟倒计时 package MultiThread_learning; // 模拟倒计时 public class TestSleep2 { public static void main(String[] args) { // 主线程 main的倒计时 try { tenDown(); } catch (InterruptedException e) { e.printStackTrace(); } } // 模拟倒计时 public static void tenDown() throws InterruptedException { int num = 10; while (true){ Thread.sleep(1000); System.out.println(num--); if (num \u003c= 0){ break; } } } } ","date":"2022-04-05","objectID":"/java_threads_learning2/:6:2","tags":["Java","Thread","多线程"],"title":"Java多线程学习2","uri":"/java_threads_learning2/"},{"categories":["Java多线程学习"],"content":"具体实现3 隔一段时长打印系统时间 package MultiThread_learning; import java.text.SimpleDateFormat; import java.util.Date; public class TestSleep3 { public static void main(String[] args) { // 打印当前系统时间 Date startTime = new Date(System.currentTimeMillis()); while (true){ try { Thread.sleep(1000); System.out.println(new SimpleDateFormat(\"HH:mm:ss\").format(startTime)); // 更新系统时间 startTime = new Date(System.currentTimeMillis()); } catch (InterruptedException e) { e.printStackTrace(); } } } // 模拟倒计时 public static void tenDown() throws InterruptedException { int num = 10; while (true){ Thread.sleep(1000); System.out.println(num--); if (num \u003c= 0){ break; } } } } ","date":"2022-04-05","objectID":"/java_threads_learning2/:6:3","tags":["Java","Thread","多线程"],"title":"Java多线程学习2","uri":"/java_threads_learning2/"},{"categories":["Java多线程学习"],"content":"线程礼让 让当前只在执行的线程礼让，但不阻塞 让线程从运行状态转为就绪状态 让CPU重新调度，礼让不一定成功，看CPU心情 ","date":"2022-04-05","objectID":"/java_threads_learning2/:7:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习2","uri":"/java_threads_learning2/"},{"categories":["Java多线程学习"],"content":"具体实现 如果礼让成功，则a线程开始执行后b线程应该也开始执行 如果礼让不成功，则a线程执行完之后b线程再执行 package MultiThread_learning; // 测试礼让 public class TestYield { public static void main(String[] args) { MyYield myYield = new MyYield(); new Thread(myYield, \"a Thread\").start(); new Thread(myYield, \"b Thread\").start(); } } class MyYield implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName() + \"线程开始执行\"); Thread.yield(); System.out.println(Thread.currentThread().getName() + \"线程停止执行\"); } } 说明礼让成功 ","date":"2022-04-05","objectID":"/java_threads_learning2/:7:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习2","uri":"/java_threads_learning2/"},{"categories":["Java多线程学习"],"content":"Java 多线程基础知识 程序project：指令和数据的有序集合，静态概念 进程Process：程序的运行过程，是系统资源分配的单位，动态概念 线程Thread：一个进程中可以有多个线程，至少有一个线程，线程是CPU调度和执行的单位。 很多多线程是模拟出来的，真正的多线程是因为有多个cpu核，如果只有单核，实际上cpu一次只能执行一个线程，知识切换很快 程序运行时，即使没有自己创建线程，后台也会有多个线程（主线程和GC线程） 如果一个程序中有多个线程，线程运行的先后人为无法干预，都是由调度器安排调度（调度器与操作系统紧密相关） 对同一份资源操作时，会存在资源抢夺问题，需要加入并发控制 线程会带来额外开销，如CPU调度时间，并发控制开销等 每个线程在自己的工作内存交互，内存控制不当会造成数据不一致（结合JMM理解） ","date":"2022-04-04","objectID":"/java_threads_learning1/:1:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习1","uri":"/java_threads_learning1/"},{"categories":["Java多线程学习"],"content":"线程的创建 Thread class：继承Thread类，重写其中的run方法 Runnable接口：实现Runnable接口 Callable接口：实现Callable接口 推荐使用Runnable接口，避免单继承的局限性，还可以多个对象被一个线程使用，节省资源 ","date":"2022-04-04","objectID":"/java_threads_learning1/:2:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习1","uri":"/java_threads_learning1/"},{"categories":["Java多线程学习"],"content":"Thread创建多线程 package MultiThread_learning; // 创建线程方法1：继承Thread类，重写run()方法，调用start开启线程 public class TestThread1 extends Thread{ @Override public void run() { // run方法线程体 for (int i = 0; i \u003c 20; i++) { System.out.println(\"我在看代码\"+i); } } public static void main(String[] args) { // 创建一个线程对象，调用start，开启线程 TestThread1 testThread1 = new TestThread1(); testThread1.start(); // main线程，主线程 for (int i = 0; i \u003c 20; i++) { System.out.println(\"我在学习多线程\"+i); } } } 自定义线程类继承Thread类 重写run方法 创建一个线程对象，调用start，开启线程 如果在创建线程对象后调用start，则为多线程模式 如果在创建线程对象后调用run，则为单线程模式 线程不一定立即执行，CPU安排调度，所以每一次多线程运行的结果都可能不一样 实例-下载图片 package MultiThread_learning; import org.apache.commons.io.FileUtils; import java.io.File; import java.io.IOException; import java.net.URL; // 练习Threa，实现多线程同步下载图片 public class TestThread2 extends Thread{ private String url; // 网络图片地址 private String name; // 保存的文件名 public TestThread2(String url, String name){ this.url = url; this.name = name; } @Override public void run() { super.run(); WebDownloader webDownloader = new WebDownloader(); webDownloader.downloader(url, name); System.out.println(\"下载了文件名为：\"+name); } public static void main(String[] args) { TestThread2 t1 = new TestThread2(\"https://img-blog.csdnimg.cn/88eba0a511a84000b1e458e9aca123c7.png\", \"1.png\"); TestThread2 t2 = new TestThread2(\"https://img-blog.csdnimg.cn/88eba0a511a84000b1e458e9aca123c7.png\", \"2.png\"); TestThread2 t3 = new TestThread2(\"https://img-blog.csdnimg.cn/88eba0a511a84000b1e458e9aca123c7.png\", \"3.png\"); t1.start(); t2.start(); t3.start(); } } // 下载器 class WebDownloader{ public void downloader(String url, String name){ try{ FileUtils.copyURLToFile(new URL(url), new File(name)); }catch(IOException e){ e.printStackTrace(); System.out.println(\"IO异常，downloader出现问题\"); } } } 多线程下载一张图片，观察执行的先后顺序是否为单线程的顺序执行 可以观察到，执行顺序和单线程顺序执行不一致，实际为多线程同时执行 ","date":"2022-04-04","objectID":"/java_threads_learning1/:2:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习1","uri":"/java_threads_learning1/"},{"categories":["Java多线程学习"],"content":"实现Runnable接口 package MultiThread_learning; import javax.crypto.spec.PSource; public class TestThread3 implements Runnable{ @Override public void run() { for (int i = 0; i \u003c 20; i++) { System.out.println(\"我在看代码--\"+i); } } public static void main(String[] args) { // 创建runnable接口的实现类对象 TestThread3 testThread3 = new TestThread3(); // 创建线程对象，通过线程对象来开启线程，代理 Thread thread = new Thread(testThread3); thread.start(); for (int i = 0; i \u003c 20; i++) { System.out.println(\"我在学习多线程--\"+i); } } } 定义MyRunnable类实现Runnable接口 实现run()方法，编写线程执行体 创建线程对象，调用start()方法启动线程 ","date":"2022-04-04","objectID":"/java_threads_learning1/:2:2","tags":["Java","Thread","多线程"],"title":"Java多线程学习1","uri":"/java_threads_learning1/"},{"categories":["Java多线程学习"],"content":"并发问题–同一个对象被多个线程使用 package MultiThread_learning; public class TestThread4 implements Runnable{ private int ticketNums = 10; @Override public void run() { while (true){ if(ticketNums \u003c=0){ break; } // 模拟延时 try { Thread.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } // 买票 System.out.println(Thread.currentThread().getName() + \"拿到了第\" + ticketNums-- + \"票\"); } } public static void main(String[] args) { TestThread4 testThread4 = new TestThread4(); new Thread(testThread4, \"小明\").start(); new Thread(testThread4, \"老师\").start(); new Thread(testThread4, \"黄牛党\").start(); } } 发现多个线程对同一个资源进行操作的时候，会出现并发问题，线程不安全，数据紊乱 ","date":"2022-04-04","objectID":"/java_threads_learning1/:3:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习1","uri":"/java_threads_learning1/"},{"categories":["Java多线程学习"],"content":"龟兔赛跑案例 package MultiThread_learning; // 模拟归途赛跑 public class Race implements Runnable{ private static String winner; @Override public void run() { for (int i = 0; i \u003c= 100; i++) { // 模拟兔子休息, 10次休息1毫秒 if (Thread.currentThread().getName().equals(\"兔子\") \u0026\u0026 i%10 == 0){ try { Thread.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } } // 判断比赛是否结束 boolean flag = gameOver(i); // 如果比赛结束，停止程序 if(flag){ break; } System.out.println(Thread.currentThread().getName() + \"--\u003e跑了\" + i + \"步\"); } } private boolean gameOver(int steps){ // 判断是否有胜利者 if (winner != null){ // 已经存在胜利者了 return true; }else{ if (steps \u003e= 100){ winner = Thread.currentThread().getName(); System.out.println(\"winner is \" + winner); return true; } } return false; } public static void main(String[] args) { Race race = new Race(); new Thread(race, \"兔子\").start(); new Thread(race, \"乌龟\").start(); } } ","date":"2022-04-04","objectID":"/java_threads_learning1/:4:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习1","uri":"/java_threads_learning1/"},{"categories":["Java多线程学习"],"content":"实现Callable接口 实现Callable接口需要返回值的类型 重写call方法，需要抛出异常 创建目标对象 创建执行服务 提交执行 获取结果 关闭服务 ","date":"2022-04-04","objectID":"/java_threads_learning1/:5:0","tags":["Java","Thread","多线程"],"title":"Java多线程学习1","uri":"/java_threads_learning1/"},{"categories":["Java多线程学习"],"content":"具体实现 package MultiThread_learning; import java.util.concurrent.*; // 多线程的方式三， 实现callable接口 public class TestCallable implements Callable\u003cBoolean\u003e { public String url; public String name; public TestCallable(String url, String name){ this.url = url; this.name = name; } @Override public Boolean call() throws Exception { WebDownloader webDownloader = new WebDownloader(); webDownloader.downloader(url, name); System.out.println(\"下载了文件名为：\"+name); return true; } public static void main(String[] args) throws ExecutionException, InterruptedException { TestCallable testCallable1 = new TestCallable(\"https://img-blog.csdnimg.cn/88eba0a511a84000b1e458e9aca123c7.png\", \"1.png\"); TestCallable testCallable2 = new TestCallable(\"https://img-blog.csdnimg.cn/88eba0a511a84000b1e458e9aca123c7.png\", \"2.png\"); TestCallable testCallable3 = new TestCallable(\"https://img-blog.csdnimg.cn/88eba0a511a84000b1e458e9aca123c7.png\", \"3.png\"); // 创建执行服务, 生成一个线程池 ExecutorService ser = Executors.newFixedThreadPool(3); // 提交执行 Future\u003cBoolean\u003e r1 = ser.submit(testCallable1); Future\u003cBoolean\u003e r2 = ser.submit(testCallable2); Future\u003cBoolean\u003e r3 = ser.submit(testCallable3); // 获取结果 boolean rs1 = r1.get(); boolean rs2 = r2.get(); boolean rs3 = r3.get(); // 关闭服务 ser.shutdown(); } } // 下载器 class WebDownloader{ public void downloader(String url, String name){ try{ FileUtils.copyURLToFile(new URL(url), new File(name)); }catch(IOException e){ e.printStackTrace(); System.out.println(\"IO异常，downloader出现问题\"); } } } ","date":"2022-04-04","objectID":"/java_threads_learning1/:5:1","tags":["Java","Thread","多线程"],"title":"Java多线程学习1","uri":"/java_threads_learning1/"},{"categories":["Java多线程学习"],"content":"Callable特性 可以定义返回值 可以跑出异常 ","date":"2022-04-04","objectID":"/java_threads_learning1/:5:2","tags":["Java","Thread","多线程"],"title":"Java多线程学习1","uri":"/java_threads_learning1/"},{"categories":["JVM学习"],"content":"遇到OOM错误的处理方式 尝试扩大对内存空间大小 能够看到代码第几行出错：内存快照工具（MAT， Jprofiler） ","date":"2022-04-03","objectID":"/jvm_learning6/:1:0","tags":["Java","算法","JVM"],"title":"JVM 学习6","uri":"/jvm_learning6/"},{"categories":["JVM学习"],"content":"MAT(eclipse)/Jprofiler(IDEA)作用 分析Dump内存文件，快速定位内存泄漏问题 获取堆中的数据 获的大的对象 ","date":"2022-04-03","objectID":"/jvm_learning6/:1:1","tags":["Java","算法","JVM"],"title":"JVM 学习6","uri":"/jvm_learning6/"},{"categories":["JVM学习"],"content":"使用Jprofiler 查看内存快照 命令-Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError，得到内存快照.hprof文件，使用Jprofiler打开，存放在模块级别的目录下 Jprofiler 中可以查看的内容如下 查看思路：先看大的对象在Current Object Set 中查看 再进Thread Dump中查看是哪个线程的哪行代码出现问题 ","date":"2022-04-03","objectID":"/jvm_learning6/:1:2","tags":["Java","算法","JVM"],"title":"JVM 学习6","uri":"/jvm_learning6/"},{"categories":["JVM学习"],"content":"GC补充知识点 GC的作用区域为方法区和堆当中 垃圾回收只能JVM自行处理，程序员不能手动回收，只能提醒 JVM进行垃圾回收时，并不是对三个区域（新生区，幸存区from，幸存区to，老年区）统一回收，大部分时候都是回收新生区 ","date":"2022-04-03","objectID":"/jvm_learning6/:2:0","tags":["Java","算法","JVM"],"title":"JVM 学习6","uri":"/jvm_learning6/"},{"categories":["JVM学习"],"content":"GC的分类 轻GC（普通GC）：只针对新生代，偶尔针对幸存区 重GC（全局GC）：所有的内容都把内存释放掉 ","date":"2022-04-03","objectID":"/jvm_learning6/:2:1","tags":["Java","算法","JVM"],"title":"JVM 学习6","uri":"/jvm_learning6/"},{"categories":["JVM学习"],"content":"例题 JVM的内存模型和分区，详细到每个区放什么 堆里面的分区有哪些 GC算法有哪些：标记清除法、标记整理（标记压缩）法、复制算法、引用计数器 轻GC和重GC分别在什么时候发生 ","date":"2022-04-03","objectID":"/jvm_learning6/:2:2","tags":["Java","算法","JVM"],"title":"JVM 学习6","uri":"/jvm_learning6/"},{"categories":["JVM学习"],"content":"GC常用算法 ","date":"2022-04-03","objectID":"/jvm_learning6/:3:0","tags":["Java","算法","JVM"],"title":"JVM 学习6","uri":"/jvm_learning6/"},{"categories":["JVM学习"],"content":"引用计数法 对象引用次数进行计数 计数器本身也有消耗，这种方法并不高效 淘汰使用少的对象（python用的就是这种方法） ","date":"2022-04-03","objectID":"/jvm_learning6/:3:1","tags":["Java","算法","JVM"],"title":"JVM 学习6","uri":"/jvm_learning6/"},{"categories":["JVM学习"],"content":"复制算法 年轻代（伊甸园区，from，to）主要用的复制算法 幸存区的from和to区之间的交换遵循：谁空谁是to 每次GC之后都会将伊甸园区中活对象，都会进入到幸存区，此时伊甸园区变为空的 from 和 to之间会不停地交换 通过from 和 to 之间的复制，和身份交换，始终保证to是空的 当对象经过15（-XX:MaxTenuringThreshold=15, 此参数设置进入老年区所要经历的GC次数，默认是15）次GC没有被清理掉时，则进入养老区 具体执行过程 Eden区中活下来的部分进入to，且将From中的对象复制到to中 from和to进行名称交换，保证to中始终为空，以备下次GC 所以每次轻GC之后，eden区是空的，to也是空的 经过MaxTenuringThreshold=15次轻GC之后对象在from中还没有被清理，则进入养老区 优点：没有内存碎片 坏处：浪费一半的内存区空间（to区始终是空的），假设对象100%存活（极端情况），此种算法的成本很高 最佳使用场景，对象存活度较低的时候，新生区 ","date":"2022-04-03","objectID":"/jvm_learning6/:3:2","tags":["Java","算法","JVM"],"title":"JVM 学习6","uri":"/jvm_learning6/"},{"categories":["JVM学习"],"content":"标记清除法 扫描对象，对活着的对象进行标记 对没有标记的对象进行清除 缺点：两次扫描严重浪费时间，会产生内存碎片 优点：不需要额外的空间 ","date":"2022-04-03","objectID":"/jvm_learning6/:3:3","tags":["Java","算法","JVM"],"title":"JVM 学习6","uri":"/jvm_learning6/"},{"categories":["JVM学习"],"content":"标记压缩算法 在标记清除的基础上进行再优化，将内存碎片进行压缩，防止内存碎片产生 再次扫描，向一端移动存活对象 多了一个移动成本 ","date":"2022-04-03","objectID":"/jvm_learning6/:3:4","tags":["Java","算法","JVM"],"title":"JVM 学习6","uri":"/jvm_learning6/"},{"categories":["JVM学习"],"content":"标记清除压缩算法 标记清除和标记压缩实际可以结合使用 经过几轮的标记清除之后，碎片多了起来，再进行标记压缩，压缩扫描的效率会高很多 ","date":"2022-04-03","objectID":"/jvm_learning6/:3:5","tags":["Java","算法","JVM"],"title":"JVM 学习6","uri":"/jvm_learning6/"},{"categories":["JVM学习"],"content":"几种算法的对比 内存效率：复制算法\u003e标记清除法\u003e标记压缩算法（时间复杂度） 内存整齐度（内存碎片的多少）：复制算法=标记压缩法\u003e标记清除算法 内存利用率：标记压缩法=标记清除算法\u003e复制算法 ","date":"2022-04-03","objectID":"/jvm_learning6/:3:6","tags":["Java","算法","JVM"],"title":"JVM 学习6","uri":"/jvm_learning6/"},{"categories":["JVM学习"],"content":"总结 没有最好的算法 只有最合适的算法 GC：分代收集算法 年轻代：存活率低，使用复制算法 老年代：存活率高，区域大，使用标记清除（内存碎片不是太多）+标记压缩算法（内存碎片已经很多了）混合实现 ","date":"2022-04-03","objectID":"/jvm_learning6/:3:7","tags":["Java","算法","JVM"],"title":"JVM 学习6","uri":"/jvm_learning6/"},{"categories":["JVM学习"],"content":"JMM（Java Memory Model） 一个缓存一致性协议，用于定义数据读写的规则 ","date":"2022-04-03","objectID":"/jvm_learning6/:4:0","tags":["Java","算法","JVM"],"title":"JVM 学习6","uri":"/jvm_learning6/"},{"categories":["JVM学习"],"content":"三种JVM Hotspot：Sun公司，用户数多 BEA JROckit：Oracle 设个财务前段办公、军事指挥与控制和电信网络的需要 j9vm JIT编译器：IBM公司，以Oracle 的java 为基础 ","date":"2022-04-02","objectID":"/jvm_learning5/:1:0","tags":["Java","算法","JVM"],"title":"JVM 学习5","uri":"/jvm_learning5/"},{"categories":["JVM学习"],"content":"堆（堆内存） Heap，一个JVM只有一个堆内存，堆内存的大小是可以调节的。 ","date":"2022-04-02","objectID":"/jvm_learning5/:2:0","tags":["Java","算法","JVM"],"title":"JVM 学习5","uri":"/jvm_learning5/"},{"categories":["JVM学习"],"content":"基本概念 类加载器读取了类文件之后，类、方法、常量、变量、保存所有引用类型的真实对象 堆内存中细分为三个区域：新生区younger new、养老区old、永久区perm（JDK1.8已经没有永久区，改成元空间了） 新生区包括：伊甸园、幸存0区、幸存1区 如果伊甸园区中新生的对象经过垃圾GC回收之后还没有被回收，则进入幸存0区 如果幸存0区满了，就会进入幸存1区，两个幸存区之间可以相互调动 如果在幸存区之中依然撑过了垃圾回收机制，则进入养老区 垃圾回收分为轻量级、重量级。轻量级针对新生区，重量级针对养老区 永久存储区包括java内置的方法和数据 ","date":"2022-04-02","objectID":"/jvm_learning5/:2:1","tags":["Java","算法","JVM"],"title":"JVM 学习5","uri":"/jvm_learning5/"},{"categories":["JVM学习"],"content":"堆内存溢出错误（OOM） GC 垃圾回收主要是在伊甸园区和养老区 假设内存满了，会报错OOM(OutOfMemoryError)，堆内存不够了，如下图代码所示 在JDK8以后，永久存储区改名你为元空间 ","date":"2022-04-02","objectID":"/jvm_learning5/:2:2","tags":["Java","算法","JVM"],"title":"JVM 学习5","uri":"/jvm_learning5/"},{"categories":["JVM学习"],"content":"新生区 一个类诞生产生死亡的地方 分为伊甸园区和幸存者区（幸存者0区和幸存者1区） 所有的对象都出生在伊甸园区（new） 假设伊甸园区只能存放10个实例对象，就会出发一次轻GC，活下来的对象就会进入幸存区 同理幸存区满了就会触发一次重GC，幸存下来的进入养老区 如果新生区和养老区都满了，则出现OOM错误出现 实际上99%的对象都是临时对象，很难进入到养老区 ","date":"2022-04-02","objectID":"/jvm_learning5/:3:0","tags":["Java","算法","JVM"],"title":"JVM 学习5","uri":"/jvm_learning5/"},{"categories":["JVM学习"],"content":"永久区 这个区域常驻内存，用来存放JDK自身携带的Class对象，Interface元数据 存储Java运行时的一些环境或者类信息 这个区域不存在垃圾回收机制 关闭虚拟机的时候就会释放这个区域的内存 一个启动类如果加载了大量的jar包，或者tomcat部署了太多应用，大量动态生成的反射类，如果这些内容不段被加载，可能会出现OOM错误 ","date":"2022-04-02","objectID":"/jvm_learning5/:4:0","tags":["Java","算法","JVM"],"title":"JVM 学习5","uri":"/jvm_learning5/"},{"categories":["JVM学习"],"content":"版本变化 JDK1.6之前：永久代，常量池在方法区中 JDK1.7：永久代，但是慢慢弱化了，去永久代，常量池在堆中 JDK1.8：无永久代，常量池在元空间之中 ","date":"2022-04-02","objectID":"/jvm_learning5/:4:1","tags":["Java","算法","JVM"],"title":"JVM 学习5","uri":"/jvm_learning5/"},{"categories":["JVM学习"],"content":"堆整体结构 方法区（存放类中的常量等信息–常量池）是一种特殊的堆（堆） package swagger_test; import javax.management.relation.RoleUnresolved; public class HeapTestDemo { public static void main(String[] args) { // 返回最大内存 long maxMemory = Runtime.getRuntime().maxMemory(); // 返回初始化内存 long totalMemory = Runtime.getRuntime().totalMemory(); System.out.println(\"maxMemory=\" + maxMemory + \"字节\\t\" + (maxMemory/(double)1024/1024) + \"MB\"); System.out.println(\"totalMemory=\" + totalMemory + \"字节\\t\" + (totalMemory/(double)1024/1024) + \"MB\"); } } ","date":"2022-04-02","objectID":"/jvm_learning5/:4:2","tags":["Java","算法","JVM"],"title":"JVM 学习5","uri":"/jvm_learning5/"},{"categories":["JVM学习"],"content":"查看堆内存 最大内存约等于计算机总内存的4分之一 初始化内存为计算机总内存的64分之一 元空间逻辑上存在，但是物理上不一定存在，实际上在系统的内存中 ","date":"2022-04-02","objectID":"/jvm_learning5/:4:3","tags":["Java","算法","JVM"],"title":"JVM 学习5","uri":"/jvm_learning5/"},{"categories":["JVM学习"],"content":"调整堆内存大小 其中-Xmx为最大内存大小，调整为1024mb 其中-Xms为初始化内存大小，调整为1024mb -XX:PrintGCDetails为打印具体的内存信息 ","date":"2022-04-02","objectID":"/jvm_learning5/:4:4","tags":["Java","算法","JVM"],"title":"JVM 学习5","uri":"/jvm_learning5/"},{"categories":["JVM学习"],"content":"栈基本概念 一种先进后出的数据结构与队列相对 栈内存，主管程序的运行 生命周期与线程同步，线程结束，栈内存也就释放了 对于栈内存来说，不存在垃圾回收机制 ","date":"2022-03-30","objectID":"/jvm_learning4/:1:0","tags":["Java","算法","JVM"],"title":"JVM 学习4","uri":"/jvm_learning4/"},{"categories":["JVM学习"],"content":"执行是栈内存的执行情况 首先main方法压栈 main中调用test方法，test压栈 test执行完后出栈 main执行完后出栈，整个程序执行完成 ","date":"2022-03-30","objectID":"/jvm_learning4/:2:0","tags":["Java","算法","JVM"],"title":"JVM 学习4","uri":"/jvm_learning4/"},{"categories":["JVM学习"],"content":"栈内存溢出错误 test 方法 和 a方法两者之间递归调用 无法停止，说明在不停地向占内存中压栈，耗尽栈内存空间，导致栈内存溢出（StackOverflowError） ","date":"2022-03-30","objectID":"/jvm_learning4/:3:0","tags":["Java","算法","JVM"],"title":"JVM 学习4","uri":"/jvm_learning4/"},{"categories":["JVM学习"],"content":"栈内存放的数据 八大基本类型 对象的引用 实例的方法 ","date":"2022-03-30","objectID":"/jvm_learning4/:4:0","tags":["Java","算法","JVM"],"title":"JVM 学习4","uri":"/jvm_learning4/"},{"categories":["JVM学习"],"content":"栈运行原理 每一个执行的方法都会产生一个栈帧 程序正在执行的方法永远在栈顶 stack1 和 stack2均为一个栈帧 每一个栈帧内部都存放着数据 ","date":"2022-03-30","objectID":"/jvm_learning4/:5:0","tags":["Java","算法","JVM"],"title":"JVM 学习4","uri":"/jvm_learning4/"},{"categories":["JVM学习"],"content":"栈、堆、方法区的交互关系 关键：绿色为栈内存，浅蓝色为堆内存，红色为方法区，蓝色为常量池，白色为通过编译的class文件 new一个对象时，加一个引用到栈的一个栈帧里 栈里还包括其他存放数据 new的对象数据存放在堆内存中，通过栈中的引用找到 堆中对象所包含的常量去方法区中的常量池寻找 ","date":"2022-03-30","objectID":"/jvm_learning4/:6:0","tags":["Java","算法","JVM"],"title":"JVM 学习4","uri":"/jvm_learning4/"},{"categories":["JVM学习"],"content":"沙箱安全机制 限制程序运行的环境，将java代码限定在JVM特定的运行范围内 当前最新的安全机制实现，则引入了域(Domain) 的概念。虚拟机会把所有代码加载到不同的系统域和应用域，系统域部分专门负责与关键资源进行交互 各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。 虚拟机中不同的受保护域(Protected Domain)，对应不一样的权限 (Permission)。 存在于不同域中的类文件 就具有了当前域的全部权限， ","date":"2022-03-30","objectID":"/jvm_learning3/:1:0","tags":["Java","算法","JVM"],"title":"JVM 学习3","uri":"/jvm_learning3/"},{"categories":["JVM学习"],"content":"组成沙箱的基本组件 字节码校验器：确保Java类文件遵循Java语言规范，并不是所有的类文件都会经过字节码校验，比如核心类 类装载器：防止恶意代码进行干涉（双亲委派机制）；守护了被信任类库的边界；将代码归入保护域，确定哪些代码可以进行操作 ","date":"2022-03-30","objectID":"/jvm_learning3/:1:1","tags":["Java","算法","JVM"],"title":"JVM 学习3","uri":"/jvm_learning3/"},{"categories":["JVM学习"],"content":"类装载器的工作模式方法 从最内层的JVM自带类加载器开始加载，防止外层恶意同名类得不到加载从而无法使用 严格通过包来区分访问域，外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码自然就无法生效 存取控制器：存取控制器可以控制核心API对操作系统的存取权限，而这个控制策略的设定可以有用户指定 安全管理器：是核心API和操作系统之间的主要接口，实现权限控制，比存取控制器的优先级高 安全软件包：java.security下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性：安全提供者、消息摘要、数字签名keytools（eg：生成安全证书，可以访问到https）、加密、鉴别 ","date":"2022-03-30","objectID":"/jvm_learning3/:1:2","tags":["Java","算法","JVM"],"title":"JVM 学习3","uri":"/jvm_learning3/"},{"categories":["JVM学习"],"content":"native 凡是带了native 关键字的方法，说明java的作用范围已经达不到了，开始调用底层C++代码 实际上是进入了内存中的本地方法栈 通过本地方法栈调用本地接口JNI（Java Native Interface），使用本地方法库 JNI的作用，扩展Java的使用，融合不同的变成语言，为Java所用 Java 诞生时C、C++ 程序员横行，必须要有调用C或者C++代码的能力 他在内存区域中转么开辟了一块标记区域–本地方法栈，登记native方法 在最终执行的时候通过JNI加载本地方法库中的方法 调用其他接口 eg：robot类操作电脑操作、驱动硬件、管理系统 ","date":"2022-03-30","objectID":"/jvm_learning3/:2:0","tags":["Java","算法","JVM"],"title":"JVM 学习3","uri":"/jvm_learning3/"},{"categories":["JVM学习"],"content":"PC寄存器—程序计数器（program counter register） 每一个线程都有一个程序计数器 线程是私有的，就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址） 然后执行引擎读取下一条命令，是一个非常小的内存空间，可以忽略不计 ","date":"2022-03-30","objectID":"/jvm_learning3/:3:0","tags":["Java","算法","JVM"],"title":"JVM 学习3","uri":"/jvm_learning3/"},{"categories":["JVM学习"],"content":"方法区（method area） 方法区被所有线程所共享，所有定义方法的信息都保存在该区域 共享的内容包括：静态变量static、常量final、类信息（构造方法、接口定义）Class、运行时的常量池 注意实例变量存在对内存中，和方法区无关 ","date":"2022-03-30","objectID":"/jvm_learning3/:4:0","tags":["Java","算法","JVM"],"title":"JVM 学习3","uri":"/jvm_learning3/"},{"categories":["6D pose"],"content":"robot grasping 基础 主要分为三个关键任务，Object Localization，Object Pose Estimation，Grasp Estimation Object Localization主要的几种方法，Object Localization without classification，Object Detection，Object Instance segmentation Object Pose Estimation主要的几种方法，Corresponding-based methods，Template-based methods， Voting-based methods Grasp Estimation的两种方式，2D planer grasp，6DoF grasp tips：这三个关键任务不一定要全部都用上才能抓取识别，实际上很时候只用其中的1个或者2个就可以完成抓取识别 ","date":"2022-03-29","objectID":"/6dpose_survey/:1:0","tags":["6D Pose","Category level","Instance level"],"title":"6DPose 论文总结","uri":"/6dpose_survey/"},{"categories":["6D pose"],"content":"各个关键任务的作用 Object Localization：找到目标对象的区域所在 Object Pose Estimation：估计物体的6D姿态，以方便生成抓取位姿 Grasp Estimation：估计物体的抓取位姿，2D抓取约束为从一个方向抓取，但是6DoF 抓取可以从任意方向进行抓取 ","date":"2022-03-29","objectID":"/6dpose_survey/:1:1","tags":["6D Pose","Category level","Instance level"],"title":"6DPose 论文总结","uri":"/6dpose_survey/"},{"categories":["6D pose"],"content":"一个抓取系统所包含的部分 grasp detection system：进行抓取姿态预测 grasp planning system：有了姿态预测之后进行抓取路径规划 control system：控制各个部件 ","date":"2022-03-29","objectID":"/6dpose_survey/:1:2","tags":["6D Pose","Category level","Instance level"],"title":"6DPose 论文总结","uri":"/6dpose_survey/"},{"categories":["6D pose"],"content":"抓取end effectors 夹爪：平行夹爪，三指夹爪，五指夹爪 吸盘：单吸盘，多吸盘（此种方式抓取方式简单，面对几何复杂的物体难以起效） ","date":"2022-03-29","objectID":"/6dpose_survey/:1:3","tags":["6D Pose","Category level","Instance level"],"title":"6DPose 论文总结","uri":"/6dpose_survey/"},{"categories":["6D pose"],"content":"抓取方式的不同 ","date":"2022-03-29","objectID":"/6dpose_survey/:2:0","tags":["6D Pose","Category level","Instance level"],"title":"6DPose 论文总结","uri":"/6dpose_survey/"},{"categories":["6D pose"],"content":"2D planer grasp 2D 形式的抓取规定机械臂只能朝一个方向去抓取（垂直于工作台平面） 高度是固定的，抓取方式预测被降为2D➕1D的方式，2D为平面上的物体位置，1D为旋转角，有些还会加上夹爪的宽度参数和矩形框描述法中的高度参数 具体有两种方法：接触点评估法（平行夹爪与物体基础的两个点，如double dot图），矩形框评估法（如上图） ","date":"2022-03-29","objectID":"/6dpose_survey/:2:1","tags":["6D Pose","Category level","Instance level"],"title":"6DPose 论文总结","uri":"/6dpose_survey/"},{"categories":["6D pose"],"content":"6DoF grasp 在3D空间中可以以任意角度对物体进行抓取，所以不能像2D planer grasp方法那样对抓取方式进行简化 开始时使用分析法，之后在RGB-D 的辅助下，开始使用深度学习的方法，进行预测 开始时都是对已知物体进行预测，之后开始对陌生物体也进行预测 基于部分局部点云的方法：不需要物体的CAD模型，还可以细分为估计候选抓取方法质量的方法，和从现有抓取转移抓取的方法 基于完整形状的方法：当目标物体的CAD模型已知时，可以直接预测出6D物体位姿，当CAD模型未知时，使用点云重建CAD模型，得到完整形状，从而预测6D物体位姿 ","date":"2022-03-29","objectID":"/6dpose_survey/:2:2","tags":["6D Pose","Category level","Instance level"],"title":"6DPose 论文总结","uri":"/6dpose_survey/"},{"categories":["6D pose"],"content":"9Dof grasp 6DoF的基础上加上了对物体长宽高的预测 可视化结果多为Bounding Box，图中的红绿蓝三条线为空间坐标，bounding box 包含三维旋转位姿和三维scale信息 ","date":"2022-03-29","objectID":"/6dpose_survey/:2:3","tags":["6D Pose","Category level","Instance level"],"title":"6DPose 论文总结","uri":"/6dpose_survey/"},{"categories":["6D pose"],"content":"object localization Object Localization without classification：找到目标物体所在的区域，但是不知道目标物体的类别 Object Detection：找到目标物体的所在的区域，同时知道其类别，多用于目标区域内有多个物体，要找出指定物体的位置 Object Instance segmentation：指的是探测像素级别某一类别物体的实例对象 ","date":"2022-03-29","objectID":"/6dpose_survey/:3:0","tags":["6D Pose","Category level","Instance level"],"title":"6DPose 论文总结","uri":"/6dpose_survey/"},{"categories":["6D pose"],"content":"关注的问题 对遮挡物体的鲁棒性 如何处理对称物体的ambiguous rotation问题 ","date":"2022-03-29","objectID":"/6dpose_survey/:4:0","tags":["6D Pose","Category level","Instance level"],"title":"6DPose 论文总结","uri":"/6dpose_survey/"},{"categories":["6D pose"],"content":"分类 使用方法分类：correspondence-based，template-based，voting-based（keypoint-based） 预测目标级别分类：instance-level，category-level instance-level常用技术路线：实例分割之后与标准CAD模型进行模板匹配回归出位姿信息 category-level常用技术路线：缺少实例目标CAD模型，需要额外对每个Category设计标注范式 By Boyan Wei ","date":"2022-03-29","objectID":"/6dpose_survey/:5:0","tags":["6D Pose","Category level","Instance level"],"title":"6DPose 论文总结","uri":"/6dpose_survey/"},{"categories":["JVM学习"],"content":"JVM常见的问题 基本都是理论知识 谈谈你对JVM的理解 JAVA8 虚拟机和之前的区别 什么是OOM 什么是栈溢出StackOverFlowError，怎么分析 JVM的常用调优参数 内存快照如何抓取 怎么分析Dump文件 谈谈JVM中类加载器你的认识 ","date":"2022-03-29","objectID":"/jvm_learning2/:1:0","tags":["Java","算法","JVM"],"title":"JVM 学习2","uri":"/jvm_learning2/"},{"categories":["JVM学习"],"content":"重点 JVM的位置 JVM的体系结构 类加载器 双亲委派机制 沙箱安全机制 Native PC寄存器 方法区 栈 三种JVM 堆 新生区 老年区 永久区 堆内存调优 GC垃圾回收机制 GC常用算法 JMM ","date":"2022-03-29","objectID":"/jvm_learning2/:2:0","tags":["Java","算法","JVM"],"title":"JVM 学习2","uri":"/jvm_learning2/"},{"categories":["JVM学习"],"content":"学习方法 百度搜索 思维导图 ","date":"2022-03-29","objectID":"/jvm_learning2/:3:0","tags":["Java","算法","JVM"],"title":"JVM 学习2","uri":"/jvm_learning2/"},{"categories":["JVM学习"],"content":"JVM的位置 基础是硬件体系，以上是操作系统，JVM依托于操作系统之上 实际上运行只需要JRE即可（整个JDK太大了），java程序可以直接运行在JRE上 ","date":"2022-03-29","objectID":"/jvm_learning2/:4:0","tags":["Java","算法","JVM"],"title":"JVM 学习2","uri":"/jvm_learning2/"},{"categories":["JVM学习"],"content":"JVM的体系结构 java栈、本地方法栈、程序计数器 不会有垃圾回收机制 方法区是一种特殊的堆 垃圾回收机制存在于方法区和堆中 JVM调优基本都是调堆 native 中的本地方法库指的是java的底层实现，比如多线程中的start 方法，其中底层实现调用了native库中的start0方法，由c++是实现 ","date":"2022-03-29","objectID":"/jvm_learning2/:5:0","tags":["Java","算法","JVM"],"title":"JVM 学习2","uri":"/jvm_learning2/"},{"categories":["JVM学习"],"content":"类加载器 作用：加载class文件 new 一个对象的时候，对象的引用(名字、地址)在栈中，实际的对象数据都在在堆内存中 虚拟机自带的加载器 启动类（根）加载器 扩展类加载器 应用程序加载器 java 的底层是C++实现的，去掉了C++ 当中的指针和内存管理，内存管理全部交给JVM来进行管理了。 ","date":"2022-03-29","objectID":"/jvm_learning2/:6:0","tags":["Java","算法","JVM"],"title":"JVM 学习2","uri":"/jvm_learning2/"},{"categories":["JVM学习"],"content":"简单过程 类加载器收到类加载请求 将这个请求向上委托给父类加载器去完成，一直向上委托，直到委托到boot class loader（启动类加载器） 检查启动类加载器是否能够加载当前这个类，如果能加载就结束，使用当前加载器，否则，跑出异常，通知字加载器进行加载 重复步骤3（最后一层子类就是当前用户自定义的类—-app） ","date":"2022-03-29","objectID":"/jvm_learning2/:6:1","tags":["Java","算法","JVM"],"title":"JVM 学习2","uri":"/jvm_learning2/"},{"categories":["JVM学习"],"content":"双亲委派机制 为了安全而执行，避免程序员改动boot 加载器所涉及的java基础包，造成不必要的错误 先去boot 根加载器中寻找，再去ext 扩展类加载器中寻找，最后去app 应用程序（自定义）加载类中寻找，如果自定义的方法和类与上述路径有重名，则执行上述路径中的 ","date":"2022-03-29","objectID":"/jvm_learning2/:7:0","tags":["Java","算法","JVM"],"title":"JVM 学习2","uri":"/jvm_learning2/"},{"categories":["6D pose"],"content":"背景 真实数据集上训练出来的模型往往难以推广到没有遇到过的场景 实例级别的9D姿态预测在测试时需要对没有见过的物体也有效，因为实例级别预测是没有CAD模型的，这往往也很难 ","date":"2022-03-19","objectID":"/category_level_1_cppf/:1:0","tags":["6D Pose","Category level","9D Pose"],"title":"CPPF","uri":"/category_level_1_cppf/"},{"categories":["6D pose"],"content":"贡献点 基于PPF(pair point features)提出CPPF(Category level pair point features)投票法进行9D姿态预测 提出一种由粗到细的算法消除噪声点对（当实例分割算法不够精准时） 提出一种实例分割算法用于发现目标物体 提出一个binary disambiguating classification task消除旋转姿态投票误报 只在虚拟点云上进行训练，除非物体在几何上的姿态非常模糊 RGB信息被用来消除姿态歧义 ","date":"2022-03-19","objectID":"/category_level_1_cppf/:2:0","tags":["6D Pose","Category level","9D Pose"],"title":"CPPF","uri":"/category_level_1_cppf/"},{"categories":["6D pose"],"content":"数据集 NOCS REAL275 SUN RGB-D ","date":"2022-03-19","objectID":"/category_level_1_cppf/:3:0","tags":["6D Pose","Category level","9D Pose"],"title":"CPPF","uri":"/category_level_1_cppf/"},{"categories":["6D pose"],"content":"实验 NOCS REAL275 对比实验 NOCS REAL275 仅提供bounding box 进行9D预测实验 SUN RGB-D 更加复杂的真实环境实验 ","date":"2022-03-19","objectID":"/category_level_1_cppf/:4:0","tags":["6D Pose","Category level","9D Pose"],"title":"CPPF","uri":"/category_level_1_cppf/"},{"categories":["6D pose"],"content":"pipeline 其中u，v确定中心点 a，B确定rotation 伽马确定scale 训练的输入为仿真数据集模型 ","date":"2022-03-19","objectID":"/category_level_1_cppf/:5:0","tags":["6D Pose","Category level","9D Pose"],"title":"CPPF","uri":"/category_level_1_cppf/"},{"categories":["6D pose"],"content":"voting-based ","date":"2022-03-19","objectID":"/category_level_1_cppf/:6:0","tags":["6D Pose","Category level","9D Pose"],"title":"CPPF","uri":"/category_level_1_cppf/"},{"categories":["6D pose"],"content":"voting for center 通过一组点对p1、p2确定一组U，V向量 计算出center 多组candidates 进行投票 ","date":"2022-03-19","objectID":"/category_level_1_cppf/:6:1","tags":["6D Pose","Category level","9D Pose"],"title":"CPPF","uri":"/category_level_1_cppf/"},{"categories":["6D pose"],"content":"voting for orientation 浅色部分为candidate orientation votes部分 可以看到中间浅色部分同时被两组点对投票 对如下两者的交叉熵进行二分类 如果CrossEntropy(ˆσ , σˆ)比 CrossEntropy(−σˆ , σˆ)，更小，就保留e1，反之，则保留-e1 ","date":"2022-03-19","objectID":"/category_level_1_cppf/:6:2","tags":["6D Pose","Category level","9D Pose"],"title":"CPPF","uri":"/category_level_1_cppf/"},{"categories":["6D pose"],"content":"voting for scales 开始时为采样点的平均值 之后进过vating，找到最终的scale ","date":"2022-03-19","objectID":"/category_level_1_cppf/:6:3","tags":["6D Pose","Category level","9D Pose"],"title":"CPPF","uri":"/category_level_1_cppf/"},{"categories":["开发工具"],"content":"基础结构 用户连接 connection–mysql 数据库 database–information_schema 表格 table 视图 view 等等 ","date":"2022-02-22","objectID":"/mysql_learning/:1:0","tags":["SQL","mysql","navicat"],"title":"Mysql学习1-基础命令行操作","uri":"/mysql_learning/"},{"categories":["开发工具"],"content":"连接数据库 navicat 双击数据库，创建连接 命令行连接 mysql -uroot -pWby785403310 修改密码 updatemysql.usersetauthentication_string=password('123456')whereuser='root'andHost='localhost'; 刷新权限 flushprivileges; ","date":"2022-02-22","objectID":"/mysql_learning/:2:0","tags":["SQL","mysql","navicat"],"title":"Mysql学习1-基础命令行操作","uri":"/mysql_learning/"},{"categories":["开发工具"],"content":"常用基础命令 查看所有数据库 showdatabases; 使用数据库 use + database名称 usemysql; 查看所有table showtables; 查看指定表结构 describeuser; 创建一个数据库 createdatabasewestos; 退出连接和注视 exit;--退出连接 --单行注释 /* sql 多行注释 */ ","date":"2022-02-22","objectID":"/mysql_learning/:3:0","tags":["SQL","mysql","navicat"],"title":"Mysql学习1-基础命令行操作","uri":"/mysql_learning/"},{"categories":["开发工具"],"content":"mysql 语言种类 CRUD 增删改查 DDL database define language DML database manipulate language DQL database query language DCL database control language CV 程序员 API 程序员 CRUD 程序员（业务） ","date":"2022-02-22","objectID":"/mysql_learning/:4:0","tags":["SQL","mysql","navicat"],"title":"Mysql学习1-基础命令行操作","uri":"/mysql_learning/"},{"categories":["开发工具"],"content":"操作数据库 操作数据库\u003e操作数据库中的表\u003e操作数据库中的表数据 关键字不区分大小写 ","date":"2022-02-22","objectID":"/mysql_learning/:5:0","tags":["SQL","mysql","navicat"],"title":"Mysql学习1-基础命令行操作","uri":"/mysql_learning/"},{"categories":["开发工具"],"content":"操作数据库 （了解） 创建数据库 CREATE DATABASE IF NOT EXISTS westos; 删除数据库 DROP DATABASE IF EXISTS hello; 使用数据库 use `school` (如果表明和字段名是一个保留字，应该加上反引号) 查看数据库 show databases ","date":"2022-02-22","objectID":"/mysql_learning/:5:1","tags":["SQL","mysql","navicat"],"title":"Mysql学习1-基础命令行操作","uri":"/mysql_learning/"},{"categories":["开发工具"],"content":"数据库的数据（列）类型 1 数值 tinyint 十分小的数据 1个字节 smallint 较小的数据 2个字节 mediumint 中等大小 3个字节 int 标准的整数 4个字节 bigint 较大的数据 8个字节 float 单精度 4个字节 double 双精度 8个字节（精度问题） decimal 字符串形式的浮点数（金融计算，一般是decimal） 2 字符串 char 字符固定大小 0～255 varchar 可变字符串 0～65535 常用变量 tinytext 微型文本 2^8-1 text 文本类型 一般用于大型文章 3 时间日期 date YYYY-MM-DD 日期格式 time HH：mm：ss 时间格式 datetime YYYY-MM-DD HH：mm：ss 最常用的时间格式 timestamp 时间戳 1970.1.1 到现在的毫秒数 year 年份表示 4 null 没有值，未知 不要使用null进行运算 ","date":"2022-02-22","objectID":"/mysql_learning/:5:2","tags":["SQL","mysql","navicat"],"title":"Mysql学习1-基础命令行操作","uri":"/mysql_learning/"},{"categories":["开发工具"],"content":"下载Hugo ","date":"2022-02-16","objectID":"/hugo_learning/:1:0","tags":["hugo"],"title":"Hugo 使用教程","uri":"/hugo_learning/"},{"categories":["开发工具"],"content":"使用 brew 来安装hugo brew install hugo ","date":"2022-02-16","objectID":"/hugo_learning/:1:1","tags":["hugo"],"title":"Hugo 使用教程","uri":"/hugo_learning/"},{"categories":["开发工具"],"content":"新建一个hugo 项目 hugo new site mysite ","date":"2022-02-16","objectID":"/hugo_learning/:1:2","tags":["hugo"],"title":"Hugo 使用教程","uri":"/hugo_learning/"},{"categories":["开发工具"],"content":"hugo 项目文件结构介绍 content 博客内容 static 图片 theme 主题 ","date":"2022-02-16","objectID":"/hugo_learning/:1:3","tags":["hugo"],"title":"Hugo 使用教程","uri":"/hugo_learning/"},{"categories":["开发工具"],"content":"主题的配置 ","date":"2022-02-16","objectID":"/hugo_learning/:2:0","tags":["hugo"],"title":"Hugo 使用教程","uri":"/hugo_learning/"},{"categories":["开发工具"],"content":"主题下载 进入gohugo.io 搜索一个主题下载到项目中的theme 文件夹之中 ","date":"2022-02-16","objectID":"/hugo_learning/:2:1","tags":["hugo"],"title":"Hugo 使用教程","uri":"/hugo_learning/"},{"categories":["开发工具"],"content":"主题的配置 进入下载主题的说明文档 https://hugoloveit.com/zh-cn/theme-documentation-basics/ 复制基本配置，并覆盖项目根目录的config.toml 文件 ","date":"2022-02-16","objectID":"/hugo_learning/:2:2","tags":["hugo"],"title":"Hugo 使用教程","uri":"/hugo_learning/"},{"categories":["开发工具"],"content":"创建第一篇博客 hugo new posts/first_post.md ","date":"2022-02-16","objectID":"/hugo_learning/:2:3","tags":["hugo"],"title":"Hugo 使用教程","uri":"/hugo_learning/"},{"categories":["开发工具"],"content":"在本地启动网站 hugo serve --buildDrafts 这里是 –buildDrafts 指文档的草稿属性为真，就需要此参数，或者直接将对应markdown文件中的draft属性设置为false ","date":"2022-02-16","objectID":"/hugo_learning/:2:4","tags":["hugo"],"title":"Hugo 使用教程","uri":"/hugo_learning/"},{"categories":["开发工具"],"content":"网站高阶参数配置 复制 https://hugoloveit.com/zh-cn/theme-documentation-basics/#site-configuration 中的config.toml 文件补充到本地的对应文件当中去，注意有几个参数是重复的， ","date":"2022-02-16","objectID":"/hugo_learning/:2:5","tags":["hugo"],"title":"Hugo 使用教程","uri":"/hugo_learning/"},{"categories":["开发工具"],"content":"部署到github.io 服务器 ","date":"2022-02-16","objectID":"/hugo_learning/:3:0","tags":["hugo"],"title":"Hugo 使用教程","uri":"/hugo_learning/"},{"categories":["开发工具"],"content":"github仓库新建 新建一个项目，名字为： github账号名.github.io ","date":"2022-02-16","objectID":"/hugo_learning/:3:1","tags":["hugo"],"title":"Hugo 使用教程","uri":"/hugo_learning/"},{"categories":["开发工具"],"content":"本地对接远程服务器地址 命令 hugo --theme=LoveIt --baseUrl=\"https://swaggerwei.github.io/\" -D 可以发现本地生成了一个public文件夹 命令 cd public git init git add . git commit -m \"first commit\" git remote add origin git@github.com:SwaggerWei/SwaggerWei.github.io.git git push -u origin master tips: init 和 remote add 操作后续更改博客不需要，只有第一次建仓库的时候需要 ","date":"2022-02-16","objectID":"/hugo_learning/:3:2","tags":["hugo"],"title":"Hugo 使用教程","uri":"/hugo_learning/"},{"categories":["开发工具"],"content":"网页进入个人主页 swaggerwei.github.io tips：一般过五分钟才行 ","date":"2022-02-16","objectID":"/hugo_learning/:3:3","tags":["hugo"],"title":"Hugo 使用教程","uri":"/hugo_learning/"},{"categories":["开发工具"],"content":"团队协作分支开发模式 一个好的 github 项目一般都有多个分支：master，dev，release分支 新建分支 branch git branch branch1 切换到目标分支 git checkout branch1 在本地的branch1 中添加一个helloworld.java 文件 public class HelloWorld { public static void main(String[] args) { System.out.println(\"hello world\"); System.out.println(\"1\"); System.out.println(\"hello world\"); System.out.println(\"2\"); } } 推送到远端 git push --set-upstream origin branch1 然后远端就有了master 和 branch1 两个分支了， 其中branch1 中才有 java文件 同理，在另一个人的主机上， 创建branch2， 并写自己的HelloWorld.java文件 public class HelloWorld { public static void main(String[] args) { System.out.println(\"1\"); System.out.println(\"hello world\"); System.out.println(\"2\"); System.out.println(\"hello world\"); } } 分支的合并发布 首先切换到master分支 git checkout master 拉一下最新的远端分支情况 git pull 将branch1 分支的内容合并到master 分支上 git merge brunch1 推到远端 git push 发现master 分支 也有branch1 中的java文件了 同理合并 branch2 到 master上， 但是发现合并有冲突， 因为有两个同名的Java 文件， 但是文件内容却不一样 ","date":"2022-01-30","objectID":"/git_learning3/:1:0","tags":["git","github","gitee"],"title":"git 代码管理工具3","uri":"/git_learning3/"},{"categories":["开发工具"],"content":"使用IDEA 快速解决 git merge 当中的冲突 右键， 选择git-》resolve conflict 双击出现的 conflict 进行代码比对 手动比对之后出现 all changes have been processed 就可以了， 点击右下角apply 然后上传到远端没有出现错误则说明成功 ","date":"2022-01-30","objectID":"/git_learning3/:2:0","tags":["git","github","gitee"],"title":"git 代码管理工具3","uri":"/git_learning3/"},{"categories":["开发工具"],"content":"如何解决冲突 模拟两个人同时修改一个文件并提交到远端 克隆到两个文件夹 me 和 other git clone git@gitee.com:swagger_wei/test_gitee_git.git me git clone git@gitee.com:swagger_wei/test_gitee_git.git other other 对first.txt 内容作出修改 推送到远端 此时另一个 me 的本地仓库是不知道远程的仓库已经发生了修改的 me 对first.txt 内容作出修改 推送到远端 发现出错，因为本地 me 仓库 不知道远端仓库已经发生了变换， 所以向远端提交失败 拉取远端变化 git pull 发现有pull之后有冲突需要解决 商量之后删掉无用部分， 合并冲突 提交到远端 发现远端已经提交成功 ","date":"2022-01-27","objectID":"/git_learning2/:1:0","tags":["git","github","gitee"],"title":"git 代码管理工具2","uri":"/git_learning2/"},{"categories":["开发工具"],"content":"应用场景 团队协作开发， 避免频繁来回拷贝代码 ","date":"2022-01-17","objectID":"/git_learning/:1:0","tags":["git","github","gitee"],"title":"git 代码管理工具1","uri":"/git_learning/"},{"categories":["开发工具"],"content":"git 工作流程 克隆 Git 资源作为工作目录 在本地的工作副本上做修改操作 如果别人更改了资源可以更新资源 检查修改之后就可以向资源库推送更新 如果发现有错误则可以撤销推送，修改错误，然后重新推送 ","date":"2022-01-17","objectID":"/git_learning/:2:0","tags":["git","github","gitee"],"title":"git 代码管理工具1","uri":"/git_learning/"},{"categories":["开发工具"],"content":"工作区和、暂存区和版本库 工作区，就是本地电脑上可以看到的文件(按下Command+Shift+. 可以显示隐藏文件、文件夹，再按一次，恢复隐藏；) 暂存区，英文stage或者index，一般存放在 .git 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index） 版本库：工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。 ","date":"2022-01-17","objectID":"/git_learning/:3:0","tags":["git","github","gitee"],"title":"git 代码管理工具1","uri":"/git_learning/"},{"categories":["开发工具"],"content":"基本操作命令 当前基本状态 git status 显示当前的最新的branch； 显示没有被commit的 文件（发现.DS_Store和first文件没有被commit） 添加到暂存区 git add 文件名 .为所有文件，再次运行git status，发现所有的文件都已经被添加 添加到版本库 git commit -m \"版本提交的附带信息\" 查看当前的提交和回滚情况 git log 注：为倒叙排序， Initial commit 为默认初始化github 官网创建得到 回滚最新的一次commit git reset commit后跟的ID 回滚之前发现有一个message 为 second commit 的 commit 回滚的ID 填入倒数第二个ID， 说明回滚到倒数第二新的状态 设置邮箱号 git config --global user.email 785403310@qq.com 设置名字 git config --global user.name swagger 然后发现log 信息中的commit 信息变成了自己 推送到github服务器 git push 推送之后发现本地创建的文件已经同步到了gitee上 ","date":"2022-01-17","objectID":"/git_learning/:4:0","tags":["git","github","gitee"],"title":"git 代码管理工具1","uri":"/git_learning/"},{"categories":["JVM学习"],"content":"9 JVM 类加载机制 Java 虚拟机将 Java 源码编译为字节码之后，虚拟机便可以将字节码读取进内存，从而进行解析、运行等整个过程，这个过程我们叫：Java 虚拟机的类加载机制 JVM 虚拟机执行 class 字节码的过程可以分为七个阶段：加载、验证、准备、解析、初始化、使用、卸载。 ","date":"2022-01-07","objectID":"/jvm_learning1/:1:0","tags":["Java","算法","JVM"],"title":"JVM 学习1","uri":"/jvm_learning1/"},{"categories":["JVM学习"],"content":"9.1 加载 JVM 的主要目的是将字节码从各个位置（网络、磁盘等）转化为二进制字节流加载到内存中，接着会为这个类在 JVM 的方法区创建一个对应的 Class 对象，这个 Class 对象就是这个类各种数据的访问入口 ","date":"2022-01-07","objectID":"/jvm_learning1/:1:1","tags":["Java","算法","JVM"],"title":"JVM 学习1","uri":"/jvm_learning1/"},{"categories":["JVM学习"],"content":"9.2 验证 当 JVM 加载完 Class 字节码文件并在方法区创建对应的 Class 对象之后，JVM 便会启动对该字节码流的校验，只有符合 JVM 字节码规范的文件才能被 JVM 正确执行。这个校验过程大致可以分为下面几个类型： JVM规范校验：JVM 会对字节流进行文件格式校验，判断其是否符合 JVM 规范，是否能被当前版本的虚拟机处理。例如：文件是否是以 0x cafe bene开头，主次版本号是否在当前虚拟机处理范围之内等 代码逻辑校验：JVM 会对代码组成的数据流和控制流进行校验，确保 JVM 运行该字节码文件后不会出现致命错误。例如一个方法要求传入 int 类型的参数，但是使用它的时候却传入了一个 String 类型的参数。一个方法要求返回 String 类型的结果，但是最后却没有返回结果。代码中引用了一个名为 Apple 的类，但是你实际上却没有定义 Apple 类 ","date":"2022-01-07","objectID":"/jvm_learning1/:1:2","tags":["Java","算法","JVM"],"title":"JVM 学习1","uri":"/jvm_learning1/"},{"categories":["JVM学习"],"content":"9.3 准备 当完成字节码文件的校验之后，JVM 便会开始为类变量分配内存并初始化。这里需要注意两个关键点，即内存分配的对象以及初始化的类型 内存分配的对象。 Java 中的变量有「类变量」和「类成员变量」两种类型，「类变量」指的是被 static 修饰的变量，而其他所有类型的变量都属于「类成员变量」。在准备阶段，JVM 只会为「类变量」分配内存，而不会为「类成员变量」分配内存。「类成员变量」的内存分配需要等到初始化阶段才开始。 初始化的类型。 在准备阶段，JVM 会为类变量分配内存，并为其初始化。但是这里的初始化指的是为变量赋予 Java 语言中该数据类型的零值，而不是用户代码里初始化的值。但如果一个变量是常量（被 static final 修饰）的话，那么在准备阶段，属性便会被赋予用户希望的值 ","date":"2022-01-07","objectID":"/jvm_learning1/:1:3","tags":["Java","算法","JVM"],"title":"JVM 学习1","uri":"/jvm_learning1/"},{"categories":["JVM学习"],"content":"9.4 解析 当通过准备阶段之后，JVM 针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类引用进行解析。这个阶段的主要任务是将其在常量池中的符号引用替换成直接其在内存中的直接引用。 其实这个阶段对于我们来说也是几乎透明的，了解一下就好 ","date":"2022-01-07","objectID":"/jvm_learning1/:1:4","tags":["Java","算法","JVM"],"title":"JVM 学习1","uri":"/jvm_learning1/"},{"categories":["JVM学习"],"content":"9.5 初始化（重点） 到了初始化阶段，用户定义的 Java 程序代码才真正开始执行。在这个阶段，JVM 会根据语句执行顺序对类对象进行初始化，一般来说当 JVM 遇到下面 5 种情况的时候会触发初始化： 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类 当使用 JDK1.7 动态语言支持时，如果一个 java.lang.invoke.MethodHandle实例最后的解析结果 REF_getstatic,REF_putstatic,REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化 ","date":"2022-01-07","objectID":"/jvm_learning1/:1:5","tags":["Java","算法","JVM"],"title":"JVM 学习1","uri":"/jvm_learning1/"},{"categories":["JVM学习"],"content":"9.6 使用 当 JVM 完成初始化阶段之后，JVM 便开始从入口方法开始执行用户的程序代码。这个阶段也只是了解一下就可以 ","date":"2022-01-07","objectID":"/jvm_learning1/:1:6","tags":["Java","算法","JVM"],"title":"JVM 学习1","uri":"/jvm_learning1/"},{"categories":["JVM学习"],"content":"9.7 卸载 当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存。这个阶段也只是了解一下就可以 ","date":"2022-01-07","objectID":"/jvm_learning1/:1:7","tags":["Java","算法","JVM"],"title":"JVM 学习1","uri":"/jvm_learning1/"},{"categories":["Java学习"],"content":"6 反射 反向获取class中各种对象的信息、例如成员变量、方法、构造方法、包等等信息 ","date":"2022-01-06","objectID":"/java_learning6/:1:0","tags":["Java","算法"],"title":"Java 学习6-反射","uri":"/java_learning6/"},{"categories":["Java学习"],"content":"6.1 创建一个对象的过程 new来实例一个对象时jvm会在加载对应的class文件 jvm在本地磁盘中查找class文件 将class文件读入到内存当中，以便使用 一个class 文件只占用个同一个空间，对此用一个class再new，不会重复在内存空间中初始化 ","date":"2022-01-06","objectID":"/java_learning6/:1:1","tags":["Java","算法"],"title":"Java 学习6-反射","uri":"/java_learning6/"},{"categories":["Java学习"],"content":"6.2 获取类的字节码 //获取类的字节码 // 方法一 Student stu1 = new Student(); Class stuClass = stu1.getClass(); System.out.println(stuClass.toString()); System.out.println(stuClass.getName()); // 方法二 Class stuClass2 = Student.class; System.out.println(stuClass2.toString()); System.out.println(stuClass2 == stuClass); // 方法三 Class stuClass3 = Class.forName(\"reflectionDemo.Student\"); System.out.println(stuClass3.toString()); ","date":"2022-01-06","objectID":"/java_learning6/:1:2","tags":["Java","算法"],"title":"Java 学习6-反射","uri":"/java_learning6/"},{"categories":["Java学习"],"content":"6.3 反射得到有参数的构造函数 // 反射得到有参数构造函数 Constructor c = stuClass3.getConstructor(String.class); c.newInstance(\"wby\"); ","date":"2022-01-06","objectID":"/java_learning6/:1:3","tags":["Java","算法"],"title":"Java 学习6-反射","uri":"/java_learning6/"},{"categories":["Java学习"],"content":"6.4 反射得到私有构造函数 // 反射得到私有构造函数 Constructor c4Private = stuClass3.getDeclaredConstructor(int.class); c4Private.setAccessible(true); c4Private.newInstance(20); ","date":"2022-01-06","objectID":"/java_learning6/:1:4","tags":["Java","算法"],"title":"Java 学习6-反射","uri":"/java_learning6/"},{"categories":["Java学习"],"content":"6.5 反射得到所有的构造方法 Constructor[] c4All = stuClass3.getDeclaredConstructors(); for (Constructor c1 : c4All){ System.out.println(c1); } ","date":"2022-01-06","objectID":"/java_learning6/:1:5","tags":["Java","算法"],"title":"Java 学习6-反射","uri":"/java_learning6/"},{"categories":["Java学习"],"content":"6.6 反射得到类中的普通方法 Student p = (Student) stuClass3.newInstance(); Method m = stuClass3.getMethod(\"Student1\", String.class, int.class); m.invoke(p, \"wby\", 20); ","date":"2022-01-06","objectID":"/java_learning6/:1:6","tags":["Java","算法"],"title":"Java 学习6-反射","uri":"/java_learning6/"},{"categories":["Java学习"],"content":"6.7 反射类中的属性字段 Field f = stuClass3.getField(\"name\"); String s = (String) f.get(p); System.out.println(s); ","date":"2022-01-06","objectID":"/java_learning6/:1:7","tags":["Java","算法"],"title":"Java 学习6-反射","uri":"/java_learning6/"},{"categories":["Java学习"],"content":"6.8 应用场合、缺点 在编译时根本无法知道该对象或类可能属于哪些类，程序只依靠运行时信息来发现该对象和类的真实信息 使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码 使用反射会模糊程序内部逻辑 ","date":"2022-01-06","objectID":"/java_learning6/:1:8","tags":["Java","算法"],"title":"Java 学习6-反射","uri":"/java_learning6/"},{"categories":["Java学习"],"content":"5 泛型 泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数 ","date":"2022-01-06","objectID":"/java_learning5/:1:0","tags":["Java","算法"],"title":"Java 学习5-泛型","uri":"/java_learning5/"},{"categories":["Java学习"],"content":"5.1 泛型方法 在调用时可以接收不同类型的参数 每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开 类型参数能被用来声明返回值类型 泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（像 int、double、char 等） ","date":"2022-01-06","objectID":"/java_learning5/:1:1","tags":["Java","算法"],"title":"Java 学习5-泛型","uri":"/java_learning5/"},{"categories":["Java学习"],"content":"5.2 java 中范型标记符 E - Element (在集合中使用，因为集合中存放的是元素) T - Type（Java 类） K - Key（键） V - Value（值） N - Number（数值类型） ？ - 表示不确定的 java 类型 ","date":"2022-01-06","objectID":"/java_learning5/:1:2","tags":["Java","算法"],"title":"Java 学习5-泛型","uri":"/java_learning5/"},{"categories":["Java学习"],"content":"5.3 类型通配符 类型通配符一般是使用 ‘\u003c \u003e’ 代替具体的类型参数。例如 List 在逻辑上是 List,List 等所有 List\u003c具体类型实参\u003e 的父类 ","date":"2022-01-06","objectID":"/java_learning5/:1:3","tags":["Java","算法"],"title":"Java 学习5-泛型","uri":"/java_learning5/"},{"categories":["Java学习"],"content":"5.4 实例1 — 泛型方法 package GenericsDemo; public class genericDemo { public static \u003c E \u003e void printArray(E[] array){ for(E element : array){ System.out.println(element); } } public static void main(String[] args) { Integer[] intArray = {1 ,2, 3, 4, 5}; Double[] doubleArray = {1.1, 2.1, 3.1, 4.1}; Character[] charArray = {'a', 'b', 'c', 'd'}; System.out.println(\"整型数组元素为：\"); printArray(intArray); System.out.println(\"双精度型数组元素为：\"); printArray(doubleArray); System.out.println(\"字符型数组元素为：\"); printArray(charArray); } } ","date":"2022-01-06","objectID":"/java_learning5/:1:4","tags":["Java","算法"],"title":"Java 学习5-泛型","uri":"/java_learning5/"},{"categories":["Java学习"],"content":"5.5 泛型类 package GenericsDemo; public class genericClassDemo \u003cT\u003e{ public T val; public void add (T val){ this.val = val; } public void display(){ System.out.println(this.val); } public static void main(String[] args) { genericClassDemo\u003cInteger\u003e intTest = new genericClassDemo\u003c\u003e(); genericClassDemo\u003cString\u003e stringTest = new genericClassDemo\u003c\u003e(); intTest.add(1); stringTest.add(\"fdsafdas\"); intTest.display(); stringTest.display(); } } ","date":"2022-01-06","objectID":"/java_learning5/:1:5","tags":["Java","算法"],"title":"Java 学习5-泛型","uri":"/java_learning5/"},{"categories":["Java学习"],"content":"4 异常 异常机制是指当程序出现错误后，程序如何处理。具体来说，异常机制提供了程序退出的安全通道。当出现错误后，程序执行的流程发生改变，程序的控制权转移到异常处理器。 ","date":"2022-01-06","objectID":"/java_learning4/:1:0","tags":["Java","算法"],"title":"Java 学习4-异常","uri":"/java_learning4/"},{"categories":["Java学习"],"content":"4.1 程序错误的分类 编译错误：编译错误是因为程序没有遵循语法规则，编译程序能够自己发现并且提示我们错误的原因和位置 运行时错误：程序在执行时，运行环境发现了不能执行的操作 逻辑错误：程序没有按照预期的逻辑顺序执行。异常也就是指程序运行时发生错误，而异常处理就是对这些错误进行处理和控制 Throwable： 有两个重要的子类：Exception（异常）和 Error（错误），二者都是 Java 异常处理的重要子类，各自都包含大量子类。 异常和错误的区别是：异常能被程序本身处理，错误是无法处理 ","date":"2022-01-06","objectID":"/java_learning4/:1:1","tags":["Java","算法"],"title":"Java 学习4-异常","uri":"/java_learning4/"},{"categories":["Java学习"],"content":"4.2 运行时异常和非运行时异常 运行时异常RuntimeException（不受检异常unchecked）： RuntimeException类极其子类表示JVM在运行期间可能出现的错误。编译器不会检查此类异常，并且不要求处理异常，比如用空值对象的引用（NullPointerException）、数组下标越界（ArrayIndexOutBoundException）。此类异常属于不可查异常，一般是由程序逻辑错误引起的，在程序中可以选择捕获处理，也可以不处理 非运行时异常，（受检异常checked）： Exception中除RuntimeException极其子类之外的异常。编译器会检查此类异常，如果程序中出现此类异常，比如说IOException，必须对该异常进行处理，要么使用try-catch捕获，要么使用throws语句抛出，否则编译不通过。 ","date":"2022-01-06","objectID":"/java_learning4/:1:2","tags":["Java","算法"],"title":"Java 学习4-异常","uri":"/java_learning4/"},{"categories":["Java学习"],"content":"4.3 异常的处理 抛出异常：throw，throws throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。 throws运用于方法声明之上，用于表示当前方法不处理异常，而是提醒该方法的调用者来处理异常 捕获异常：try，catch，finally ","date":"2022-01-06","objectID":"/java_learning4/:1:3","tags":["Java","算法"],"title":"Java 学习4-异常","uri":"/java_learning4/"},{"categories":["Java学习"],"content":"4.4 实例 throw 的使用 package ExceptionDemo; public class TrowDemo { public static void main(String[] args) { int a = devide(4, 0); System.out.println(a); } public static int devide(int a, int b){ if(b==0){ throw new ArithmeticException(\"异常信息：除数不能为0\"); } return a/b; } } throws 的使用 package ExceptionDemo; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.InputStream; public class ThrowsDemo { public static void main(String[] args) throws FileNotFoundException{ try { //可能出现异常的代码段 readFile(); }catch (FileNotFoundException e){ // 异常处理 System.out.println(\"异常信息： 找不到指定路径\"); } System.out.println(\"后续处理\"); } public static void readFile() throws FileNotFoundException{ // InputStream is = new FileInputStream(\"/Users/swaggerwei/Desktop/look4Job/Java_language/notes/docks\"); InputStream is = new FileInputStream(\"/Users/swaggerwei/Desktop/notes/docks\"); } } 自定义异常类 package ExceptionDemo; /* * 自定义异常类 * 用户不存在异常 * */ public class UserNotExistException extends RuntimeException{ public UserNotExistException(){ super(); } } ","date":"2022-01-06","objectID":"/java_learning4/:1:4","tags":["Java","算法"],"title":"Java 学习4-异常","uri":"/java_learning4/"},{"categories":["Java学习"],"content":"3 容器 数据容器主要分为了两类：Collection 和 Map Collection: 存放独立元素的序列 Map：存放key-value型的元素对 ","date":"2022-01-06","objectID":"/java_learning3/:1:0","tags":["Java","算法"],"title":"Java 学习3-容器","uri":"/java_learning3/"},{"categories":["Java学习"],"content":"3.1 Collection 存放独立元素的序列 List： ArrayList LinkedList Vector Stack Set：HashSet LinkedHashSet TreeSet ","date":"2022-01-06","objectID":"/java_learning3/:1:1","tags":["Java","算法"],"title":"Java 学习3-容器","uri":"/java_learning3/"},{"categories":["Java学习"],"content":"3.2 Map：存放key-value型的元素对 HashMap： LinkedHashMap TreeMap： ConcurrentHashMap HashTable ","date":"2022-01-06","objectID":"/java_learning3/:1:2","tags":["Java","算法"],"title":"Java 学习3-容器","uri":"/java_learning3/"},{"categories":["Java学习"],"content":"3.3 Collection 和 Collections 的区别 Collection 是一个接口， Set和List等容器的父接口 Collections 是一个工具类，提供了一系列ff的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等 ","date":"2022-01-06","objectID":"/java_learning3/:1:3","tags":["Java","算法"],"title":"Java 学习3-容器","uri":"/java_learning3/"},{"categories":["Java学习"],"content":"3.4 List、Set、Map 的区别 ","date":"2022-01-06","objectID":"/java_learning3/:1:4","tags":["Java","算法"],"title":"Java 学习3-容器","uri":"/java_learning3/"},{"categories":["Java学习"],"content":"3.5 HashMap 和 HashTable的区别 存储：HashMap 允许 key 和 value 为 null，而 Hashtable 不允许。 线程安全：HashTable 是线程安全的(同一时间只允许一个线程作出改变)，而 HashMap 是非线程安全的（同一时间可能有多个线程对其进行操作）。 推荐使用：在 HashTable 的类注释可以看到，HashTable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。 ","date":"2022-01-06","objectID":"/java_learning3/:1:5","tags":["Java","算法"],"title":"Java 学习3-容器","uri":"/java_learning3/"},{"categories":["Java学习"],"content":"3.6 实例 package Java_ContainerDemo; import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set; import java.util.Collections; public class collectionDemo { public static void main(String[] args) { List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); list.add(1); list.add(2); list.add(5); list.add(3); list.add(4); list.add(6); System.out.println(list.toString()); Set\u003cInteger\u003e set = new HashSet\u003c\u003e(); set.add(1); set.add(2); System.out.println(set.toString()); // 测试Collections 工具箱 Collections.sort(list); System.out.println(list.toString()); List\u003cInteger\u003e list1 = Collections.emptyList(); System.out.println(list1.toString()); } } ","date":"2022-01-06","objectID":"/java_learning3/:1:6","tags":["Java","算法"],"title":"Java 学习3-容器","uri":"/java_learning3/"},{"categories":["Java学习"],"content":"1 继承（关键字extends） 父类中私有成员可以被继承，只是外界无法访问 父类中公共属性、方法可以被子类继承 支持单继承，多重继承（单链式继承），不支持多继承（一个类继承多个父类） 子类中的方法重写必须是父类中已有的方法 重写后再次调用父类的方法使用关键字super 例如 super.需要调用父类中的方法; super必须在子类构造器中第一句 重写与重载的区别 重写：方法名、参数跟父类方法一致，只是方法体内容不一样（运行时多态） 重载：方法名一致，形参返回值不一致（编译时多态） Java中，在创建类时，都会默认继承Object类 只要父类构造方法不发生重载（保留无参的） 子类无需改动 需要遵循先构造父类，在构造子类的顺序 ","date":"2022-01-05","objectID":"/java_learning2/:1:0","tags":["Java","算法"],"title":"Java 学习2-继承和接口","uri":"/java_learning2/"},{"categories":["Java学习"],"content":"2 接口 接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合 接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法 接口无法被实例化，但是可以被实现 ","date":"2022-01-05","objectID":"/java_learning2/:2:0","tags":["Java","算法"],"title":"Java 学习2-继承和接口","uri":"/java_learning2/"},{"categories":["Java学习"],"content":"2.1 接口与类的异同点 接口不能用于实例化对象 接口没有构造方法 接口中所有的方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法 接口不能包含成员变量，除了 static 和 final 变量 接口不是被类继承了，而是要被类实现 接口支持多继承 接口和类都可以有多个方法 文件名类似 ","date":"2022-01-05","objectID":"/java_learning2/:2:1","tags":["Java","算法"],"title":"Java 学习2-继承和接口","uri":"/java_learning2/"},{"categories":["Java学习"],"content":"2.2 实例 package objectOriented; //接口demo public interface Animal { static int height = 0; public void eat(); public void travel(); } package objectOriented; public class testAnimal_interface implements Animal{ public void eat(){ System.out.println(\"tiger eat\"); } public void travel(){ System.out.println(\"tiger travel\"); } public int numOfLegs(){ return 0; } public static void main(String[] args) { testAnimal_interface tiger = new testAnimal_interface(); tiger.eat(); tiger.travel(); System.out.println(tiger.numOfLegs()); } } ","date":"2022-01-05","objectID":"/java_learning2/:2:2","tags":["Java","算法"],"title":"Java 学习2-继承和接口","uri":"/java_learning2/"},{"categories":["Java学习"],"content":"四种内部类 成员内部类：定义在一个外部类内部，作为一个成员，称之为成员内部类，可以访问内部私有属性 静态内部类：定义在一个外部类内部，作为一个静态成员，访问外部类的静态属性，因为在进入JVM的时候静态成员变量先初始化，这个时候不同的成员变量还没有初始化 局部内部类：定义在程序执行的任何部分，和局部变量一样 匿名内部类：对象new出来之后不用赋值给一个变量，直接使用，多线程new Thread使用较多 ","date":"2022-01-05","objectID":"/java_learning2/:3:0","tags":["Java","算法"],"title":"Java 学习2-继承和接口","uri":"/java_learning2/"},{"categories":["刷题学习"],"content":"树 和 图 辨析 树的父节点和子节点之间是一条路单向可达 图的的节点之间存在多条路可达 ","date":"2021-11-24","objectID":"/lc_learning9/:1:0","tags":["算法"],"title":"刷题学习9-java 图 知识点graph","uri":"/lc_learning9/"},{"categories":["刷题学习"],"content":"基本概念 顶点 边 邻居节点：只有一条边连接的顶点 度（degree）：一个顶点有几条边，就有几度 ","date":"2021-11-24","objectID":"/lc_learning9/:2:0","tags":["算法"],"title":"刷题学习9-java 图 知识点graph","uri":"/lc_learning9/"},{"categories":["刷题学习"],"content":"图的区分 无向图：边没有方向 有向图 权重图 ","date":"2021-11-24","objectID":"/lc_learning9/:3:0","tags":["算法"],"title":"刷题学习9-java 图 知识点graph","uri":"/lc_learning9/"},{"categories":["刷题学习"],"content":"有向图的基本概念 入度：多少条边指向该顶点 出度：多少条边从这个顶点出发指向其他顶点 ","date":"2021-11-24","objectID":"/lc_learning9/:4:0","tags":["算法"],"title":"刷题学习9-java 图 知识点graph","uri":"/lc_learning9/"},{"categories":["刷题学习"],"content":"EG： 韩：入度为0；出度为2 李：入度为1；出度为1 bishi：入度为2；出度为0 饲：入度为1；出度为1 ","date":"2021-11-24","objectID":"/lc_learning9/:4:1","tags":["算法"],"title":"刷题学习9-java 图 知识点graph","uri":"/lc_learning9/"},{"categories":["刷题学习"],"content":"权重图的基本概念 边上有权重 EG：顶点为城市，边为城市之间的距离，最短路径问题 ","date":"2021-11-24","objectID":"/lc_learning9/:5:0","tags":["算法"],"title":"刷题学习9-java 图 知识点graph","uri":"/lc_learning9/"},{"categories":["刷题学习"],"content":"最短路径常用算法 贝尔曼-福特算法（Bellman Ford） 狄杰斯特拉算法（Dijkstra） DFS BFS ","date":"2021-11-24","objectID":"/lc_learning9/:6:0","tags":["算法"],"title":"刷题学习9-java 图 知识点graph","uri":"/lc_learning9/"},{"categories":["ROS 学习"],"content":"使用github安装 网址：http://www.uco.es/investiga/grupos/ava/node/26 git clone到本地之后，catkin make即可开始使用 ","date":"2021-11-20","objectID":"/aruco_learning/:1:0","tags":["ROS","抓取"],"title":"Aruco配合realsense 使用","uri":"/aruco_learning/"},{"categories":["ROS 学习"],"content":"使用apt安装 sudo apt-get install ros-kinetic-aruco-ros sudo apt-get install ros-kinetic-aruco-msgs sudo apt-get install ros-kinetic-aruco-detect sudo apt-get install ros-kinetic-aruco ","date":"2021-11-20","objectID":"/aruco_learning/:2:0","tags":["ROS","抓取"],"title":"Aruco配合realsense 使用","uri":"/aruco_learning/"},{"categories":["ROS 学习"],"content":"测试使用 roslaunch aruco_ros single.launch 如果没有报错，说明成功 ","date":"2021-11-20","objectID":"/aruco_learning/:3:0","tags":["ROS","抓取"],"title":"Aruco配合realsense 使用","uri":"/aruco_learning/"},{"categories":["ROS 学习"],"content":"网址生成二维码，及其相关信息 http://chev.me/arucogen/ 图片的风格类型 marker ID —–582 尺寸大小（注意这里的单位为mm）—-34mm ","date":"2021-11-20","objectID":"/aruco_learning/:4:0","tags":["ROS","抓取"],"title":"Aruco配合realsense 使用","uri":"/aruco_learning/"},{"categories":["ROS 学习"],"content":"修改launch文件夹中的single.launch文件 更改camera_info为realsense发布的相机内参话题 \u003cremap from=\"/camera_info\" to=\"/camera/color/camera_info\" /\u003e 更改image \u003cremap from=\"/image\" to=\"/camera/color/image_raw\" /\u003e 更改camera_frame \u003cparam name=\"camera_frame\" value=\"/camera_link\"/\u003e 更改Marker ID; marker size \u003carg name=\"markerId\" default=\"582\"/\u003e \u003carg name=\"markerSize\" default=\"0.034\"/\u003e \u003c!-- in m --\u003e ","date":"2021-11-20","objectID":"/aruco_learning/:5:0","tags":["ROS","抓取"],"title":"Aruco配合realsense 使用","uri":"/aruco_learning/"},{"categories":["ROS 学习"],"content":"开始测试 启动realsense节点 roslaunch realsense2_camera rs_camera.launch 启动single.launch 文件 roslaunch aruco_ros single.launch 使用image_view观察识别效果 rosrun image_view image_view image:=/aruco_single/result 查看位姿 rostopic echo /aruco_single/pose 参考：https://blog.csdn.net/qq_34935373/article/details/105098244 ","date":"2021-11-20","objectID":"/aruco_learning/:6:0","tags":["ROS","抓取"],"title":"Aruco配合realsense 使用","uri":"/aruco_learning/"},{"categories":["pointNetGPD"],"content":"资源相关 项目地址 源码地址 论文地址 ","date":"2021-11-18","objectID":"/pointnetgpd_reading/:1:0","tags":["抓取","pointNet"],"title":"1-PointNetGPD论文阅读","uri":"/pointnetgpd_reading/"},{"categories":["pointNetGPD"],"content":"输入输出 input： 点云数据 output： 抓取位姿（6D）(parallel-jaw)方式 ","date":"2021-11-18","objectID":"/pointnetgpd_reading/:2:0","tags":["抓取","pointNet"],"title":"1-PointNetGPD论文阅读","uri":"/pointnetgpd_reading/"},{"categories":["pointNetGPD"],"content":"contribution 网络轻量化 预测夹爪的6D位姿 贡献一个真实的点云抓取数据集 网络模型可以准确的分析出夹爪和抓取物体的几何信息，在点云数据很粗糙的情况下准确度也有保证 ","date":"2021-11-18","objectID":"/pointnetgpd_reading/:3:0","tags":["抓取","pointNet"],"title":"1-PointNetGPD论文阅读","uri":"/pointnetgpd_reading/"},{"categories":["pointNetGPD"],"content":"motivation 现如今的抓取预测方式都是依据RGB和Depth 结合的方式，很少考虑几何信息 PointNet 直接在点云做分割和分类的效果非常好 ","date":"2021-11-18","objectID":"/pointnetgpd_reading/:4:0","tags":["抓取","pointNet"],"title":"1-PointNetGPD论文阅读","uri":"/pointnetgpd_reading/"},{"categories":["pointNetGPD"],"content":"pipeline ","date":"2021-11-18","objectID":"/pointnetgpd_reading/:5:0","tags":["抓取","pointNet"],"title":"1-PointNetGPD论文阅读","uri":"/pointnetgpd_reading/"},{"categories":["pointNetGPD"],"content":"抓取实验评价指标 Meticulous grasp quality scores 包括如下两部分 force-closure GWS analysis ","date":"2021-11-18","objectID":"/pointnetgpd_reading/:6:0","tags":["抓取","pointNet"],"title":"1-PointNetGPD论文阅读","uri":"/pointnetgpd_reading/"},{"categories":["ROS 学习"],"content":"基本概念 urdf 文件， 定义机器人的结构 用于机器人的仿真、 可视化、 tf ROS 的中包含一个urdf包，用来解析urdf文件 ","date":"2021-11-01","objectID":"/ros_learning6/:1:0","tags":["ROS"],"title":"6-URDF","uri":"/ros_learning6/"},{"categories":["ROS 学习"],"content":"描述机器人零部件和零部件之间的关系 link 每个零部件都有自己的link（xyz三个轴） joint 描述两个零部件连接的关节 urdf文件中定义两个link 之间必有一个joint ","date":"2021-11-01","objectID":"/ros_learning6/:2:0","tags":["ROS"],"title":"6-URDF","uri":"/ros_learning6/"},{"categories":["ROS 学习"],"content":"urdf 文件的具体撰写 ","date":"2021-11-01","objectID":"/ros_learning6/:3:0","tags":["ROS"],"title":"6-URDF","uri":"/ros_learning6/"},{"categories":["ROS 学习"],"content":"tf in python 的相关数据类型 tuple list numpy array 四种方式通用 EG： ","date":"2021-11-01","objectID":"/ros_learning5/:1:0","tags":["ROS"],"title":"5-tf in python ","uri":"/ros_learning5/"},{"categories":["ROS 学习"],"content":"四元数、矩阵、欧拉角之间的转换 ","date":"2021-11-01","objectID":"/ros_learning5/:2:0","tags":["ROS"],"title":"5-tf in python ","uri":"/ros_learning5/"},{"categories":["ROS 学习"],"content":"tf.TransformListener 类 构造函数为无参数 tips：查看相对的tf，方法中注意时间要填写为time(0), 不能使用time(now)获取当前时间，因为获取当前的tf消息是空的，需要等待一下才有消息 ","date":"2021-11-01","objectID":"/ros_learning5/:3:0","tags":["ROS"],"title":"5-tf in python ","uri":"/ros_learning5/"},{"categories":["ROS 学习"],"content":"tf.transformBroadcaster 类 构造函数为无参数 ","date":"2021-11-01","objectID":"/ros_learning5/:4:0","tags":["ROS"],"title":"5-tf in python ","uri":"/ros_learning5/"},{"categories":["ROS 学习"],"content":"tf相关指令 根据当前的tf tree 绘制一个PDF图: 接收/tf 消息五秒，然后生成一个树图 rosrun tf view_frames 查看当前的tf tree： 动态显示 rosrun rqt_tf_tree rqt_tf_tree 查看两个frame 之间的变化关系 rosrun tf tf_echo [reference_frame] [target_frame] ","date":"2021-11-01","objectID":"/ros_learning5/:5:0","tags":["ROS"],"title":"5-tf in python ","uri":"/ros_learning5/"},{"categories":["ROS 学习"],"content":"TransFrom 坐标变换（位置+姿态） 坐标系数据的维护工具 ","date":"2021-11-01","objectID":"/ros_learning4/:1:0","tags":["ROS"],"title":"4-tf介绍","uri":"/ros_learning4/"},{"categories":["ROS 学习"],"content":"抓取场景下的坐标转换 涉及的坐标系：基坐标系、摄像头坐标系、机械臂末端坐标系 物体坐标相对于摄像头坐标系-》物体坐标相对于基坐标系 物体坐标相对于夹爪末端坐标系 ","date":"2021-11-01","objectID":"/ros_learning4/:2:0","tags":["ROS"],"title":"4-tf介绍","uri":"/ros_learning4/"},{"categories":["ROS 学习"],"content":"ROS中的tf 一个部件是一个link， 会发布自己的tf消息 与之相连的link， 会接收其tf消息完成连接转化工作（joint工作） ROS中tf表示的意思：标准 话题 工具 接口 ","date":"2021-11-01","objectID":"/ros_learning4/:3:0","tags":["ROS"],"title":"4-tf介绍","uri":"/ros_learning4/"},{"categories":["ROS 学习"],"content":"tf消息格式 ","date":"2021-11-01","objectID":"/ros_learning4/:4:0","tags":["ROS"],"title":"4-tf介绍","uri":"/ros_learning4/"},{"categories":["ROS 学习"],"content":"两个frame之间的tf变化 TransformedStamped.msg seq-序号 stamp-时间戳 frame_id-本frame的id child_frame_id-子frame的id 位置 旋转位姿 很多个节点向/tf 话题发送消息， 形成tf树 ","date":"2021-11-01","objectID":"/ros_learning4/:4:1","tags":["ROS"],"title":"4-tf介绍","uri":"/ros_learning4/"},{"categories":["ROS 学习"],"content":"Client Library 提供ROS编程的库 例如建立node，发布消息，调用服务 提供了如下几种client library ：roscpp、rospy、roslisp ","date":"2021-11-01","objectID":"/ros_learning3/:1:0","tags":["ROS"],"title":"3-roscpp介绍","uri":"/ros_learning3/"},{"categories":["ROS 学习"],"content":"rospy的组成 Node Topic Service Param Time ","date":"2021-11-01","objectID":"/ros_learning3/:2:0","tags":["ROS"],"title":"3-roscpp介绍","uri":"/ros_learning3/"},{"categories":["ROS 学习"],"content":"rospy-Node 相关 ","date":"2021-11-01","objectID":"/ros_learning3/:3:0","tags":["ROS"],"title":"3-roscpp介绍","uri":"/ros_learning3/"},{"categories":["ROS 学习"],"content":"rospy-topic 相关 wait_for_message: 只接收一次消息，不是一直处理消息 publisher-》init: 当中的queue_size, 设置为1， 为异步通信方式， None为同步通信方式 ","date":"2021-11-01","objectID":"/ros_learning3/:4:0","tags":["ROS"],"title":"3-roscpp介绍","uri":"/ros_learning3/"},{"categories":["ROS 学习"],"content":"topic_demo ","date":"2021-11-01","objectID":"/ros_learning3/:5:0","tags":["ROS"],"title":"3-roscpp介绍","uri":"/ros_learning3/"},{"categories":["ROS 学习"],"content":"功能描述： 两个node，一个发布模拟的GPS消息（格式为自定义，包括坐标和工作状态） 另一个node接收并处理该信息（计算到原点的距离） ","date":"2021-11-01","objectID":"/ros_learning3/:5:1","tags":["ROS"],"title":"3-roscpp介绍","uri":"/ros_learning3/"},{"categories":["ROS 学习"],"content":"步骤 建立一个package cd ~/catkin_ws/src catkin_create_pkg topic_demo roscpp rospy std_msg 定义自己的msg文件 cd topic_demo/ mkdir msg cd msg gedit gps.msg 文件内容如下 编写talker.py 编写listener.py 修改CmakeList.txt; package.xml文件 最后执行catkin_make，编译完成之后会在如下路径下生成gps的头文件 使用rosrun运行talker.py和listener.py文件 ","date":"2021-11-01","objectID":"/ros_learning3/:5:2","tags":["ROS"],"title":"3-roscpp介绍","uri":"/ros_learning3/"},{"categories":["ROS 学习"],"content":"ROS常用工具 仿真：Gazebo 调试、可视化：Rviz、rqt 命令行工具：rostopic、roslaunch、rosbag 专用工具：Moveit ","date":"2021-10-28","objectID":"/ros_learning2/:1:0","tags":["ROS"],"title":"2-ROS常用工具","uri":"/ros_learning2/"},{"categories":["ROS 学习"],"content":"Gazebo 机器人仿真工具 ODE、Bullet 等物理引擎 动力学、导航、感知等任务的模拟 ","date":"2021-10-28","objectID":"/ros_learning2/:2:0","tags":["ROS"],"title":"2-ROS常用工具","uri":"/ros_learning2/"},{"categories":["ROS 学习"],"content":"Gazebo 操作 鼠标左键平移， 中键旋转 左侧world：各类物理模型及其属性 左侧insert：可以插入各种模型 ","date":"2021-10-28","objectID":"/ros_learning2/:3:0","tags":["ROS"],"title":"2-ROS常用工具","uri":"/ros_learning2/"},{"categories":["ROS 学习"],"content":"RViz 方便调试和监控的工具 ADD 添加监视器（RbotModel、Laserscan、PointCloud、Camera等） 选中监视器中的topic，进行消息的接收，才能进行可视化 ","date":"2021-10-28","objectID":"/ros_learning2/:4:0","tags":["ROS"],"title":"2-ROS常用工具","uri":"/ros_learning2/"},{"categories":["ROS 学习"],"content":"rqt可视化命令行工具 rqt_graph：显示通信架构（节点和话题的发布状态） rqt_plot：绘制曲线 rqt_console：查看日志 ","date":"2021-10-28","objectID":"/ros_learning2/:5:0","tags":["ROS"],"title":"2-ROS常用工具","uri":"/ros_learning2/"},{"categories":["ROS 学习"],"content":"rosbag ROS命令行工具 记录和回放数据流 回放会将记录的消息重新发布，单独使用回放之前需要roscoe启动master节点 ","date":"2021-10-28","objectID":"/ros_learning2/:6:0","tags":["ROS"],"title":"2-ROS常用工具","uri":"/ros_learning2/"},{"categories":["ROS 学习"],"content":"通信方式 topic service parameter server actionlib ","date":"2021-10-28","objectID":"/ros_learning1/:1:0","tags":["ROS"],"title":"1-ROS通信方式","uri":"/ros_learning1/"},{"categories":["ROS 学习"],"content":"topic 通信方式 异步通信方式 Node间通过publish-subscribe的方式进行通信 topic 发布节点只管发布， 接收节点只管接收 特点 异步通信方式 对于同一个topic可以有多个发送者（例如tf，和rosout），也可以有多个接收者 ","date":"2021-10-28","objectID":"/ros_learning1/:2:0","tags":["ROS"],"title":"1-ROS通信方式","uri":"/ros_learning1/"},{"categories":["ROS 学习"],"content":"Message topic 内容的数据类型—》类 定义在.msg文件当中 包括的类型 ","date":"2021-10-28","objectID":"/ros_learning1/:3:0","tags":["ROS"],"title":"1-ROS通信方式","uri":"/ros_learning1/"},{"categories":["ROS 学习"],"content":"topic 相关命令 列出所有的topic rostopic list 显示某个topic的属性信息 rostopic info /topic_name topic内容 rostopic echo /topic_name 向某个topic发布内容 rostopic pub /topic_name ... 列出所有msg rosmsg list 显示某个msg 的内容 rosmsg show /msg_name ","date":"2021-10-28","objectID":"/ros_learning1/:4:0","tags":["ROS"],"title":"1-ROS通信方式","uri":"/ros_learning1/"},{"categories":["刷题学习"],"content":"基本定义 堆就是一种二叉树结构—完全二叉树 完全二叉树： 1 每个父节点，最多只有两个孩子 2 从上到下，从左到右依次填满 ","date":"2021-10-18","objectID":"/lc_learning8/:1:0","tags":["算法"],"title":"刷题学习8-java 堆 知识点Heap","uri":"/lc_learning8/"},{"categories":["刷题学习"],"content":"堆需要满足的条件： 是一个完全二叉树 每个节点都大于等于孩子节点（最大堆）或者每个每个节点都小于等于孩子节点（最小堆） ","date":"2021-10-18","objectID":"/lc_learning8/:2:0","tags":["算法"],"title":"刷题学习8-java 堆 知识点Heap","uri":"/lc_learning8/"},{"categories":["刷题学习"],"content":"最大堆和最小堆的辨析 根节点：堆顶元素 ","date":"2021-10-18","objectID":"/lc_learning8/:3:0","tags":["算法"],"title":"刷题学习8-java 堆 知识点Heap","uri":"/lc_learning8/"},{"categories":["刷题学习"],"content":"堆常见操作的时间复杂度 访问 Access X 搜索 Search O(1) 堆顶元素 添加 Insert O(logN) 为了满足最大堆或者最小堆的定义，需要进行父节点互换 删除 Delete O(logN) 删除堆顶元素 ","date":"2021-10-18","objectID":"/lc_learning8/:4:0","tags":["算法"],"title":"刷题学习8-java 堆 知识点Heap","uri":"/lc_learning8/"},{"categories":["刷题学习"],"content":"堆化操作的时间复杂度 堆化操作的时间复杂度是O(N)的原理 堆化：将一组无序的数加入到堆里去 堆化：将一组无序的数转化为完全二叉树，然后将完全二叉树转化为最大堆或者最小堆的操作 ","date":"2021-10-18","objectID":"/lc_learning8/:5:0","tags":["算法"],"title":"刷题学习8-java 堆 知识点Heap","uri":"/lc_learning8/"},{"categories":["刷题学习"],"content":"Eg： 有一组数：[10, 9, 7, 12, 16, 8, 5] 构建完全二叉树，结构是唯一的，只需要将数组从头到尾遍历一遍 O(N) 转化为 最小堆｜最大堆 O(N) 整体的时间复杂度为 O(N) ","date":"2021-10-18","objectID":"/lc_learning8/:5:1","tags":["算法"],"title":"刷题学习8-java 堆 知识点Heap","uri":"/lc_learning8/"},{"categories":["刷题学习"],"content":"堆的常见操作 创建堆（最大堆｜最小堆） PriorityQueue\u003cInteger\u003e minHeap = new PriorityQueue\u003c\u003e(); PriorityQueue\u003cInteger\u003e maxHeap = new PriorityQueue\u003c\u003e(Collections.reverseOrder()); 添加元素 minHeap.add(10); minHeap.add(8); minHeap.add(9); minHeap.add(11); minHeap.add(2); maxHeap.add(10); maxHeap.add(8); maxHeap.add(9); maxHeap.add(11); maxHeap.add(2); 获取堆顶元素 System.out.println(minHeap.peek()); System.out.println(maxHeap.peek()); 读取堆顶元素并出堆 minHeap.poll(); System.out.println(minHeap.toString()); maxHeap.poll(); System.out.println(maxHeap.toString()); 堆的长度 System.out.println(minHeap.size()); System.out.println(maxHeap.size()); 堆的遍历 while (!minHeap.isEmpty()){ minHeap.poll(); System.out.println(minHeap.toString()); } while (!maxHeap.isEmpty()){ maxHeap.poll(); System.out.println(maxHeap.toString()); } ","date":"2021-10-18","objectID":"/lc_learning8/:6:0","tags":["算法"],"title":"刷题学习8-java 堆 知识点Heap","uri":"/lc_learning8/"},{"categories":["刷题学习"],"content":"leetcode练习题 215 数组中第k个最大元素 kth largest element in a array 692 前k个高频单词 top k frequent words ","date":"2021-10-18","objectID":"/lc_learning8/:7:0","tags":["算法"],"title":"刷题学习8-java 堆 知识点Heap","uri":"/lc_learning8/"},{"categories":["刷题学习"],"content":"树的基本概念 描述的是节点之间的父子关系 tips： 成环的结构不可能成为树， 因为无法确定父子关系 ","date":"2021-10-16","objectID":"/lc_learning7/:1:0","tags":["算法"],"title":"刷题学习7-java 树知识点Tree","uri":"/lc_learning7/"},{"categories":["刷题学习"],"content":"重要的名词 节点 根节点（开始的节点，没有父节点，具有唯一性） 叶子节点（没有孩子的节点） ","date":"2021-10-16","objectID":"/lc_learning7/:2:0","tags":["算法"],"title":"刷题学习7-java 树知识点Tree","uri":"/lc_learning7/"},{"categories":["刷题学习"],"content":"高度、深度、层 概念辨析 高度：从叶子向根看，从0开始计数 深度：从根向叶子看，从0开始计数 层： 从根向叶子看，从1开始计数 ","date":"2021-10-16","objectID":"/lc_learning7/:3:0","tags":["算法"],"title":"刷题学习7-java 树知识点Tree","uri":"/lc_learning7/"},{"categories":["刷题学习"],"content":"二叉树 普通二叉树：每个节点最多两个孩子 满二叉树：除了叶子节点，每个节点都有左右两个孩子，且所有的叶子节点都在同一层 完全二叉树：从树的根节点，从上到下，从左到右，依次填满节点形成二叉树 tips：如果一个二叉树是满二叉树，那么一定是完全二叉树，反过来不一定 ","date":"2021-10-16","objectID":"/lc_learning7/:4:0","tags":["算法"],"title":"刷题学习7-java 树知识点Tree","uri":"/lc_learning7/"},{"categories":["刷题学习"],"content":"遍历 前序遍历： 根节点、左子树、右子树 中序遍历： 左子树、根节点、右子树 后序遍历： 左子树、右子树，根节点 EG: 前序遍历：A B D E C F G 中序遍历：D B E A F C G 后序遍历：D E B F G C A ","date":"2021-10-16","objectID":"/lc_learning7/:5:0","tags":["算法"],"title":"刷题学习7-java 树知识点Tree","uri":"/lc_learning7/"},{"categories":["刷题学习"],"content":"leetcode 练习题 144 Binary Tree Preorder Traversal 前序遍历 94 Binary Tree Inorder Traversal 中序遍历 145 Binary Tree Postorder Traversal 后序遍历 ","date":"2021-10-16","objectID":"/lc_learning7/:6:0","tags":["算法"],"title":"刷题学习7-java 树知识点Tree","uri":"/lc_learning7/"},{"categories":["kinova"],"content":"我的环境 ubuntu 16.04 64bits ROS Kinetic ","date":"2021-10-14","objectID":"/kinova_ros/:1:0","tags":["ROS","kinova"],"title":"4-Kinova_ros 配置文档","uri":"/kinova_ros/"},{"categories":["kinova"],"content":"Kinova SDK 下载 进入kinova官网 kinovarobotics.com 找到右上角resource， 根据自己kinova机械臂的名称找到对应的资源库，我的是Gen2 选择对应自由度的机械臂，然后找到SDK下载 ","date":"2021-10-14","objectID":"/kinova_ros/:2:0","tags":["ROS","kinova"],"title":"4-Kinova_ros 配置文档","uri":"/kinova_ros/"},{"categories":["kinova"],"content":"Kinova SDK 安装 解压SDK, 切换到目录中 打开终端 cd Ubuntu/16_04/64\\ bits/ 使用.sh文件安装 sudo bash installSDK64.sh 一直下一步即可，　一般是默认安装在opt目录下 ","date":"2021-10-14","objectID":"/kinova_ros/:3:0","tags":["ROS","kinova"],"title":"4-Kinova_ros 配置文档","uri":"/kinova_ros/"},{"categories":["kinova"],"content":"SDK DevelopmentCenter GUI 简单使用 切换到安装目录下 cd /opt/JACO-SDK/GUI/ 运行GUI文件 sudo ./DevelopmentCenter.sh 右上角检测到序列号，　且使用Virtual joystick可以使用说明成功 ","date":"2021-10-14","objectID":"/kinova_ros/:4:0","tags":["ROS","kinova"],"title":"4-Kinova_ros 配置文档","uri":"/kinova_ros/"},{"categories":["kinova"],"content":"Kinova-ros 安装 创建工作空间 mkdir \"~/catkin_ws/src/\" 切换到工作空间 cd ~/catkin_ws/src/ 下载 git clone https://github.com/Kinovarobotics/kinova-ros.git kinova-ros 可以导入到gitee 再下载 编译 cd ~/catkin_ws/ catkin_make 更改bashrc文件 source ~/catkin_ws/devel/setup.bash 此句话加入到bashrc中 ","date":"2021-10-14","objectID":"/kinova_ros/:5:0","tags":["ROS","kinova"],"title":"4-Kinova_ros 配置文档","uri":"/kinova_ros/"},{"categories":["kinova"],"content":"机器人唤醒 TIPS： 注意ROS节点和Development Center不能一起打开 source source devel/setup.bash bringup机械臂 roslaunch kinova_bringup kinova_robot.launch kinova_robotType:=j2n7s300 ","date":"2021-10-14","objectID":"/kinova_jaco2_7dof/:1:0","tags":["ROS","kinova"],"title":"3-kinova jaco2 7dof 机械臂基础控制","uri":"/kinova_jaco2_7dof/"},{"categories":["kinova"],"content":"cartesian 控制模式 重新起一个终端 cd ~/catkin_ws source devel/setup.bash 运行pose_action_client.py 文件 tips： pose参数解释，机器人方向看手 a.非相对（指定6D位置）移动， 不带-r参数 （小）左（大）右 （小）高（大）低 （大）前（小）后 rosrun kinova_demo pose_action_client.py -v j2n7s300 mdeg -- -0.193846275806 -0.265829235315 0.505497992039 94.2 -43.2 -167.1 rosrun kinova_demo pose_action_client.py -v j2n7s300 mdeg -- -0.193846275806 -0.265829235315 0.705497992039 94.2 -43.2 -167.1 rosrun kinova_demo pose_action_client.py -v j2n7s300 mdeg -- -0.193846275806 -0.465829235315 0.505497992039 94.2 -43.2 -167.1 rosrun kinova_demo pose_action_client.py -v j2n7s300 mdeg -- -0.393846275806 -0.265829235315 0.505497992039 94.2 -43.2 -167.1 rosrun kinova_demo pose_action_client.py -v j2n7s300 mdeg -- -0.193846275806 -0.265829235315 0.705497992039 94.2 -43.2 -167.1 b.相对（在当前6D位置基础上）移动，带-r参数 rosrun kinova_demo pose_action_client.py -v -r j2n7s300 mdeg -- 0.01 0 0 0 10 10 ","date":"2021-10-14","objectID":"/kinova_jaco2_7dof/:2:0","tags":["ROS","kinova"],"title":"3-kinova jaco2 7dof 机械臂基础控制","uri":"/kinova_jaco2_7dof/"},{"categories":["kinova"],"content":"手指控制 参数 robotType： j2n7s300 手指移动模式： percent 手指打开程度： 100 100 100（完全闭合） ； 0 0 0（完全打开） 控制命令 rosrun kinova_demo fingers_action_client.py j2n7s300 percent -- 100 100 100 rosrun kinova_demo fingers_action_client.py j2n7s300 percent -- 0 0 0 ","date":"2021-10-14","objectID":"/kinova_jaco2_7dof/:3:0","tags":["ROS","kinova"],"title":"3-kinova jaco2 7dof 机械臂基础控制","uri":"/kinova_jaco2_7dof/"},{"categories":["刷题学习"],"content":"特点 无序 不重复 注重自己独一无二的特性 ","date":"2021-10-13","objectID":"/lc_learning6/:1:0","tags":["算法"],"title":"刷题学习6-java集合Set学习","uri":"/lc_learning6/"},{"categories":["刷题学习"],"content":"主要作用 检查某一个元素是否存在 有无重复元素 ","date":"2021-10-13","objectID":"/lc_learning6/:2:0","tags":["算法"],"title":"刷题学习6-java集合Set学习","uri":"/lc_learning6/"},{"categories":["刷题学习"],"content":"Set的种类 HashSet 主要使用 LinkListSet TreeSet ","date":"2021-10-13","objectID":"/lc_learning6/:3:0","tags":["算法"],"title":"刷题学习6-java集合Set学习","uri":"/lc_learning6/"},{"categories":["刷题学习"],"content":"将一个元素加入到HashSet过程原理 取得元素 通过哈希函数得到哈希值 通过哈希值在哈希表中寻找，如果表中没有此元素，就直接存入到哈希表中 如果有元素，然后进行对比 如果已有元素和当前元素相等，则不做操作 如果不相等，则发生哈希冲突（使用链表方法解决） ","date":"2021-10-13","objectID":"/lc_learning6/:4:0","tags":["算法"],"title":"刷题学习6-java集合Set学习","uri":"/lc_learning6/"},{"categories":["刷题学习"],"content":"哈希集合的操作的时间复杂度 访问：不存在 搜索：无哈希冲突O(1) ，有哈希冲突O(k) —k为冲突元素的个数 插入：无哈希冲突O(1) ，有哈希冲突O(k) —k为冲突元素的个数 删除：无哈希冲突O(1) ，有哈希冲突O(k) —k为冲突元素的个数 ","date":"2021-10-13","objectID":"/lc_learning6/:5:0","tags":["算法"],"title":"刷题学习6-java集合Set学习","uri":"/lc_learning6/"},{"categories":["刷题学习"],"content":"哈希集合的常用操作 创建集合 HashSet\u003cInteger\u003e set = new HashSet\u003c\u003e(); 添加元素 set.add(10); System.out.println(set.add(10)); // 检测到元素重复，添加不成功 add 会返回一个boolean值 set.add(3); set.add(5); set.add(2); set.add(2); System.out.println(set.toString()); 查询元素 System.out.println(set.contains(2)); 删除元素 set.remove(2); System.out.println(set.toString()); 长度 System.out.println(set.size()); ","date":"2021-10-13","objectID":"/lc_learning6/:6:0","tags":["算法"],"title":"刷题学习6-java集合Set学习","uri":"/lc_learning6/"},{"categories":["刷题学习"],"content":"leetcode 练习题 217 Contains Duplicate 存在重复元素 705 Design Hashset 设计哈希集合 ","date":"2021-10-13","objectID":"/lc_learning6/:7:0","tags":["算法"],"title":"刷题学习6-java集合Set学习","uri":"/lc_learning6/"},{"categories":["yoloV5"],"content":"标注方法 自己获取的数据集，人工进行标注（全人工） 自己获取的数据集，首先使用训练好的网络标注一遍，然后手动进行微调（半人工） 仿真数据集（GAN网络来生成自己的数据集– synthetic data） ","date":"2021-10-10","objectID":"/yolov5_owndatasettrain/:1:0","tags":["yoloV5","python","pytorch"],"title":"3-如何制作和训练自己的数据集（YoloV5）","uri":"/yolov5_owndatasettrain/"},{"categories":["yoloV5"],"content":"标注工具 CVAT（需要安装） makesense.ai（在线标注工具） ","date":"2021-10-10","objectID":"/yolov5_owndatasettrain/:2:0","tags":["yoloV5","python","pytorch"],"title":"3-如何制作和训练自己的数据集（YoloV5）","uri":"/yolov5_owndatasettrain/"},{"categories":["yoloV5"],"content":"makesense.ai 标注过程 输入图片 选择Object Detection 创建自己的分类 根据自己的分类开始进行标注（标注的时候也可以使用action中的load models进行半人工标注） 导出文件（action-》export annotation-》yolo format） ","date":"2021-10-10","objectID":"/yolov5_owndatasettrain/:3:0","tags":["yoloV5","python","pytorch"],"title":"3-如何制作和训练自己的数据集（YoloV5）","uri":"/yolov5_owndatasettrain/"},{"categories":["yoloV5"],"content":"文件组织过程 将images和labels分别放入对应的文件夹中 参照coco.yaml， 写自己数据集的配置 # train and val data as 1) directory: path/images/, 2) file: path/images.txt, or 3) list: [path1/images/, path2/images/]train:mydata/images/trainval:mydata/images/train# number of classesnc:3# class namesnames:['person','car','bike'] 修改train.py中的--data参数 parser.add_argument('--data', type=str, default='mydata/mydata.yaml', help='data.yaml path') 运行train.py开始训练 使用detect测试自己训练的模型 修改detect 中的权重文件为自己训练的模型（一般问train当中最新的那个exp） ","date":"2021-10-10","objectID":"/yolov5_owndatasettrain/:4:0","tags":["yoloV5","python","pytorch"],"title":"3-如何制作和训练自己的数据集（YoloV5）","uri":"/yolov5_owndatasettrain/"},{"categories":["yoloV5"],"content":"tips pycharm左侧工程目录文件个数太多了会占用大量的资源（需要检索） 可以右键文件夹，在此处选择exclude， 则可以节省资源 需要有路径的地方，只要路径正确， exclude的文件依然可以找到，知识在目录视图中找不到 ","date":"2021-10-10","objectID":"/yolov5_owndatasettrain/:5:0","tags":["yoloV5","python","pytorch"],"title":"3-如何制作和训练自己的数据集（YoloV5）","uri":"/yolov5_owndatasettrain/"},{"categories":["刷题学习"],"content":"基础定义 键值对：key：value 例如学号姓名： 1：张三 2：李四 3：王五 查找元素的方式不需要从头遍历到尾，直接通过键（key）来进行查找，时间复杂度低 ","date":"2021-10-08","objectID":"/lc_learning5/:1:0","tags":["算法"],"title":"刷题学习5-java 哈希表学习-散列表","uri":"/lc_learning5/"},{"categories":["刷题学习"],"content":"语言的使用 Java—HashMap python—-字典 ","date":"2021-10-08","objectID":"/lc_learning5/:2:0","tags":["算法"],"title":"刷题学习5-java 哈希表学习-散列表","uri":"/lc_learning5/"},{"categories":["刷题学习"],"content":"哈希查找对应元素的机制 ","date":"2021-10-08","objectID":"/lc_learning5/:3:0","tags":["算法"],"title":"刷题学习5-java 哈希表学习-散列表","uri":"/lc_learning5/"},{"categories":["刷题学习"],"content":"哈希碰撞 两个不同的key通过同一个哈希函数，得到相同的内存地址 ","date":"2021-10-08","objectID":"/lc_learning5/:4:0","tags":["算法"],"title":"刷题学习5-java 哈希表学习-散列表","uri":"/lc_learning5/"},{"categories":["刷题学习"],"content":"哈希碰撞解决方法 ","date":"2021-10-08","objectID":"/lc_learning5/:5:0","tags":["算法"],"title":"刷题学习5-java 哈希表学习-散列表","uri":"/lc_learning5/"},{"categories":["刷题学习"],"content":"拉链法 当数组上的某个节点发生Hash冲突时,就把这个节点作为头节点,将新插入的节点挂到这个节点上,形成一个连表,新来的节点通过尾插的形式逐个插入节点 jdk1.8 之后采用链表或者红黑树的方法进行解决 优点：处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短 优点：拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况 优点：在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可 ","date":"2021-10-08","objectID":"/lc_learning5/:5:1","tags":["算法"],"title":"刷题学习5-java 哈希表学习-散列表","uri":"/lc_learning5/"},{"categories":["刷题学习"],"content":"开放地址法 如果当前位置发生了Hash冲突,就在数据里找寻其他没有冲突的位置存放这个数据 ","date":"2021-10-08","objectID":"/lc_learning5/:5:2","tags":["算法"],"title":"刷题学习5-java 哈希表学习-散列表","uri":"/lc_learning5/"},{"categories":["刷题学习"],"content":"再散列法 我们可以再弄另外一个Hash函数，对落在同一个位置的关键字进行再次的Hash ","date":"2021-10-08","objectID":"/lc_learning5/:5:3","tags":["算法"],"title":"刷题学习5-java 哈希表学习-散列表","uri":"/lc_learning5/"},{"categories":["刷题学习"],"content":"各种操作的时间复杂度 访问 X 搜索（无哈希碰撞） O(1) 搜索（有哈希碰撞） O(K) 链表遍历时经过了k个元素 插入 O(1) 删除 O(1) ","date":"2021-10-08","objectID":"/lc_learning5/:6:0","tags":["算法"],"title":"刷题学习5-java 哈希表学习-散列表","uri":"/lc_learning5/"},{"categories":["刷题学习"],"content":"Java 哈希表的常用操作 创建哈希表 // 通过字符串数组创建哈希表 String[] hashTable = new String[4]; // 通过HashMap 库创建哈希表 HashMap\u003cInteger, String\u003e hashMap = new HashMap\u003c\u003e(); 添加 // 添加 hashTable[1] = \"张三\"; hashTable[2] = \"李四\"; hashTable[3] = \"王五\"; // 使用数组的方式将其输出 for(int i = 0; i\u003chashTable.length-1; i++){ System.out.println((i+1)+\"-\"+hashTable[i+1]); } hashMap.put(1, \"张三\"); hashMap.put(2, \"李四\"); hashMap.put(3, \"王五\"); System.out.println(hashMap.toString()); 删除 hashTable[1] = \"\"; for(int i = 0; i\u003chashTable.length-1; i++){ System.out.println((i+1)+\"-\"+hashTable[i+1]); } hashMap.remove(1); System.out.println(hashMap.toString()); 更新元素 hashTable[1] = \"赵四\"; for(int i = 0; i\u003chashTable.length-1; i++){ System.out.println((i+1)+\"-\"+hashTable[i+1]); } hashMap.put(1 , \"赵四\"); 获取元素 System.out.println(hashTable[2]); System.out.println(hashMap.get(2)); 检查key的值是否存在 System.out.println(hashMap.containsKey(3)); 哈希表的长度 System.out.println(hashTable.length);// 有一个内存位置为空，4 System.out.println(hashMap.size()); 哈希表是否还有元素 System.out.println(hashMap.isEmpty()); ","date":"2021-10-08","objectID":"/lc_learning5/:7:0","tags":["算法"],"title":"刷题学习5-java 哈希表学习-散列表","uri":"/lc_learning5/"},{"categories":["刷题学习"],"content":"leetcode 练习题 217 存在重复元素 Contains Duplicate 389 找不同 Find Difference 496 下一个最大元素 Next Great Element ","date":"2021-10-08","objectID":"/lc_learning5/:8:0","tags":["算法"],"title":"刷题学习5-java 哈希表学习-散列表","uri":"/lc_learning5/"},{"categories":["yoloV5"],"content":"parser 参数详解 --weights 初始化模型： 有yolov5m，yolov5s，yolov5x，yolov5l，如果为设置为空就是没有任何与训练模型 --config 训练配置文件：.yaml 文件，与预训练模型相对应。 --data 所使用的数据集的配置文件：.yaml 文件，训练自己的数据集是也需要编辑相应的yaml文件 --hyp 超参数配置文件： 学习率等 --epoch 训练轮数 --batch-size batchsize 大小 --img-size 图片大小 --rect padding之后会有灰色区域的冗余信息，此参数设置为真，可以去除冗余信息 --resume 从之前训练的节点开始训练（已经训练的网络在runs/train/exp文件夹下的pt文件） 发现从此pt权重文件开始继续训练 --nosave 是否只保留最后一个epoch的权重文件 --notest 是否只测试最后一个epoch --noautoanchor （目标检测算法中是否使用锚点、锚框）关闭autoanchor --evolve 进化超参数（寻找最优参数的一种方式） --bucket 没有必要 --cache-images 缓存图片以备更快的训练 --image-weights 上一轮中训练情况不好的图片，在下一轮中加一些相关的权重 --device 训练设备选择 选择cpu或者gpu --multi-scale 对图片的尺寸进行变化 --single-cls 训练的数据集是但类别还是多类别 --adam 优化方法使用adam 优化法 --sync-bn DDP参数 --local_rank DDP参数 --workers 最好设置成0，不然很容易出错 --poject 项目存储位置 --entity W\u0026B 训练可视化的库是否启用 --name 训练结果保存名字 --quad 开启之后在尺寸大于640的图像上识别效果更好，但是有可能会使在640尺寸的图片上效果更差 --Linear-lr 学习速率的变化，如果开启就使用线性的方式进行变化，不开启就使用余弦退火的方式变化 --label-smoothing 防止在分了算法中出现过拟合的情况发生 --save_log 每隔多少个epoch，在tensorboard 中打一个标签 ","date":"2021-10-02","objectID":"/yolov5_train/:1:0","tags":["yoloV5","python","pytorch"],"title":"2-YoloV5 train.py 如何使用","uri":"/yolov5_train/"},{"categories":["kinova"],"content":"安全使用 不要进行剪裁操作，尖锐物体可能会上伤到手臂 关闭的时候会泄力，注意提前用手拖着 关节移动的时候不要限位 ","date":"2021-09-28","objectID":"/kinova_gen2learning2/:1:0","tags":["ROS","kinova"],"title":"2-kinova-gen2 使用学习","uri":"/kinova_gen2learning2/"},{"categories":["kinova"],"content":"部件 手臂主体部件 背面接口部件 USB、网线接口：公kinova SDK 控制使用 switch：开关 8pin口：摇杆控制 4pin口：电源线 ","date":"2021-09-28","objectID":"/kinova_gen2learning2/:2:0","tags":["ROS","kinova"],"title":"2-kinova-gen2 使用学习","uri":"/kinova_gen2learning2/"},{"categories":["kinova"],"content":"控制机械臂 ","date":"2021-09-28","objectID":"/kinova_gen2learning2/:3:0","tags":["ROS","kinova"],"title":"2-kinova-gen2 使用学习","uri":"/kinova_gen2learning2/"},{"categories":["kinova"],"content":"手柄控制 两种控制模式：Cartesian velocity（默认）、Angular velocity 手柄结构： 手柄按键指示表： ","date":"2021-09-28","objectID":"/kinova_gen2learning2/:3:1","tags":["ROS","kinova"],"title":"2-kinova-gen2 使用学习","uri":"/kinova_gen2learning2/"},{"categories":["kinova"],"content":"ROS 控制 具体访问https://github.com/Kinovarobotics/kinova-ros 选择对应ros版本的branch，然后进行安装 ","date":"2021-09-28","objectID":"/kinova_gen2learning2/:3:2","tags":["ROS","kinova"],"title":"2-kinova-gen2 使用学习","uri":"/kinova_gen2learning2/"},{"categories":["kinova"],"content":"3 SDK 控制 C++ library ","date":"2021-09-28","objectID":"/kinova_gen2learning2/:3:3","tags":["ROS","kinova"],"title":"2-kinova-gen2 使用学习","uri":"/kinova_gen2learning2/"},{"categories":["yoloV5"],"content":"pycharm 文件目录展开折叠管理 打开已打开文件的目录 展开所有目录 折叠所有目录 ","date":"2021-09-25","objectID":"/yolov5_macair/:1:0","tags":["m1 mac","yoloV5","python","pytorch"],"title":"1-yoloV5 本地训练 - m1 Mac Air（仅仅是为了调通代码）","uri":"/yolov5_macair/"},{"categories":["yoloV5"],"content":"number of workers 设置 此项为dataloader的载入数据的线程数量 初始运行的时候最好设置成0，由于不同机器的性能不同，数目大了很容易出问题 ","date":"2021-09-25","objectID":"/yolov5_macair/:2:0","tags":["m1 mac","yoloV5","python","pytorch"],"title":"1-yoloV5 本地训练 - m1 Mac Air（仅仅是为了调通代码）","uri":"/yolov5_macair/"},{"categories":["yoloV5"],"content":"导入nnpack 错误，m1 Mac 硬件不支持 在运行detect.py文件时同样报错，应该没有影响 ","date":"2021-09-25","objectID":"/yolov5_macair/:3:0","tags":["m1 mac","yoloV5","python","pytorch"],"title":"1-yoloV5 本地训练 - m1 Mac Air（仅仅是为了调通代码）","uri":"/yolov5_macair/"},{"categories":["yoloV5"],"content":"缺失coco 数据集错误 本地缺失coco128数据集 但是联网之后无法在该网址下载coco128 所有复制链接手动下载 最后复制到指定文件夹 完成后问题解决 开始训练 ","date":"2021-09-25","objectID":"/yolov5_macair/:4:0","tags":["m1 mac","yoloV5","python","pytorch"],"title":"1-yoloV5 本地训练 - m1 Mac Air（仅仅是为了调通代码）","uri":"/yolov5_macair/"},{"categories":["刷题学习"],"content":"问号 ？冒号 ：条件语句 int i = 0; int x = i\u003e1 ? 0:1; 问号冒号将其分为代码分为三个部分A、B、C A？B：C 如果A为真则执行B，如果为假则执行C ","date":"2021-09-23","objectID":"/lc_learning4/:1:0","tags":["算法"],"title":"刷题学习4-java 零碎基础知识","uri":"/lc_learning4/"},{"categories":["刷题学习"],"content":"字符串charAt 函数 String 类型的变量使用 指定index，返回该位置上的字符，返回类型为char类型 ","date":"2021-09-23","objectID":"/lc_learning4/:2:0","tags":["算法"],"title":"刷题学习4-java 零碎基础知识","uri":"/lc_learning4/"},{"categories":["刷题学习"],"content":"String 和 StringBuilder 的使用 ","date":"2021-09-23","objectID":"/lc_learning4/:3:0","tags":["算法"],"title":"刷题学习4-java 零碎基础知识","uri":"/lc_learning4/"},{"categories":["刷题学习"],"content":"初始化 StringBuilder str = new StringBuilder(); ","date":"2021-09-23","objectID":"/lc_learning4/:3:1","tags":["算法"],"title":"刷题学习4-java 零碎基础知识","uri":"/lc_learning4/"},{"categories":["刷题学习"],"content":"增加元素 str.append(1); str.append('a'); str.append(1.2); System.out.println(str.toString()); ","date":"2021-09-23","objectID":"/lc_learning4/:3:2","tags":["算法"],"title":"刷题学习4-java 零碎基础知识","uri":"/lc_learning4/"},{"categories":["刷题学习"],"content":"指定位置增加 str.insert(2, 's'); System.out.println(str.toString()); ","date":"2021-09-23","objectID":"/lc_learning4/:3:3","tags":["算法"],"title":"刷题学习4-java 零碎基础知识","uri":"/lc_learning4/"},{"categories":["刷题学习"],"content":"返回指定位置子序列 System.out.println(str.subSequence(0, 3)); ","date":"2021-09-23","objectID":"/lc_learning4/:3:4","tags":["算法"],"title":"刷题学习4-java 零碎基础知识","uri":"/lc_learning4/"},{"categories":["刷题学习"],"content":"搜索元素 System.out.println(str.indexOf(\"as\")); ","date":"2021-09-23","objectID":"/lc_learning4/:3:5","tags":["算法"],"title":"刷题学习4-java 零碎基础知识","uri":"/lc_learning4/"},{"categories":["刷题学习"],"content":"是否为空 System.out.println(str.isEmpty()); ","date":"2021-09-23","objectID":"/lc_learning4/:3:6","tags":["算法"],"title":"刷题学习4-java 零碎基础知识","uri":"/lc_learning4/"},{"categories":["刷题学习"],"content":"leetcode 题目强化 剑指offer 2 字符串二进制加法 ","date":"2021-09-23","objectID":"/lc_learning4/:4:0","tags":["算法"],"title":"刷题学习4-java 零碎基础知识","uri":"/lc_learning4/"},{"categories":["Java学习"],"content":"class 文件结构 ListNode.java 链表节点类 linkListString.java 链表类 test_ll_string.java 测试文件 ","date":"2021-09-20","objectID":"/java_learning/:1:0","tags":["Java","算法"],"title":"Java 学习1-快速实现自定义字符链表","uri":"/java_learning/"},{"categories":["Java学习"],"content":"ListNode.java val 存放字符串 next 指向下一个节点 构造函数 package linkList_string; public class ListNode { char val; ListNode next; public ListNode(char val) { this.val = val; } } ","date":"2021-09-20","objectID":"/java_learning/:2:0","tags":["Java","算法"],"title":"Java 学习1-快速实现自定义字符链表","uri":"/java_learning/"},{"categories":["Java学习"],"content":"linkListString.java 链表类 头节点head 尾节点tail size 存放链表节点数目 构造函数 成员方法：尾部添加元素 package linkList_string; public class linkListString { ListNode head; ListNode tail; int size; public linkListString() { head = null; tail = null; size = 0; } public void add(char val) { ListNode node = new ListNode(val); if (head == null) { head = node; tail = node; } else { tail.next = node; tail = node; } size++; } } ","date":"2021-09-20","objectID":"/java_learning/:3:0","tags":["Java","算法"],"title":"Java 学习1-快速实现自定义字符链表","uri":"/java_learning/"},{"categories":["Java学习"],"content":"test_ll_string.java 测试文件 实例化linkListString对象 添加节点 package linkList_string; public class test_ll_string { public static void main(String[] args) { linkListString list = new linkListString(); list.add('a'); list.add('b'); list.add('c'); list.add('d'); list.add('e'); list.add('f'); list.add('g'); } } Debug 运行成功 ","date":"2021-09-20","objectID":"/java_learning/:4:0","tags":["Java","算法"],"title":"Java 学习1-快速实现自定义字符链表","uri":"/java_learning/"},{"categories":["刷题学习"],"content":"特点 先进后出，与队列这种数据结构相反，队列是先进先出。 实用例子： 浏览器后退功能 ","date":"2021-09-20","objectID":"/lc_learning3/:1:0","tags":["算法"],"title":"刷题学习3-java 栈学习","uri":"/lc_learning3/"},{"categories":["刷题学习"],"content":"操作的时间复杂度 访问栈顶元素 O(1) 搜索 O(N) 插入 O(1) 入栈 删除 O(1) 出栈 ","date":"2021-09-20","objectID":"/lc_learning3/:2:0","tags":["算法"],"title":"刷题学习3-java 栈学习","uri":"/lc_learning3/"},{"categories":["刷题学习"],"content":"Java栈的常用操作 ","date":"2021-09-20","objectID":"/lc_learning3/:3:0","tags":["算法"],"title":"刷题学习3-java 栈学习","uri":"/lc_learning3/"},{"categories":["刷题学习"],"content":"创建栈 Stack\u003cInteger\u003e stack = new Stack\u003c\u003e(); ","date":"2021-09-20","objectID":"/lc_learning3/:3:1","tags":["算法"],"title":"刷题学习3-java 栈学习","uri":"/lc_learning3/"},{"categories":["刷题学习"],"content":"添加元素 stack.push(1); stack.push(2); stack.push(3); System.out.println(stack.toString()); ","date":"2021-09-20","objectID":"/lc_learning3/:3:2","tags":["算法"],"title":"刷题学习3-java 栈学习","uri":"/lc_learning3/"},{"categories":["刷题学习"],"content":"查看栈顶元素 - 即将出栈的元素 int num = stack.peek(); ","date":"2021-09-20","objectID":"/lc_learning3/:3:3","tags":["算法"],"title":"刷题学习3-java 栈学习","uri":"/lc_learning3/"},{"categories":["刷题学习"],"content":"删除栈顶元素 - 即将出栈的元素 int temp = stack.pop(); System.out.println(temp); ","date":"2021-09-20","objectID":"/lc_learning3/:3:4","tags":["算法"],"title":"刷题学习3-java 栈学习","uri":"/lc_learning3/"},{"categories":["刷题学习"],"content":"返回栈的长度 System.out.println(stack.size()); ","date":"2021-09-20","objectID":"/lc_learning3/:3:5","tags":["算法"],"title":"刷题学习3-java 栈学习","uri":"/lc_learning3/"},{"categories":["刷题学习"],"content":"栈是否为空 System.out.println(\"is empty: \"+stack.isEmpty()); ","date":"2021-09-20","objectID":"/lc_learning3/:3:6","tags":["算法"],"title":"刷题学习3-java 栈学习","uri":"/lc_learning3/"},{"categories":["刷题学习"],"content":"遍历栈 while (!stack.isEmpty()){ System.out.println(stack.pop()); } ","date":"2021-09-20","objectID":"/lc_learning3/:3:7","tags":["算法"],"title":"刷题学习3-java 栈学习","uri":"/lc_learning3/"},{"categories":["刷题学习"],"content":"leetcode 练习题 20 valid Parentheses 有效的括号 496 Next Great Element 下一个最大的元素 ","date":"2021-09-20","objectID":"/lc_learning3/:4:0","tags":["算法"],"title":"刷题学习3-java 栈学习","uri":"/lc_learning3/"},{"categories":["Java学习"],"content":"平台区分 这里指不同的操作系统：macos windows linux ","date":"2021-09-19","objectID":"/java_learning1/:1:0","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"跨平台运行原理 java 语言要想在不同的平台运行， 只需要该平台上有翻译java语言的虚拟机即可 称为 JVM （Java Virtual Machine） ","date":"2021-09-19","objectID":"/java_learning1/:2:0","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"JRE 和 JDK ","date":"2021-09-19","objectID":"/java_learning1/:3:0","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"JRE（Java Runtime Environment） 是Java运行时的环境，包含JVM和运行时所需要的核心类库 运行一个已有的java程序只需要安装JRE即可 ","date":"2021-09-19","objectID":"/java_learning1/:3:1","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"JDK（Java Development Kit） Java程序开发的工具包， 包含JRE和开发人员使用的工具 其中的开发工具：编译工具（javac.exe), 运行工具（java.exe） ","date":"2021-09-19","objectID":"/java_learning1/:3:2","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"总结：JDK、JRE、JVM之间的关系 实际上运行java 只需要一个JDK就可以了 ","date":"2021-09-19","objectID":"/java_learning1/:4:0","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"本机JDK安装 ","date":"2021-09-19","objectID":"/java_learning1/:5:0","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"Java JDK 安装目录 ","date":"2021-09-19","objectID":"/java_learning1/:6:0","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"IDEA HelloWorld 案例操作步骤 ","date":"2021-09-19","objectID":"/java_learning1/:7:0","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"IDEA 的项目结构 项目(Project) \u003e 模块(Module) \u003e 包(Package) \u003e java文件 对应到这个项目当中 项目(Project)—-java_learning 模块(Module)—–idea_test 包(Package)——swagger_test java文件———HelloWorld.java ","date":"2021-09-19","objectID":"/java_learning1/:8:0","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"内容辅助键 ","date":"2021-09-19","objectID":"/java_learning1/:9:0","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"快速生成语句 快速生成main方法：psvm，回车 快速生成输出语句：sout，回车 ","date":"2021-09-19","objectID":"/java_learning1/:9:1","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"内容辅助键 Ctrl+alt+space—-内容提示，代码补全 ","date":"2021-09-19","objectID":"/java_learning1/:9:2","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"快捷键 ","date":"2021-09-19","objectID":"/java_learning1/:10:0","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"注释 command+/ ","date":"2021-09-19","objectID":"/java_learning1/:10:1","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"格式化 command+options+L ","date":"2021-09-19","objectID":"/java_learning1/:10:2","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["Java学习"],"content":"IDEA模块操作 新建模块 删除模块 导入模块 ","date":"2021-09-19","objectID":"/java_learning1/:11:0","tags":["Java","算法"],"title":"Java 学习-前期准备","uri":"/java_learning1/"},{"categories":["刷题学习"],"content":"队列的基本特征 先进先出 单端队列–只有一个口可以进，一个口可以出 双端队列–两个口都可以进， 两个口都可以出 ","date":"2021-09-17","objectID":"/lc_learning2/:1:0","tags":["算法"],"title":"刷题学习2-java 队列学习","uri":"/lc_learning2/"},{"categories":["刷题学习"],"content":"队列数据结构的特点 访问O(N) 需要从头到尾遍历一遍 搜索O(N) 需要从头到尾遍历一遍 插入O(1) 插入只能在队尾插入，不需要遍历，所以时间复杂度为O(1) 删除O(1) 删除只能在队头删除，不需要遍历，所以时间复杂度为O(1) tips 队列的底层实现是链表 ","date":"2021-09-17","objectID":"/lc_learning2/:2:0","tags":["算法"],"title":"刷题学习2-java 队列学习","uri":"/lc_learning2/"},{"categories":["刷题学习"],"content":"队列的常见操作 创建队列 Queue\u003cInteger\u003e queue = new LinkedList\u003c\u003e(); 添加元素 for (int i = 0; i\u003c 3 ; i++){ queue.add(i+1); } System.out.println(queue.toString()); 获取即将出队的元素 peek() int temp1 = queue.peek(); System.out.println(temp1); 删除即将出队的元素 remove()、pop()、poll() int temp2 = queue.poll(); System.out.println(temp2); System.out.println(queue.toString()); 判断队列是不是为空 System.out.println(queue.isEmpty());//O(1) 队列长度 System.out.println(queue.size());//O(1) 遍历队列（边删除边遍历队列的操作） while (!queue.isEmpty()){ int temp = queue.poll(); System.out.println(temp); }//O(N) ","date":"2021-09-17","objectID":"/lc_learning2/:3:0","tags":["算法"],"title":"刷题学习2-java 队列学习","uri":"/lc_learning2/"},{"categories":["刷题学习"],"content":"leetcode 队列基础练习题 ","date":"2021-09-17","objectID":"/lc_learning2/:4:0","tags":["算法"],"title":"刷题学习2-java 队列学习","uri":"/lc_learning2/"},{"categories":["刷题学习"],"content":"933 最近的请求次数 number of Recent calls 参数使用： 类的成员变量-队列queue、ping函数中变量-temp保存即将出队的元素 构造函数中初始化queue为一个队列 调用ping时首先最新的t入队 while开始条件：队列不为空 查找即将出列元素到存入temp，如果t-temp大于3000，则出列 如果小于，不出列，停止循环，返回队列长度为最终结果 ","date":"2021-09-17","objectID":"/lc_learning2/:4:1","tags":["算法"],"title":"刷题学习2-java 队列学习","uri":"/lc_learning2/"},{"categories":["刷题学习"],"content":"239 滑动窗口最大值 ","date":"2021-09-17","objectID":"/lc_learning2/:4:2","tags":["算法"],"title":"刷题学习2-java 队列学习","uri":"/lc_learning2/"},{"categories":["刷题学习"],"content":"链表与数组的区别 数组的存放为连续的内存空间， 链表不需要，任意碎片式的内存空间都可以形成链表。 ","date":"2021-09-16","objectID":"/lc_learninglistnode/:1:0","tags":["算法"],"title":"刷题学习1.5-java 链表 知识点ListNode","uri":"/lc_learninglistnode/"},{"categories":["刷题学习"],"content":"链表的分类 双端链表：既有next指向下一个数据也有previous指向前一个数据，可以双向遍历。 单端链表：只有next指向下一个数据，只能单向遍历。 ","date":"2021-09-16","objectID":"/lc_learninglistnode/:2:0","tags":["算法"],"title":"刷题学习1.5-java 链表 知识点ListNode","uri":"/lc_learninglistnode/"},{"categories":["刷题学习"],"content":"链表的基本操作 访问—-O(N) 需要遍历，从头找到尾 搜索—-O(N) 需要遍历，从头找到尾 插入—-O(1) 直接需要插入的位置断开指针，使上一个的指针指向新的元素的位置，新元素的下一个指向原本的下一个元素 删除—-O(1) 断开删除元素前一个元素的next指向删除元素的next即可 ","date":"2021-09-16","objectID":"/lc_learninglistnode/:3:0","tags":["算法"],"title":"刷题学习1.5-java 链表 知识点ListNode","uri":"/lc_learninglistnode/"},{"categories":["刷题学习"],"content":"tips 这里的插入删除操作的时间复杂度实际上说的插入或删除这一个操作的时间复杂度。 实际上整个操作的时间复杂度是O(N)，因为需要先查找到元素，遍历到指定位置，再进行插入。 ","date":"2021-09-16","objectID":"/lc_learninglistnode/:3:1","tags":["算法"],"title":"刷题学习1.5-java 链表 知识点ListNode","uri":"/lc_learninglistnode/"},{"categories":["刷题学习"],"content":"应用场景 写多读少的场景 ","date":"2021-09-16","objectID":"/lc_learninglistnode/:4:0","tags":["算法"],"title":"刷题学习1.5-java 链表 知识点ListNode","uri":"/lc_learninglistnode/"},{"categories":["刷题学习"],"content":"java 链表的常见操作 创建链表 LinkedList\u003cInteger\u003e list_1 = new LinkedList\u003c\u003e(); 添加元素 for (int i = 0; i\u003c3 ;i++){ list_1.add(i+1); } System.out.println(list_1.toString()); list_1.add(2,99); System.out.println(list_1.toString()); 访问元素 System.out.println(list_1.get(2)); 查找元素 System.out.println(list_1.indexOf(99)); System.out.println(list_1.indexOf(88)); 删除元素 list_1.remove(2); System.out.println(list_1.toString()); 链表长度 System.out.println(list_1.size()); 更新元素 list_1.set(2, 88); System.out.println(list_1.toString()); ","date":"2021-09-16","objectID":"/lc_learninglistnode/:5:0","tags":["算法"],"title":"刷题学习1.5-java 链表 知识点ListNode","uri":"/lc_learninglistnode/"},{"categories":["刷题学习"],"content":"链表基础leetcode题目 ","date":"2021-09-16","objectID":"/lc_learninglistnode/:6:0","tags":["算法"],"title":"刷题学习1.5-java 链表 知识点ListNode","uri":"/lc_learninglistnode/"},{"categories":["刷题学习"],"content":"1 leetcode 203 删除指定元素 参数设置：head（移动节点）， prev（head的前一个），dummy（保存头节点，最后返回结果） 1 遍历整个链表，入口的条件是链表的头节点不为空（这样最后一个节点也可以遍历到） 2 如果碰到指定值，prev 指向head的下一个节点head移动一步 3 如果没有碰到指定值，prev指向head，head后移一步 4 最后返回头节点（需要有dummy存储头节点）， 最后返回 ","date":"2021-09-16","objectID":"/lc_learninglistnode/:6:1","tags":["算法"],"title":"刷题学习1.5-java 链表 知识点ListNode","uri":"/lc_learninglistnode/"},{"categories":["刷题学习"],"content":"2 leetcode 206 反转链表 参数设置：head（移动节点）， hNext（head的后一个），dummy（保存头节点，最后返回结果），dNext（dummy的后一个节点） dNext = dummy.next; hNext = head.next; dummy.next = hNext; head.next = hNext.next; hNext.next = dNext; ","date":"2021-09-16","objectID":"/lc_learninglistnode/:6:2","tags":["算法"],"title":"刷题学习1.5-java 链表 知识点ListNode","uri":"/lc_learninglistnode/"},{"categories":["kinova"],"content":"注：此方法适用于系统不能通过自检，并自动启动的情况 ","date":"2021-09-14","objectID":"/kinova_launch1/:0:1","tags":["ROS","kinova"],"title":"1-Kinova MOVO 手动启动操作","uri":"/kinova_launch1/"},{"categories":["kinova"],"content":"手动启动bash roslaunch movo_bringup movo_system.launch ","date":"2021-09-14","objectID":"/kinova_launch1/:1:0","tags":["ROS","kinova"],"title":"1-Kinova MOVO 手动启动操作","uri":"/kinova_launch1/"},{"categories":["kinova"],"content":"运行tractor_node脚本，解决MOVO底盘问题 ./tractor_node ","date":"2021-09-14","objectID":"/kinova_launch1/:2:0","tags":["ROS","kinova"],"title":"1-Kinova MOVO 手动启动操作","uri":"/kinova_launch1/"},{"categories":["kinova"],"content":"直连MOVO进行joystick手柄操作 cd /home/movo/movo_ws roslaunch movo_remote_teleop movo_remote_teleop.launch ","date":"2021-09-14","objectID":"/kinova_launch1/:3:0","tags":["ROS","kinova"],"title":"1-Kinova MOVO 手动启动操作","uri":"/kinova_launch1/"},{"categories":["kinova"],"content":"手柄操作方式 操作方式图解，所有的操作除了手指操作，其他的都需要DeadMan按键激活操作 ","date":"2021-09-14","objectID":"/kinova_launch1/:4:0","tags":["ROS","kinova"],"title":"1-Kinova MOVO 手动启动操作","uri":"/kinova_launch1/"},{"categories":["kinova"],"content":"rviz 操作 进入rviz rviz 点击motion planning 中planning Query栏中状态更新，选中状态之后点击update Commands栏中先点击plan，再update ","date":"2021-09-14","objectID":"/kinova_launch1/:5:0","tags":["ROS","kinova"],"title":"1-Kinova MOVO 手动启动操作","uri":"/kinova_launch1/"},{"categories":["刷题学习"],"content":"时间复杂度 时间复杂度即为代码的执行次数量级 算法的执行时间与输入之间的关系 ","date":"2021-09-08","objectID":"/lc_learning/:1:0","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"O(1) 常量数量级的时间复杂度, 没有for循环和while循环 ","date":"2021-09-08","objectID":"/lc_learning/:1:1","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"O(N) 常量不看，其中total=0，return total为常量执行次数 只有一层循环，循环的执行次数为N ","date":"2021-09-08","objectID":"/lc_learning/:1:2","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"O(logN) 常量不看，其中i=1，return i 为常量执行次数 i=i*2的执行次数为log2(N)，舍去2，则最后结果为O(logN) ","date":"2021-09-08","objectID":"/lc_learning/:1:3","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"O(M+N) 同理常量次数不看 两个O(N)，一个执行M次，一个执行N次 组合之后变成O(M+N)， 实际上等同于O(N) ","date":"2021-09-08","objectID":"/lc_learning/:1:4","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"O(NlogN) 同理常量次数不看 N次执行次数的循环内嵌套了一个logN次执行次数的循环 总次数为二者相乘即为O(NlogN) ","date":"2021-09-08","objectID":"/lc_learning/:1:5","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"O(N2) N次执行次数的循环内嵌套了一个N次执行次数的循环 总次数为二者相乘即为O(N2) ","date":"2021-09-08","objectID":"/lc_learning/:1:6","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"时间复杂度的判断方式 首先看有没有循环，没有则为常量次数O(1) 如果有，首先判断每一次循环的执行次数 循环之间的嵌套使用相乘的方式，得出最终的时间复杂度 ","date":"2021-09-08","objectID":"/lc_learning/:1:7","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"各个时间复杂度之间的比较 O(1) \u003c O(logN) \u003c O(N) \u003c O(NlogN) \u003c O(N2) \u003c O(2N) \u003c O(N!) 二分查找：O(logN) 堆排序：O(NlogN) 冒泡排序：O(N2) 快速排序：O(N2) 选择排序：O(N2) 二叉树排序：O(N2) 插入排序：O(N2) ","date":"2021-09-08","objectID":"/lc_learning/:1:8","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"空间复杂度 算法的存储空间和算法的关系 占空间的都是声明出来的变量 ","date":"2021-09-08","objectID":"/lc_learning/:2:0","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"O(1) 存储的变量为常数数量级 total在初始化之后虽然在循环当中被重复赋值，但是始终只占用total的空间 所以存储的变量为常数数量级 ","date":"2021-09-08","objectID":"/lc_learning/:2:1","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"O(N) 存储的数量级为N，循环的次数 数组的内的数字在不断增多，不断开辟新的内存空间 ","date":"2021-09-08","objectID":"/lc_learning/:2:2","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"tip1 arrary = [] for num in nums: array.append(num) return arrary 空间占用分为堆空间和栈空间 在for循环中条件部分申明的变量 num 开辟的空间为栈空间 使用完毕就会释放 而其他变量使用的是堆空间，程序完成之后才会释放 ","date":"2021-09-08","objectID":"/lc_learning/:3:0","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["刷题学习"],"content":"tip2 递归的函数内本身的空间复杂度如果为O(1)， 则调用递归的空间复杂度为O(N) 递归的函数内本身的空间复杂度如果为O(N)， 则调用递归的空间复杂度为O(N2) ","date":"2021-09-08","objectID":"/lc_learning/:4:0","tags":["算法"],"title":"刷题学习1-时间和空间复杂度","uri":"/lc_learning/"},{"categories":["Latex"],"content":"算法加入 在tex 文件开头引用以下包： algorithm、algorithmics、algpseudocode、amsmath \\usepackage{algorithm} \\usepackage{algorithmicx} \\usepackage{algpseudocode} \\usepackage{amsmath} f 如果算法中包含输入输出模块，还应加入如下代码： \\renewcommand{\\algorithmicrequire}{\\textbf{Input:}} % Use Input in the format of Algorithm \\renewcommand{\\algorithmicensure}{\\textbf{Output:}} % Use Output in the format of Algorithm 算法主体 \\begin{algorithm}[thpb] \\caption{algorithm name} \\label{algorithmlabel} \\begin{algorithmic}[1] \\Require algorithm input \\Ensure algorithm output \\State algorithm content1; \\While{while loop} \\State algorithm content2;\\EndWhile \\\\ \\Return algorithm output. \\end{algorithmic} \\end{algorithm} 完成之后呈现为这种状态 注意： 在while之后不要忘记endwhile while内部的代码会自动缩近 ","date":"2021-09-08","objectID":"/latex_learning2/:1:0","tags":["Latex"],"title":"Latex 语法学习笔记2","uri":"/latex_learning2/"},{"categories":["Latex"],"content":"各种文件 .bib 存放参考文献 .tex 文献源码 .bst 参考文献风格，与.bib组合使用 .sty 风格文件 ","date":"2021-09-08","objectID":"/latex_learning2/:2:0","tags":["Latex"],"title":"Latex 语法学习笔记2","uri":"/latex_learning2/"},{"categories":["Latex"],"content":"overleaf 使用 overleaf 左下角为文章结构 方便快速定位到tex代码文件的位置 ","date":"2021-09-08","objectID":"/latex_learning1/:1:0","tags":["Latex"],"title":"Latex 语法学习笔记1","uri":"/latex_learning1/"},{"categories":["Latex"],"content":"图片的插入与引用 插入 \\begin{figure}[t] \\centering \\includegraphics[scale=0.25]{intro.png} \\caption{描述} \\label{pic-label} \\vspace{-0.4cm} \\end{figure} \\centering 放置位置剧中 \\includegraphics[scale=0.25]{intro.png} 图片名称（同一目录下）及大小 \\caption{描述}图片下方的描述 \\label{pic-label}图片的引用 引用 Fig. \\ref{pic-label} 此处的pic-label 即为图片插入时的图片引用 ","date":"2021-09-08","objectID":"/latex_learning1/:2:0","tags":["Latex"],"title":"Latex 语法学习笔记1","uri":"/latex_learning1/"},{"categories":["Latex"],"content":"文献的插入与引用 首先bib文件中加入此格式的代码 @article{cosio2004autonomous, title={Autonomous robot navigation using adaptive potential fields}, author={Cos{\\'\\i}o, F Arambula and Casta{\\~n}eda, MA Padilla}, journal={Mathematical and Computer Modelling}, volume={40}, number={9-10}, pages={1141--1156}, year={2004} } 在tex文件中加入对bib文件和bst文献的支持 \\bibliographystyle{IEEEtranS} \\bibliography{IEEEexample} 最后在tex文件中引用该文献， 此处引用label为 cosio2004autonomous ~\\cite{cosio2004autonomous} ","date":"2021-09-08","objectID":"/latex_learning1/:3:0","tags":["Latex"],"title":"Latex 语法学习笔记1","uri":"/latex_learning1/"}]