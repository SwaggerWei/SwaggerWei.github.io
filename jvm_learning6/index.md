# JVM 学习6


## 遇到OOM错误的处理方式
* 尝试扩大对内存空间大小 
* 能够看到代码第几行出错：内存快照工具（MAT， Jprofiler）
### MAT(eclipse)/Jprofiler(IDEA)作用
* 分析Dump内存文件，快速定位内存泄漏问题
* 获取堆中的数据
* 获的大的对象
### 使用Jprofiler 查看内存快照
![](/image_JVM/pic19.png)
* 命令`-Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError`，得到内存快照.hprof文件，使用Jprofiler打开，存放在模块级别的目录下
![](/image_JVM/pic17.png)
* Jprofiler 中可以查看的内容如下
![](/image_JVM/pic18.png)
* 查看思路：先看大的对象在Current Object Set 中查看
![](/image_JVM/pic20.png)
* 再进Thread Dump中查看是哪个线程的哪行代码出现问题
![](/image_JVM/pic21.png)

## GC补充知识点
![](/image_JVM/pic22.png)
* GC的作用区域为方法区和堆当中
* 垃圾回收只能JVM自行处理，程序员不能手动回收，只能提醒
* JVM进行垃圾回收时，并不是对三个区域（新生区，幸存区from，幸存区to，老年区）统一回收，大部分时候都是回收新生区
### GC的分类
* 轻GC（普通GC）：只针对新生代，偶尔针对幸存区
* 重GC（全局GC）：所有的内容都把内存释放掉
### 例题
* JVM的内存模型和分区，详细到每个区放什么
* 堆里面的分区有哪些
* GC算法有哪些：标记清除法、标记整理（标记压缩）法、复制算法、引用计数器
* 轻GC和重GC分别在什么时候发生

## GC常用算法
### 引用计数法
* 对象引用次数进行计数
* 计数器本身也有消耗，这种方法并不高效 
* 淘汰使用少的对象（python用的就是这种方法）
### 复制算法
* 年轻代（伊甸园区，from，to）主要用的复制算法
* 幸存区的from和to区之间的交换遵循：谁空谁是to
* 每次GC之后都会将伊甸园区中活对象，都会进入到幸存区，此时伊甸园区变为空的
* from 和 to之间会不停地交换 
* 通过from 和 to 之间的复制，和身份交换，始终保证to是空的
* 当对象经过15（-XX:MaxTenuringThreshold=15, 此参数设置进入老年区所要经历的GC次数，默认是15）次GC没有被清理掉时，则进入养老区
#### 具体执行过程
* ![](/image_JVM/pic23.png)
* Eden区中活下来的部分进入to，且将From中的对象复制到to中
* ![](/image_JVM/pic24.png)
* from和to进行名称交换，保证to中始终为空，以备下次GC
* 所以每次轻GC之后，eden区是空的，to也是空的
* 经过MaxTenuringThreshold=15次轻GC之后对象在from中还没有被清理，则进入养老区
* 优点：没有内存碎片
* 坏处：浪费一半的内存区空间（to区始终是空的），假设对象100%存活（极端情况），此种算法的成本很高
* 最佳使用场景，对象存活度较低的时候，新生区
### 标记清除法
* ![](/image_JVM/pic25.png)
* 扫描对象，对活着的对象进行标记
* ![](/image_JVM/pic26.png)
* 对没有标记的对象进行清除
* 缺点：两次扫描严重浪费时间，会产生内存碎片
* 优点：不需要额外的空间
### 标记压缩算法
* ![](/image_JVM/pic27.png)
* 在标记清除的基础上进行再优化，将内存碎片进行压缩，防止内存碎片产生
* 再次扫描，向一端移动存活对象
* 多了一个移动成本
### 标记清除压缩算法
* 标记清除和标记压缩实际可以结合使用
* 经过几轮的标记清除之后，碎片多了起来，再进行标记压缩，压缩扫描的效率会高很多
### 几种算法的对比
* 内存效率：复制算法>标记清除法>标记压缩算法（时间复杂度）
* 内存整齐度（内存碎片的多少）：复制算法=标记压缩法>标记清除算法
* 内存利用率：标记压缩法=标记清除算法>复制算法
### 总结
* 没有最好的算法
* 只有最合适的算法
* GC：分代收集算法
* 年轻代：存活率低，使用复制算法
* 老年代：存活率高，区域大，使用标记清除（内存碎片不是太多）+标记压缩算法（内存碎片已经很多了）混合实现

## JMM（Java Memory Model）
* 一个缓存一致性协议，用于定义数据读写的规则
