# JVM 学习3


## 沙箱安全机制
![](/image_JVM/pic4.png)
* 限制程序运行的环境，将java代码限定在JVM特定的运行范围内
* 当前最新的安全机制实现，则引入了域(Domain) 的概念。虚拟机会把所有代码加载到不同的系统域和应用域，系统域部分专门负责与关键资源进行交互
* 各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。
* 虚拟机中不同的受保护域(Protected Domain)，对应不一样的权限 (Permission)。
* 存在于不同域中的类文件 就具有了当前域的全部权限，
### 组成沙箱的基本组件
* 字节码校验器：确保Java类文件遵循Java语言规范，并不是所有的类文件都会经过字节码校验，比如核心类
* 类装载器：防止恶意代码进行干涉（双亲委派机制）；守护了被信任类库的边界；将代码归入保护域，确定哪些代码可以进行操作

### 类装载器的工作模式方法
* 从最内层的JVM自带类加载器开始加载，防止外层恶意同名类得不到加载从而无法使用  
* 严格通过包来区分访问域，外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码自然就无法生效
* 存取控制器：存取控制器可以控制核心API对操作系统的存取权限，而这个控制策略的设定可以有用户指定
* 安全管理器：是核心API和操作系统之间的主要接口，实现权限控制，比存取控制器的优先级高
* 安全软件包：java.security下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性：安全提供者、消息摘要、数字签名keytools（eg：生成安全证书，可以访问到https）、加密、鉴别

## native 
* 凡是带了native 关键字的方法，说明java的作用范围已经达不到了，开始调用底层C++代码
* 实际上是进入了内存中的本地方法栈
* 通过本地方法栈调用本地接口JNI（Java Native Interface），使用本地方法库 
* JNI的作用，扩展Java的使用，融合不同的变成语言，为Java所用
* Java 诞生时C、C++ 程序员横行，必须要有调用C或者C++代码的能力
* 他在内存区域中转么开辟了一块标记区域--本地方法栈，登记native方法
* 在最终执行的时候通过JNI加载本地方法库中的方法  
* 调用其他接口
_eg：robot类操作电脑操作、驱动硬件、管理系统_

## PC寄存器---程序计数器（program counter register）
* 每一个线程都有一个程序计数器
* 线程是私有的，就是一个指针，指向方法区中的方法字节码（用来存储指向下一条指令的地址）
* 然后执行引擎读取下一条命令，是一个非常小的内存空间，可以忽略不计

## 方法区（method area）
* 方法区被所有线程所共享，所有定义方法的信息都保存在该区域
* _共享的内容包括：静态变量static、常量final、类信息（构造方法、接口定义）Class、运行时的常量池_
* _注意实例变量存在对内存中，和方法区无关_



